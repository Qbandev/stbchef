<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Crypto Trading Bot Chef</title>
    <link rel="icon" type="image/webp" href="static/favicon.webp">
    <link rel="stylesheet" href="static/css/styles.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Include utilities JS -->
    <script src="static/js/utils.js"></script>
    <!-- Include market analysis JS -->
    <script src="static/js/marketAnalysis.js"></script>
    <!-- Include chart handlers JS -->
    <script src="static/js/chartHandlers.js"></script>
    <!-- Include wallet manager JS -->
    <script src="static/js/walletManager.js"></script>
    <!-- Include notification manager JS -->
    <script src="static/js/notificationManager.js"></script>
    <!-- Include model predictions JS -->
    <script src="static/js/modelPredictions.js"></script>
    <!-- Include stats manager JS -->
    <script src="static/js/statsManager.js"></script>
    <script>
        // Initialize a notification permission state variable
        let notificationPermissionGranted = false;
        
        // Define global storage keys for localStorage
        window.STORAGE_KEYS = {
            WALLET: 'stbchef_wallet',
            TRADE_HISTORY: 'stbchef_trade_history',
            MODEL_PERFORMANCE: 'stbchef_model_performance',
            LAST_UPDATE: 'stbchef_last_update',
            PRICE_DATA: 'stbchef_price_data',
            VOLUME_DATA: 'stbchef_volume_data',
            TIME_LABELS: 'stbchef_time_labels'
        };
        
        // Initialize variables
        window.web3 = null;
        window.userAccount = null;
        let priceChart;
        let performanceChart;
        let priceHistory = JSON.parse(localStorage.getItem(window.STORAGE_KEYS.PRICE_DATA) || '[]');
        let timeLabels = JSON.parse(localStorage.getItem(window.STORAGE_KEYS.TIME_LABELS) || '[]');
        let volumeHistory = JSON.parse(localStorage.getItem(window.STORAGE_KEYS.VOLUME_DATA) || '[]');
        const tradingActions = [];

        // Make chart data available globally
        window.priceHistory = priceHistory;
        window.timeLabels = timeLabels;
        window.volumeHistory = volumeHistory;
        window.STORAGE_KEYS = window.STORAGE_KEYS;

        // Initialize trade history for each model
        let tradeHistory = JSON.parse(localStorage.getItem(window.STORAGE_KEYS.TRADE_HISTORY) || JSON.stringify({
            gemini: [],
            groq: [],
            mistral: []
        }));
        
        // Make tradeHistory available globally
        window.tradeHistory = tradeHistory;

        // Add accuracy tracking variables
        let aiAccuracy = JSON.parse(localStorage.getItem(window.STORAGE_KEYS.MODEL_PERFORMANCE) || JSON.stringify({
            gemini: { correct: 0, total: 0 },
            groq: { correct: 0, total: 0 },
            mistral: { correct: 0, total: 0 }
        }));
        
        // Make aiAccuracy available globally
        window.aiAccuracy = aiAccuracy;

        // Add market volatility tracking
        let marketVolatility = {
            window: 24, // 24-hour window
            data: [],
            current: 0
        };

        let lastDecisions = {
            gemini: null,
            groq: null,
            mistral: null,
            price: null
        };

        // Make lastDecisions available globally
        window.lastDecisions = lastDecisions;
        // Make marketVolatility available globally
        window.marketVolatility = marketVolatility;

        // User account is already initialized as a global variable

        // Load persisted wallet connection on page load
        window.addEventListener('load', async () => {
            // Initialize wallet card with default state first
            if (window.updateWalletCard) {
                window.updateWalletCard();
            }
            
            // Get persisted wallet connection from the server
            try {
                // Try to load from localStorage first (more reliable)
                const localWallet = localStorage.getItem(window.STORAGE_KEYS.WALLET);
                let persistedWallet = localWallet;
                
                // Try to get from server as fallback, but handle errors gracefully
                try {
                    const response = await fetch('/api/wallet/connection');
                    if (response.ok) {
                        const data = await response.json();
                        // Check if we have most_recent_wallet (from the list endpoint)
                        if (data && data.most_recent_wallet) {
                            persistedWallet = data.most_recent_wallet;
                        }
                        // Or if we have a single wallet status
                        else if (data && data.is_connected && data.wallet_address) {
                            persistedWallet = data.wallet_address;
                        }
                    }
                } catch (serverError) {
                    console.warn('Server API for wallet connections not available, using local data only:', serverError);
                    // Continue with localStorage data
                }
                
                // First check if the persisted wallet is in the disconnected accounts list
                if (persistedWallet && window.disconnectedAccounts && 
                    window.disconnectedAccounts.includes(persistedWallet?.toLowerCase())) {
                    console.log(`Persisted wallet ${persistedWallet} was previously disconnected, maintaining disconnected state`);
                    // Clear the connection state
                    localStorage.removeItem(window.STORAGE_KEYS.WALLET);
                    userAccount = null;
                    updateWalletUI();
                    displayEmptyStats();
                    
                    // Show a notification after page loads
                    setTimeout(() => {
                        showNotification(`Account ${formatWalletAddress(persistedWallet)} is disconnected. Click 'Connect Wallet' to reconnect.`, 'info');
                    }, 1000);
                    
                    // Ensure model decisions show "Connect wallet first"
                    fetch('/api/trading-data')
                        .then(response => response.json())
                        .then(data => {
                            updateModelDecisions(data, null);
                        })
                        .catch(error => {
                            console.error("Failed to fetch initial trading data:", error);
                        });
                    return;
                }
                
                if (persistedWallet && typeof window.ethereum !== 'undefined') {
                    try {
                        window.web3 = new Web3(window.ethereum);
                        
                        // First check if ethereum is connected at all
                        const isConnected = window.ethereum.isConnected();
                        if (!isConnected) {
                            console.log('MetaMask is not connected, waiting for connection...');
                            // Wait for connection
                            await new Promise(resolve => {
                                const connectionCheckInterval = setInterval(() => {
                                    if (window.ethereum.isConnected()) {
                                        clearInterval(connectionCheckInterval);
                                        resolve();
                                    }
                                }, 100);
                                // Timeout after 3 seconds
                                setTimeout(() => {
                                    clearInterval(connectionCheckInterval);
                                    resolve();
                                }, 3000);
                            });
                        }
                        
                        // Request accounts - this will NOT prompt if already connected
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        
                        // Check if the current MetaMask account is in the disconnected list
                        if (accounts && accounts.length > 0 && window.disconnectedAccounts && 
                            window.disconnectedAccounts.includes(accounts[0]?.toLowerCase())) {
                            console.log(`Current MetaMask account ${accounts[0]} was previously disconnected, maintaining disconnected state`);
                            userAccount = null;
                            updateWalletUI();
                            displayEmptyStats();
                            
                            // Show a notification
                            showNotification(`Account ${formatWalletAddress(accounts[0])} is disconnected. Click 'Connect Wallet' to reconnect.`, 'info');
                            
                            // Ensure model decisions show "Connect wallet first"
                            fetch('/api/trading-data')
                                .then(response => response.json())
                                .then(data => {
                                    updateModelDecisions(data, null);
                                })
                                .catch(error => {
                                    console.error("Failed to fetch initial trading data:", error);
                                });
                            return;
                        }
                        
                        if (accounts.length === 0) {
                            // Need to explicitly request accounts
                            try {
                                const requestedAccounts = await window.ethereum.request({ 
                                    method: 'eth_requestAccounts',
                                    params: [] 
                                });
                                
                                // Check if the requested account is in the disconnected list
                                if (requestedAccounts && requestedAccounts.length > 0 && window.disconnectedAccounts && 
                                    window.disconnectedAccounts.includes(requestedAccounts[0]?.toLowerCase())) {
                                    console.log(`Requested account ${requestedAccounts[0]} was previously disconnected, maintaining disconnected state`);
                                    userAccount = null;
                                    updateWalletUI();
                                    displayEmptyStats();
                                    
                                    // Show a notification
                                    showNotification(`Account ${formatWalletAddress(requestedAccounts[0])} is disconnected. Click 'Connect Wallet' to reconnect.`, 'info');
                                    
                                    // Ensure model decisions show "Connect wallet first"
                                    fetch('/api/trading-data')
                                        .then(response => response.json())
                                        .then(data => {
                                            updateModelDecisions(data, null);
                                        })
                                        .catch(error => {
                                            console.error("Failed to fetch initial trading data:", error);
                                        });
                                    return;
                                }
                                
                                if (requestedAccounts.length > 0 && 
                                    requestedAccounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                                    userAccount = requestedAccounts[0];
                                } else if (requestedAccounts.length > 0) {
                                    // Different account than stored
                                    userAccount = requestedAccounts[0];
                                    persistWalletConnection(userAccount);
                                }
                            } catch (err) {
                                console.log('User rejected connection or request failed:', err);
                                    // Mark current wallet as disconnected
                                    if (persistedWallet) {
                                        persistWalletConnection(null);
                                    }
                                userAccount = null;
                                updateWalletUI();
                                return;
                            }
                        } else if (accounts[0] && accounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                            userAccount = accounts[0];
                        } else if (accounts.length > 0) {
                            // If account is available but different from stored one, update it
                            userAccount = accounts[0];
                            persistWalletConnection(userAccount);
                        }
                        
                        if (userAccount) {
                            updateWalletUI();
                            
                            // Fetch initial wallet data
                            await getWalletBalances();
                            
                            // Ensure model decisions are updated with wallet connection status
                            fetch('/api/trading-data')
                                .then(response => response.json())
                                .then(data => {
                                    updateModelDecisions(data, userAccount);
                                })
                                .catch(error => {
                                    console.error("Failed to fetch initial trading data:", error);
                                });
                                
                            // Load wallet-specific stats
                            fetchWalletStats();
                            
                            // Setup session persistence - check connection status periodically
                            setInterval(async () => {
                                if (typeof window.ethereum !== 'undefined') {
                                    const isStillConnected = window.ethereum.isConnected();
                                    const currentAccounts = await window.ethereum.request({ method: 'eth_accounts' })
                                        .catch(() => []);
                                    
                                    // If metamask disconnected or account changed unexpectedly
                                    if (!isStillConnected || currentAccounts.length === 0 || 
                                        (userAccount && currentAccounts[0].toLowerCase() !== userAccount.toLowerCase())) {
                                        // Attempt to reconnect silently
                                        if (isStillConnected && currentAccounts.length === 0) {
                                            try {
                                                const reconnectAccounts = await window.ethereum.request({ 
                                                    method: 'eth_requestAccounts',
                                                    params: [] 
                                                }).catch(() => []);
                                                
                                                if (reconnectAccounts.length > 0) {
                                                    userAccount = reconnectAccounts[0];
                                                    persistWalletConnection(userAccount);
                                                    updateWalletUI();
                                                    await getWalletBalances();
                                                    fetchWalletStats();
                                                }
                                            } catch (e) {
                                                // Silent reconnect failed, don't bother user
                                                console.log('Silent reconnect failed:', e);
                                            }
                                        }
                                    }
                                }
                            }, 10000); // Check every 10 seconds
                        }
                    } catch (error) {
                        console.error('Error restoring wallet connection:', error);
                            // Mark as disconnected
                            persistWalletConnection(null);
                        userAccount = null;
                        updateWalletUI();
                    }
                } else {
                    // Ensure model decisions show "Connect wallet first"
                    fetch('/api/trading-data')
                        .then(response => response.json())
                        .then(data => {
                            updateModelDecisions(data, null);
                        })
                        .catch(error => {
                            console.error("Failed to fetch initial trading data:", error);
                        });
                }
            } catch (error) {
                console.error('Error fetching wallet connections from server:', error);
                // Fallback to no wallet connected
                userAccount = null;
                updateWalletUI();
            }
            
            clearExpiredData();
            
            // Setup visibility change handler to refresh wallet connection when tab becomes visible again
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    // Tab is now visible, check wallet connection
                    try {
                        // Use localStorage as source of truth
                        const localWallet = localStorage.getItem(window.STORAGE_KEYS.WALLET);
                        let persistedWallet = localWallet;
                        
                        // Try server, but don't depend on it
                        try {
                            const response = await fetch('/api/wallet/connection');
                            if (response.ok) {
                                const data = await response.json();
                                // Check if we have most_recent_wallet (from the list endpoint)
                                if (data && data.most_recent_wallet) {
                                    persistedWallet = data.most_recent_wallet;
                                }
                                // Or if we have a single wallet status
                                else if (data && data.is_connected && data.wallet_address) {
                                    persistedWallet = data.wallet_address;
                                }
                            }
                        } catch (serverError) {
                            console.warn('Server API for wallet connections not available on visibility change, using local data:', serverError);
                            // Continue with localStorage data
                        }
                        
                        if (typeof window.ethereum !== 'undefined') {
                            try {
                                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                                
                                if (accounts.length > 0) {
                                    const currentAccount = accounts[0].toLowerCase();
                                    
                                    // First check if the current account is in the disconnected list
                                    if (window.disconnectedAccounts && window.disconnectedAccounts.includes(currentAccount)) {
                                        console.log(`Tab visible: Account ${accounts[0]} was previously disconnected, maintaining disconnected state`);
                                        // Clear the connection in our app
                                        userAccount = null;
                                        updateWalletUI();
                                        displayEmptyStats();
                                        // Show notification to remind user
                                        showNotification(`Account ${formatWalletAddress(accounts[0])} is disconnected. Click 'Connect Wallet' to reconnect.`, 'info');
                                        return;
                                    }
                                    
                                    // Otherwise, handle normal account changes
                                    if (!userAccount || accounts[0].toLowerCase() !== userAccount.toLowerCase()) {
                                        userAccount = accounts[0];
                                        persistWalletConnection(userAccount);
                                        updateWalletUI();
                                        await getWalletBalances();
                                        fetchWalletStats();
                                        
                                        // Update LLM decisions for the new account
                                        const tradingData = await fetch('/api/trading-data').then(res => res.json());
                                        updateModelDecisions(tradingData, userAccount);
                                    }
                                } else if (userAccount) {
                                    // We have a userAccount but ethereum doesn't show any accounts
                                    // Try silently reconnecting
                                    try {
                                        const reconnectAccounts = await window.ethereum.request({ 
                                            method: 'eth_requestAccounts',
                                            params: [] 
                                        }).catch(() => []);
                                        
                                        if (reconnectAccounts.length > 0) {
                                            userAccount = reconnectAccounts[0];
                                            persistWalletConnection(userAccount);
                                            updateWalletUI();
                                            await getWalletBalances();
                                            fetchWalletStats();
                                        } else {
                                            // Failed to reconnect silently, reset wallet state
                                            userAccount = null;
                                            persistWalletConnection(null);
                                            updateWalletUI();
                                            displayEmptyStats();
                                        }
                                    } catch (e) {
                                        // Silent reconnect failed, reset wallet state
                                        userAccount = null;
                                        persistWalletConnection(null);
                                        updateWalletUI();
                                        displayEmptyStats();
                                    }
                                }
                            } catch (error) {
                                console.error('Error checking wallet connection on visibility change:', error);
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching wallet connections on visibility change:', error);
                    }
                }
            });
        });
        
        // Define token contract ABIs
        const ERC20_ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            }
        ];
        
        // Wallet balances
        let walletBalances = {
            eth: 0,
            usdc: 0,
            ethusd: 0, // Current ETH/USD price
            totalValueUSD: 0
        };

        // Add raw accuracy tracking
        let aiRawAccuracy = JSON.parse(localStorage.getItem('stbchef_raw_accuracy') || JSON.stringify({
                        gemini: { correct: 0, total: 0, accuracy: 0 },
                        groq: { correct: 0, total: 0, accuracy: 0 },
                        mistral: { correct: 0, total: 0, accuracy: 0 }
        }));
        
        // Make aiRawAccuracy available globally
        window.aiRawAccuracy = aiRawAccuracy;

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing dashboard...');
            checkFreshSession(); // Check if storage needs clearing
            
            // Initialize UI with empty state first for model stats
            displayEmptyStats();
            
            // Initialize wallet card with empty state
            updateWalletCard();
            
            // Initialize charts before any data loading
            window.initCharts();
            
            // Check for daily reset
            checkDailyReset(); 
            
            // First, load global market data (this is not wallet-dependent)
            updateData();
            
            // Set up auto-refresh every 10 minutes
            const refreshInterval = setInterval(() => {
                console.log('Auto-refresh triggered');
                updateData();
            }, 600000);  // 10 minutes

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                clearInterval(refreshInterval);
                
                // Make sure wallet connection is saved before page unloads
                if (userAccount) {
                    // We don't use localStorage for wallet connection anymore
                    // Force a server update with wallet connection before unload
                    fetch('/api/wallet/connection', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            wallet_address: userAccount,
                            is_connected: true
                        }),
                        // Use keepalive to ensure request completes even as page unloads
                        keepalive: true
                    }).catch(() => {}); // Ignore errors on page unload
                    
                    // Also save any pending wallet stats or model decisions
                    try {
                        localStorage.setItem(window.STORAGE_KEYS.TRADE_HISTORY, JSON.stringify(tradeHistory));
                        localStorage.setItem(window.STORAGE_KEYS.MODEL_PERFORMANCE, JSON.stringify(aiAccuracy));
                        localStorage.setItem('stbchef_raw_accuracy', JSON.stringify(aiRawAccuracy));
                        localStorage.setItem(window.STORAGE_KEYS.LAST_UPDATE, Date.now().toString());
                    } catch (e) {
                        // Ignore error in case localStorage is full
                        console.error('Error saving data on unload:', e);
                    }
                }
            });
        });

        // Save trade history and model performance to localStorage
        function persistModelData() {
            localStorage.setItem(window.STORAGE_KEYS.TRADE_HISTORY, JSON.stringify(tradeHistory));
            localStorage.setItem(window.STORAGE_KEYS.MODEL_PERFORMANCE, JSON.stringify(aiAccuracy));
            // Also save timestamp of last update
            localStorage.setItem(window.STORAGE_KEYS.LAST_UPDATE, Date.now().toString());
        }
    </script>

    <!-- Info Panel Toggle Script -->
    <script>
        // Function to toggle info panel visibility
        function toggleInfoPanel() {
            // Target the info panel in the header
            const infoPanel = document.getElementById('info-panel');
            const toggleBtn = document.getElementById('info-collapse-btn').querySelector('i');
            const showText = document.querySelector('.show-when-collapsed');
            const hideText = document.querySelector('.hide-when-expanded');
            
            // Check if the panel is not displayed
            if (infoPanel && infoPanel.style.display === 'none') {
                // Show the panel
                infoPanel.style.display = 'block';
                // Update button icon
                toggleBtn.classList.remove('fa-chevron-down');
                toggleBtn.classList.add('fa-chevron-up');
                // Update text
                if (showText) showText.style.display = 'none';
                if (hideText) hideText.style.display = 'inline';
                // Save state
                localStorage.setItem('infoPanelCollapsed', 'false');
            } else {
                // Hide the panel
                if (infoPanel) infoPanel.style.display = 'none';
                // Update button icon
                toggleBtn.classList.remove('fa-chevron-up');
                toggleBtn.classList.add('fa-chevron-down');
                // Update text
                if (showText) showText.style.display = 'inline';
                if (hideText) hideText.style.display = 'none';
                // Save state
                localStorage.setItem('infoPanelCollapsed', 'true');
            }
        }
        
        // Check for panel state on page load - collapse by default
        window.addEventListener('DOMContentLoaded', () => {
            // By default, make the panel collapsed
            localStorage.setItem('infoPanelCollapsed', 'true');
            
            // Make sure all elements exist before trying to manipulate them
            const infoPanel = document.getElementById('info-panel');
            const toggleBtn = document.getElementById('info-collapse-btn')?.querySelector('i');
            const showText = document.querySelector('.show-when-collapsed');
            const hideText = document.querySelector('.hide-when-expanded');
            
            // Hide by default
            if (infoPanel) infoPanel.style.display = 'none';
            if (toggleBtn) {
                toggleBtn.classList.remove('fa-chevron-up');
                toggleBtn.classList.add('fa-chevron-down');
            }
            // Show/hide appropriate text
            if (showText) showText.style.display = 'inline';
            if (hideText) hideText.style.display = 'none';
        });
    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <!-- Header -->
    <header class="cyber-header p-4">
        <div class="container mx-auto">
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center">
                <div class="flex items-center">
                    <img src="static/robot.webp" alt="Trading Bot Chef Logo" class="header-logo">
                    <div>
                        <h1 class="cyber-title text-xl md:text-2xl">Simple Crypto Trading Bot Chef</h1>
                        <div class="flex items-center">
                            <span class="text-neon-blue text-sm mr-2">AI Crypto Trading Analyzer</span>
                            <button id="info-collapse-btn" class="text-xs text-neon-blue hover:text-white bg-black bg-opacity-50 px-2 py-0.5 rounded-full flex items-center" onclick="toggleInfoPanel()">
                                <span class="mr-1 show-when-collapsed">Show info</span>
                                <span class="mr-1 hide-when-expanded">Hide info</span>
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="flex items-center space-x-4 mt-2 md:mt-0">
                    <button id="wallet-btn" onclick="connectWallet()" class="wallet-btn px-4 py-2 rounded">
                        Connect Wallet
                    </button>
                    <a href="https://github.com/Qbandev/stbchef" target="_blank" class="cyber-btn px-4 py-2 rounded flex items-center">
                        <i class="fab fa-github mr-2"></i>
                        GitHub
                    </a>
                </div>
            </div>
            <div id="info-panel" class="mt-3 w-full bg-gradient-to-r from-cyber-dark to-black border border-neon-blue border-opacity-20 rounded-lg p-3 shadow">
                <p class="text-sm text-white mb-3">This site compares how well different AI models predict Ethereum price movements in real-time, tracking which models make the most profitable decisions.</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-xs">
                    <div class="cyber-panel p-3 rounded bg-black bg-opacity-50 border-l-2 border-neon-blue">
                        <p class="mb-2 font-bold text-neon-blue">Dashboard Features:</p>
                        <p class="mb-1 text-white"><span class="text-neon-blue mr-1">→</span> Live ETH price data feeds these AI models</p>
                        <p class="mb-1 text-white"><span class="text-neon-blue mr-1">→</span> Each AI independently decides: BUY, SELL, or HOLD</p>
                        <p class="text-white"><span class="text-neon-blue mr-1">→</span> Dashboard tracks AI performance accuracy</p>
                    </div>
                    <div class="cyber-panel p-3 rounded bg-black bg-opacity-50 border-l-2 border-neon-purple">
                        <p class="mb-2 font-bold text-neon-purple">Wallet Connection:</p>
                        <p class="mb-1 text-white"><span class="text-neon-purple mr-1">→</span> <strong>Connect a wallet</strong> to see personalized metrics</p>
                        <p class="mb-1 text-white"><span class="text-neon-purple mr-1">→</span> View your portfolio allocation & suggestions</p>
                        <p class="text-white"><span class="text-neon-purple mr-1">→</span> <em>No actual trading (Just notifications) - research only</em></p>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4 mt-4">
        <div class="grid grid-cols-1 gap-6">
            <!-- ETH/USDC Live Price Card (Full Width) -->
            <div class="cyber-card p-6 rounded-lg shadow mb-6">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
                    <h2 class="text-xl font-semibold cyber-title">ETH/USDC <span class="text-sm text-gray-400">Live Price</span></h2>
                    <div class="flex items-center space-x-4 mt-2 md:mt-0">
                        <div>
                            <span class="text-gray-400 text-sm">Current Price:</span>
                            <span id="eth-price" class="text-2xl font-bold ml-2 cyber-value animate-pulse">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400 text-sm">24h Vol:</span>
                            <span id="eth-volume" class="text-sm font-bold ml-2 cyber-value">-</span>
                        </div>
                    </div>
                </div>
                <!-- ETH Price Chart (Integrated) -->
                <div class="h-64 relative" id="price-chart-container">
                    <canvas id="price-chart"></canvas>
                </div>
                <!-- Price & Gas Info -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                    <!-- Price Data -->
                    <div class="flex justify-between items-center">
                        <div>
                            <span class="text-gray-400">24h High:</span>
                            <span id="eth-high" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">24h Low:</span>
                            <span id="eth-low" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">Sentiment:</span>
                            <span id="sentiment" class="ml-1 px-2 py-0.5 rounded-full text-xs font-semibold bg-gray-700 text-gray-300">-</span>
                        </div>
                    </div>
                    <!-- Gas Prices (Linea) -->
                    <div class="flex justify-between items-center">
                        <div></div> <!-- Empty div to push content to right -->
                        <div class="flex items-center space-x-4">
                            <span class="text-gray-400">Gas Prices:</span>
                            <div class="flex space-x-4">
                                <div class="text-center">
                                    <span class="text-green-400 text-sm mr-1">Low:</span>
                                    <span id="gas-low" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-yellow-400 text-sm mr-1">Medium:</span>
                                    <span id="gas-standard" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-red-400 text-sm mr-1">High:</span>
                                    <span id="gas-fast" class="text-sm font-bold cyber-value">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Wallet Status Card (Full Width) -->
            <div id="wallet-card" class="cyber-card rounded-lg shadow p-6 mb-6">
                <!-- Content dynamically generated by JavaScript -->
            </div>
            
            <!-- AI Model Recommendations -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Gemini AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Gemini AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="gemini-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Gemini 1.5 Flash</div>
                    </div>
                </div>

                <!-- Groq AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Groq AI</h2>
                        <svg class="w-6 h-6 text-neon-purple" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="groq-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by DeepSeek-R1-Distill-Llama-70B</div>
                    </div>
                </div>

                <!-- Mistral AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Mistral AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10l3.5 3.5m0-6.5L13 10m6 0l-3.5 3.5M7 10l-3.5 3.5m0-6.5L7 10m-6 0l3.5 3.5" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="mistral-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Mistral Large</div>
                    </div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">Model Performance</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Gemini Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-blue">Gemini AI</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="gemini-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="gemini-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-blue">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="gemini-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Groq Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-purple">Groq DeepSeek</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="groq-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="groq-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-purple">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="groq-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Mistral Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-green">Mistral AI</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="mistral-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="mistral-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-green">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="mistral-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>
</body>
</html> 
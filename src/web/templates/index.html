<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Crypto Trading Bot Chef</title>
    <link rel="icon" type="image/webp" href="static/favicon.webp">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-purple: #9d00ff;
            --neon-pink: #ff0099;
            --cyber-black: #0a0a0f;
            --cyber-dark: #1a1a2e;
            --cyber-text: #e2e8f0;
        }
        body {
            background: var(--cyber-black);
            color: var(--cyber-text);
            font-family: 'Courier New', monospace;
            background-image: 
                linear-gradient(45deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(-45deg, rgba(157, 0, 255, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: center;
        }
        .cyber-card {
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
        }
        .cyber-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            animation: scan-line 2s linear infinite;
        }
        @keyframes scan-line {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .cyber-title {
            color: var(--neon-blue);
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.7);
            position: relative;
        }
        .cyber-value {
            color: var(--neon-purple);
            text-shadow: 0 0 10px rgba(157, 0, 255, 0.7);
            position: relative;
        }
        .cyber-btn {
            background: transparent;
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.7);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .cyber-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            background: rgba(0, 243, 255, 0.2);
            transform: translate(-50%, -50%) rotate(45deg);
            transition: all 0.3s ease;
            opacity: 0;
        }
        .cyber-btn:hover::before {
            opacity: 1;
        }
        .cyber-btn:hover {
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
            transform: translateY(-2px);
        }
        .chart-container {
            border: 1px solid var(--neon-blue);
            background: rgba(26, 26, 46, 0.8);
            height: 400px;
            box-shadow: inset 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        .header-logo {
            max-width: 60px;
            height: auto;
            filter: drop-shadow(0 0 15px rgba(0, 243, 255, 0.7));
            animation: pulse 2s ease-in-out infinite;
            margin-right: 1rem;
        }
        @keyframes pulse {
            0% { filter: drop-shadow(0 0 15px rgba(0, 243, 255, 0.7)); }
            50% { filter: drop-shadow(0 0 25px rgba(157, 0, 255, 0.7)); }
            100% { filter: drop-shadow(0 0 15px rgba(0, 243, 255, 0.7)); }
        }
        .cyber-header {
            background: rgba(26, 26, 46, 0.8);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        .cyber-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            animation: scan-line 2s linear infinite;
        }
        @media (max-width: 768px) {
            .header-logo {
                max-width: 60px;
            }
            .chart-container {
                height: 300px;
            }
            .grid-cols-3 {
                grid-template-columns: 1fr;
            }
        }
        .wallet-btn {
            background: linear-gradient(45deg, var(--neon-purple), var(--neon-pink));
            border: 1px solid var(--neon-purple);
            color: white;
            text-shadow: 0 0 5px rgba(157, 0, 255, 0.7);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .wallet-btn:hover {
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
            box-shadow: 0 0 20px rgba(157, 0, 255, 0.5);
            transform: translateY(-2px);
        }
        .wallet-btn.connected {
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
            border: 1px solid var(--neon-blue);
        }
        .wallet-btn.connected:hover {
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
        }
        .cyber-btn-small {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            text-transform: uppercase;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem;
            border-radius: 0.5rem;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid var(--neon-purple);
            color: white;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 0 20px rgba(157, 0, 255, 0.3);
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        /* Custom Tooltip Styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        .tooltip {
            visibility: hidden;
            position: fixed;
            z-index: 9999;
            padding: 8px 12px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid var(--neon-blue);
            border-radius: 4px;
            color: var(--cyber-text);
            font-size: 0.875rem;
            white-space: pre-line;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
            min-width: 200px;
            backdrop-filter: blur(5px);
            transform: translateX(-50%) translateY(-100%);
            margin-top: -10px;
        }
        .tooltip::after {
            content: "";
            position: absolute;
            bottom: -5px;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent var(--neon-blue) transparent;
        }
        .tooltip-container:hover .tooltip,
        .tooltip-container:focus-within .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-trigger {
            cursor: help;
        }
        .spinner {
            color: var(--neon-blue);
            font-size: 1.5rem;
            animation: pulse 2s infinite;
        }
        .network-btn {
            background: rgba(10, 10, 20, 0.4);
            border: 1px solid transparent;
            color: var(--cyber-text);
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            min-width: 120px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        .network-btn:not(.network-active) {
            animation: subtle-pulse 3s infinite;
        }
        @keyframes subtle-pulse {
            0% { box-shadow: 0 0 0px rgba(0, 243, 255, 0); }
            50% { box-shadow: 0 0 8px rgba(0, 243, 255, 0.3); }
            100% { box-shadow: 0 0 0px rgba(0, 243, 255, 0); }
        }
        .network-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 243, 255, 0.2), transparent);
            transition: 0.5s;
        }
        .network-btn:hover::before {
            left: 100%;
        }
        .network-btn:hover {
            border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
            color: var(--neon-blue);
            transform: translateY(-2px);
        }
        .network-active {
            color: var(--neon-blue);
            border-color: var(--neon-blue);
            background: rgba(0, 243, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
        }
        .network-icon {
            margin-right: 0.5rem;
            width: 20px;
            height: 20px;
        }
        .eth-icon {
            color: #627eea;
        }
        .linea-icon {
            color: #00ABFF;
            background-color: #121212;
            border-radius: 50%;
        }
        .active-indicator {
            font-size: 0.75rem;
            margin-left: 0.5rem;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
            animation: pulse 2s infinite;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        // Initialize a notification permission state variable
        let notificationPermissionGranted = false;
        
        // Storage keys for persisting data
        const STORAGE_KEYS = {
            WALLET: 'stbchef_wallet',
            HISTORY: 'stbchef_history',
            LAST_UPDATE: 'stbchef_last_update',
            PRICE_DATA: 'stbchef_price_data',
            VOLUME_DATA: 'stbchef_volume_data',
            TIME_LABELS: 'stbchef_time_labels',
            TRADE_HISTORY: 'stbchef_trade_history',
            MODEL_PERFORMANCE: 'stbchef_model_performance'
        };
        
        // Logger function to centralize logging
        function logToServer(level, message, context = {}) {
            // Always log to console
            if (level === 'error') {
                console.error(message, context);
            } else if (level === 'warn') {
                console.warn(message, context);
            } else {
                console.log(message, context);
            }
            
            // Send logs to server for important events
            if (level === 'error' || level === 'warn') {
                try {
                    fetch('/api/log', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            level,
                            message,
                            context,
                            timestamp: new Date().toISOString(),
                            userAgent: navigator.userAgent,
                            url: window.location.href
                        })
                    }).catch(err => console.error('Error sending log to server:', err));
                } catch (e) {
                    // Fail silently - don't let logging errors create more errors
                    console.error('Failed to send log to server:', e);
                }
            }
        }

        // Initialize variables
        let web3;
        let userAccount;
        let priceChart;
        let performanceChart;
        let priceHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.PRICE_DATA) || '[]');
        let timeLabels = JSON.parse(localStorage.getItem(STORAGE_KEYS.TIME_LABELS) || '[]');
        let volumeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.VOLUME_DATA) || '[]');
        const tradingActions = [];

        // Initialize trade history for each model
        let tradeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.TRADE_HISTORY) || JSON.stringify({
            gemini: [],
            groq: [],
            mistral: []
        }));

        // Add accuracy tracking variables
        let aiAccuracy = JSON.parse(localStorage.getItem(STORAGE_KEYS.MODEL_PERFORMANCE) || JSON.stringify({
            gemini: { correct: 0, total: 0 },
            groq: { correct: 0, total: 0 },
            mistral: { correct: 0, total: 0 }
        }));

        // Add market volatility tracking
        let marketVolatility = {
            window: 24, // 24-hour window
            data: [],
            current: 0
        };

        function calculateVolatility(price) {
            marketVolatility.data.push(price);
            if (marketVolatility.data.length > marketVolatility.window * 60) { // 60 data points per hour
                marketVolatility.data.shift();
            }

            if (marketVolatility.data.length > 1) {
                const returns = marketVolatility.data.slice(1).map((p, i) => 
                    (p - marketVolatility.data[i]) / marketVolatility.data[i]
                );
                marketVolatility.current = Math.sqrt(returns.reduce((sum, r) => sum + r * r, 0) / returns.length) * 100;
            }
        }

        function calculateDynamicThreshold() {
            // Base threshold of 1%, adjusted by volatility
            const baseThreshold = 1.0;
            const volatilityFactor = Math.max(0.5, Math.min(2.0, marketVolatility.current));
            return baseThreshold * volatilityFactor;
        }

        function calculateTradeScore(decision, priceChangePercent, threshold) {
            let score = 0;

            // Base score for correct direction
            if (decision === 'BUY' && priceChangePercent > threshold) {
                score = 1;
            } else if (decision === 'SELL' && priceChangePercent < -threshold) {
                score = 1;
            } else if (decision === 'HOLD' && Math.abs(priceChangePercent) <= threshold) {
                score = 1;
            }

            // Bonus points for magnitude
            if (score > 0) {
                const magnitude = Math.abs(priceChangePercent) - threshold;
                score += Math.min(1, magnitude / threshold); // Up to 1 additional point
            }

            return score;
        }

        let lastDecisions = {
            gemini: null,
            groq: null,
            mistral: null,
            price: null
        };

        // Load persisted wallet connection on page load
        window.addEventListener('load', async () => {
            const persistedWallet = localStorage.getItem(STORAGE_KEYS.WALLET);
            if (persistedWallet && typeof window.ethereum !== 'undefined') {
                try {
                    web3 = new Web3(window.ethereum);
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts[0] && accounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                        userAccount = accounts[0];
                        updateWalletUI();
                        
                        // Fetch initial wallet data
                        await getWalletBalances();
                        
                        // Ensure model decisions are updated with wallet connection status
                        fetch('/api/trading-data')
                            .then(response => response.json())
                            .then(data => {
                                updateModelDecisions(data, userAccount);
                            })
                            .catch(error => {
                                console.error("Failed to fetch initial trading data:", error);
                            });
                            
                        // Load wallet-specific stats
                        fetchWalletStats();
                    } else if (accounts.length > 0) {
                        // If account is available but different from stored one, update it
                        userAccount = accounts[0];
                        persistWalletConnection(userAccount);
                        updateWalletUI();
                        
                        // Fetch initial wallet data
                        await getWalletBalances();
                        
                        // Ensure model decisions are updated with wallet connection status
                        fetch('/api/trading-data')
                            .then(response => response.json())
                            .then(data => {
                                updateModelDecisions(data, userAccount);
                            })
                            .catch(error => {
                                console.error("Failed to fetch initial trading data:", error);
                            });
                            
                        // Load wallet-specific stats
                        fetchWalletStats();
                    }
                } catch (error) {
                    console.error('Error restoring wallet connection:', error);
                }
            } else {
                // Ensure model decisions show "Connect wallet first"
                fetch('/api/trading-data')
                    .then(response => response.json())
                    .then(data => {
                        updateModelDecisions(data, null);
                    })
                    .catch(error => {
                        console.error("Failed to fetch initial trading data:", error);
                    });
            }
            clearExpiredData();
        });

        // Persist wallet connection
        function persistWalletConnection(account) {
            if (account) {
                localStorage.setItem(STORAGE_KEYS.WALLET, account);
            } else {
                localStorage.removeItem(STORAGE_KEYS.WALLET);
            }
        }

        // Update wallet UI
        function updateWalletUI() {
            const walletBtn = document.getElementById('wallet-btn');
            if (userAccount) {
                walletBtn.innerHTML = `${userAccount.substring(0, 6)}...${userAccount.substring(38)} <i class="fas fa-sign-out-alt ml-2"></i>`;
                walletBtn.classList.add('connected');
                walletBtn.title = 'Click to disconnect wallet';
            } else {
                walletBtn.innerHTML = 'Connect Wallet';
                walletBtn.classList.remove('connected');
                walletBtn.title = 'Connect to MetaMask';
            }
        }

        // Load persisted trading history
        function loadPersistedHistory() {
            try {
                // Only load persisted history if wallet is connected
                if (!userAccount) {
                    displayEmptyStats();
                    return;
                }
                
                const history = localStorage.getItem(STORAGE_KEYS.TRADE_HISTORY);
                const performance = localStorage.getItem(STORAGE_KEYS.MODEL_PERFORMANCE);

                if (history) {
                    tradeHistory = JSON.parse(history);
                }
                if (performance) {
                    aiAccuracy = JSON.parse(performance);
                }

                // Update UI with loaded data
                updateModelStatsDisplay();
            } catch (error) {
                console.error('Error loading persisted history:', error);
            }
        }

        // Persist trading history
        function persistTradingHistory() {
            try {
                localStorage.setItem(STORAGE_KEYS.TRADE_HISTORY, JSON.stringify(tradeHistory));
                localStorage.setItem(STORAGE_KEYS.MODEL_PERFORMANCE, JSON.stringify(aiAccuracy));
                localStorage.setItem(STORAGE_KEYS.LAST_UPDATE, Date.now().toString());
            } catch (error) {
                console.error('Error persisting history:', error);
            }
        }

        // Clear expired data
        function clearExpiredData() {
            const lastUpdate = parseInt(localStorage.getItem(STORAGE_KEYS.LAST_UPDATE) || '0');
            if (Date.now() - lastUpdate > 24 * 60 * 60 * 1000) {
                localStorage.removeItem(STORAGE_KEYS.TRADE_HISTORY);
                localStorage.removeItem(STORAGE_KEYS.MODEL_PERFORMANCE);
                localStorage.removeItem(STORAGE_KEYS.LAST_UPDATE);
                localStorage.removeItem(STORAGE_KEYS.PRICE_DATA);
                localStorage.removeItem(STORAGE_KEYS.VOLUME_DATA);
                localStorage.removeItem(STORAGE_KEYS.TIME_LABELS);
            }
        }

        // Modified wallet connection function
        async function connectWallet() {
            // If already connected, disconnect
            if (userAccount) {
                userAccount = null;
                web3 = null;
                resetWalletBalances();
                persistWalletConnection(null);
                updateWalletUI();
                
                // Clear model performance when disconnecting
                displayEmptyStats();
                
                // Update LLM decision cards to show "Connect wallet first"
                const tradingData = await fetch('/api/trading-data').then(res => res.json());
                updateModelDecisions(tradingData, null);
                
                showNotification('Wallet disconnected', 'warning');
                return;
            }
            
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    userAccount = accounts[0];
                    web3 = new Web3(window.ethereum);

                    // Check which network we're on
                    const chainId = await web3.eth.getChainId();
                    const isLinea = chainId === 59144;
                    const isEthereum = chainId === 1;
                    
                    // Only show warning if on unsupported network, no need for confirmation on supported ones
                    if (!isLinea && !isEthereum) {
                        showNotification(`Connected to unsupported network (ID: ${chainId}). Please switch to Linea (ID: 59144) or Ethereum (ID: 1).`, 'warning');
                    }

                    persistWalletConnection(userAccount);
                    
                    // Show loading state on wallet card
                    const walletCard = document.getElementById('wallet-card');
                    if (walletCard) {
                        walletCard.innerHTML = `
                            <div class="flex flex-col">
                                <div class="flex items-center justify-between mb-3">
                                    <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                </div>
                                <div class="flex flex-col items-center justify-center h-24">
                                    <p class="text-gray-400 mb-2">Loading wallet data...</p>
                                    <div class="spinner"><i class="fas fa-sync-alt fa-spin"></i></div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Get wallet balances after connecting
                    await getWalletBalances();
                    
                    // Update model performance cards with wallet-specific data
                    fetchWalletStats();
                    
                    // Update LLM decision cards
                    const tradingData = await fetch('/api/trading-data').then(res => res.json());
                    updateModelDecisions(tradingData, userAccount);
                    
                    updateWalletUI();
                    showNotification('Wallet connected successfully!', 'success');

                    // Request notification permission after wallet connection
                    await requestNotificationPermission();

                    // Handle account changes
                    window.ethereum.on('accountsChanged', function (accounts) {
                        if (accounts.length === 0) {
                            userAccount = null;
                            resetWalletBalances();
                            persistWalletConnection(null);
                            
                            // Update model stats and LLM decisions on disconnect
                            displayEmptyStats();
                            fetch('/api/trading-data')
                                .then(res => res.json())
                                .then(data => updateModelDecisions(data, null));
                        } else {
                            userAccount = accounts[0];
                            getWalletBalances();
                            persistWalletConnection(userAccount);
                            requestNotificationPermission(); // Request permission for new account
                            
                            // Update model stats and LLM decisions on account change
                            fetchWalletStats();
                            fetch('/api/trading-data')
                                .then(res => res.json())
                                .then(data => updateModelDecisions(data, userAccount));
                        }
                        updateWalletUI();
                        showNotification(accounts.length === 0 ? 'Wallet disconnected' : 'Wallet account changed', accounts.length === 0 ? 'warning' : 'info');
                    });
                    
                    // Update balances when chain changes
                    window.ethereum.on('chainChanged', function (chainIdHex) {
                        const newChainId = parseInt(chainIdHex, 16);
                        const isLinea = newChainId === 59144;
                        const isEthereum = newChainId === 1;
                        
                        // Only show warning if on unsupported network, no need for confirmation on supported ones
                        if (!isLinea && !isEthereum) {
                            showNotification(`Switched to unsupported network (ID: ${newChainId}). Please switch to Linea (ID: 59144) or Ethereum (ID: 1).`, 'warning');
                        }
                        
                        getWalletBalances();
                        updateWalletUI();
                        
                        // Update model stats and LLM decisions on chain change
                        fetchWalletStats();
                        fetch('/api/trading-data')
                            .then(res => res.json())
                            .then(data => updateModelDecisions(data, userAccount));
                    });
                } catch (error) {
                    console.error('User denied account access:', error);
                    showNotification('Failed to connect wallet', 'error');
                }
            } else {
                showNotification('Please install MetaMask!', 'error');
            }
        }
        
        // Define token contract ABIs
        const ERC20_ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            }
        ];
        
        // Wallet balances
        let walletBalances = {
            eth: 0,
            usdc: 0,
            ethusd: 0, // Current ETH/USD price
            totalValueUSD: 0
        };
        
        // Get wallet balances
        async function getWalletBalances() {
            if (!userAccount || !web3) {
                console.log("No wallet connection available");
                resetWalletBalances();
                return;
            }
            
            try {
                console.log("Fetching wallet balances for", userAccount);
                
                // Get current network ID with timeout
                let chainId;
                try {
                    const timeout = ms => new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Chain ID request timed out')), ms));
                    
                    chainId = await Promise.race([
                        web3.eth.getChainId(),
                        timeout(3000) // 3 second timeout
                    ]);
                    console.log("Current chain ID:", chainId);
                } catch (chainError) {
                    console.error("Error getting chain ID:", chainError);
                    chainId = 0; // Use 0 as "unknown network"
                }
                
                // Check if we're on Linea (Chain ID 59144) or Ethereum (Chain ID 1)
                const isLinea = chainId === 59144;
                const isEthereum = chainId === 1;
                const isSupportedNetwork = isLinea || isEthereum;
                
                if (!isSupportedNetwork) {
                    showNotification(`Unsupported network (Chain ID: ${chainId}). Please switch to Linea or Ethereum mainnet.`, 'warning');
                    console.warn(`Unsupported network: ${chainId}`);
                }
                
                // Get ETH balance
                const ethBalance = await web3.eth.getBalance(userAccount);
                walletBalances.eth = parseFloat(web3.utils.fromWei(ethBalance, 'ether'));
                console.log("ETH balance:", walletBalances.eth);
                
                // Only try to get USDC balance if we're on a supported network
                walletBalances.usdc = 0; // Default to 0
                
                if (isLinea) {
                    // USDC on Linea
                    const lineaUsdcAddress = '0x176211869cA2b568f2A7D4EE941E073a821EE1ff';
                    try {
                        await getTokenBalance(lineaUsdcAddress);
                    } catch (contractError) {
                        console.warn("Error fetching Linea USDC balance:", contractError.message);
                    }
                } else if (isEthereum) {
                    // USDC on Ethereum Mainnet
                    const ethUsdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
                    try {
                        await getTokenBalance(ethUsdcAddress);
                    } catch (contractError) {
                        console.warn("Error fetching Ethereum USDC balance:", contractError.message);
                    }
                }
                
                // Get current ETH/USD price from the dashboard data
                const ethPriceElement = document.getElementById('eth-price');
                if (ethPriceElement) {
                    const priceText = ethPriceElement.textContent;
                    walletBalances.ethusd = parseFloat(priceText.replace('$', '').trim());
                    console.log("ETH/USD price:", walletBalances.ethusd);
                } else {
                    console.warn("ETH price element not found");
                    // Fallback price in case the element isn't found
                    walletBalances.ethusd = 3000; 
                }
                
                // Calculate total value in USD
                walletBalances.totalValueUSD = (walletBalances.eth * walletBalances.ethusd) + walletBalances.usdc;
                console.log("ETH value in USD:", walletBalances.eth * walletBalances.ethusd);
                console.log("USDC value:", walletBalances.usdc);
                console.log("Total wallet value:", walletBalances.totalValueUSD, "USD");
                
                // Make sure we have a valid total - if somehow it's still 0 or NaN, set a minimum value
                if (!walletBalances.totalValueUSD || isNaN(walletBalances.totalValueUSD) || walletBalances.totalValueUSD <= 0) {
                    if (walletBalances.eth > 0) {
                        // If we have ETH but totalValue calculation failed, use the ETH value
                        walletBalances.totalValueUSD = walletBalances.eth * walletBalances.ethusd;
                        console.log("Using ETH-only value:", walletBalances.totalValueUSD, "USD");
                    }
                }
                
                // Update the wallet card
                updateWalletCard();
                
                // Update model stats to reflect wallet-based operations
                if (isSupportedNetwork) {
                    updateModelStatsForWallet();
                } else {
                    console.log("Skipping model stats update for unsupported network");
                }
                
                return walletBalances;
            } catch (error) {
                logToServer('error', "Error fetching wallet balances", error);
                showNotification("Error fetching wallet balances: " + error.message, "error");
                resetWalletBalances();
                return null;
            }
        }
        
        // Get token balance helper function
        async function getTokenBalance(tokenAddress) {
            try {
                console.log(`Attempting to fetch token balance for ${tokenAddress}`);
                
                // Create contract instance with error checking
                let tokenContract;
                try {
                    tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
                } catch (contractError) {
                    throw new Error(`Failed to create contract instance: ${contractError.message}`);
                }
                
                // Use shorter timeouts to avoid hanging
                const timeout = ms => new Promise((_, reject) => 
                    setTimeout(() => reject(new Error(`Contract call timed out after ${ms}ms`)), ms));
                
                // First check if the contract responds at all with a simple call
                try {
                    // Brief timeout for simple call
                    const contractCheck = await Promise.race([
                        tokenContract.methods.symbol().call(),
                        timeout(2000)
                    ]);
                    console.log(`Contract ${tokenAddress} responds with symbol: ${contractCheck}`);
                } catch (checkError) {
                    console.warn(`Contract not responding properly: ${checkError.message}`);
                    // Continue anyway, might still work
                }
                
                // Attempt the balance calls with shorter timeouts
                console.log(`Fetching decimals and balance from ${tokenAddress}`);
                let decimals, balance;
                
                try {
                    // Try decimals first with short timeout
                    decimals = await Promise.race([
                        tokenContract.methods.decimals().call(),
                        timeout(3000)
                    ]);
                    console.log(`Token decimals: ${decimals}`);
                } catch (decimalsError) {
                    console.warn(`Failed to get decimals: ${decimalsError.message}, using default value 6`);
                    // Default to 6 decimals for USDC as fallback
                    decimals = 6;
                }
                
                try {
                    // Try balance next with short timeout
                    balance = await Promise.race([
                        tokenContract.methods.balanceOf(userAccount).call(),
                        timeout(3000)
                    ]);
                    console.log(`Token balance (raw): ${balance}`);
                } catch (balanceError) {
                    console.warn(`Failed to get balance: ${balanceError.message}, using 0`);
                    // Default to 0 balance as fallback
                    balance = "0";
                }
                
                // Validate returned values with defensive programming
                if (balance === undefined || balance === null) {
                    console.warn("Received undefined/null balance, defaulting to 0");
                    balance = "0";
                }
                
                if (decimals === undefined || decimals === null) {
                    console.warn("Received undefined/null decimals, defaulting to 6");
                    decimals = 6;
                }
                
                // Parse values with error checking
                let decimalValue, balanceValue;
                try {
                    decimalValue = parseInt(decimals);
                    if (isNaN(decimalValue)) {
                        console.warn("Invalid decimals value, defaulting to 6");
                        decimalValue = 6;
                    }
                } catch (parseError) {
                    console.warn(`Error parsing decimals: ${parseError.message}, using default 6`);
                    decimalValue = 6;
                }
                
                try {
                    balanceValue = parseFloat(balance);
                    if (isNaN(balanceValue)) {
                        console.warn("Invalid balance value, defaulting to 0");
                        balanceValue = 0;
                    }
                } catch (parseError) {
                    console.warn(`Error parsing balance: ${parseError.message}, using 0`);
                    balanceValue = 0;
                }
                
                // Calculate final balance
                walletBalances.usdc = balanceValue / Math.pow(10, decimalValue);
                console.log(`USDC balance (formatted): ${walletBalances.usdc}`);
                return walletBalances.usdc;
            } catch (error) {
                // Log detailed error information, but don't fail catastrophically
                logToServer('error', "Token contract error", {
                    message: error.message,
                    tokenAddress: tokenAddress,
                    userAccount: userAccount,
                    chainId: web3.eth.chainId || 'unknown'
                });
                
                // Set USDC to 0 on error
                walletBalances.usdc = 0;
                return 0;
            }
        }
        
        // Reset wallet balances
        function resetWalletBalances() {
            walletBalances = {
                eth: 0,
                usdc: 0,
                ethusd: 0,
                totalValueUSD: 0
            };
            updateWalletCard();
            updateModelStatsForWallet();
        }
        
        // Update wallet card with current balances
        function updateWalletCard() {
            const walletCard = document.getElementById('wallet-card');
            if (!walletCard) return;
            
            if (!userAccount || !web3) {
                walletCard.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full">
                        <p class="text-gray-400 mb-2">Connect your wallet to see balances</p>
                    </div>
                `;
                return;
            }
            
            // Note: We will proceed even if balances are zero - we want to show network switching options
            
            // Check if we're on Linea network
            web3.eth.getChainId().then(chainId => {
                const isLinea = chainId === 59144;
                const isEthereum = chainId === 1;
                const networkName = isLinea ? 'Linea' : isEthereum ? 'Ethereum' : 'Unknown Network';
                const networkClass = isLinea || isEthereum ? 'text-green-400' : 'text-yellow-400';
                
                // Network switching buttons
                const switchNetworkButtons = isLinea || isEthereum ? `
                    <div class="col-span-2 mt-3 flex justify-center space-x-4">
                        <button onclick="${isEthereum ? 'void(0)' : 'switchNetwork(1)'}" class="network-btn ${isEthereum ? 'network-active cursor-not-allowed opacity-80' : ''} flex items-center">
                            <div class="network-icon eth-icon">
                                <svg class="w-4 h-4" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 32C24.8366 32 32 24.8366 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32ZM15.9963 5.33333L15.8 5.88333V20.2L15.9963 20.3967L22.6599 16.405L15.9963 5.33333Z" fill="#627EEA" fill-opacity="0.7"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 5.33333L9.33333 16.405L16 20.3967V13.4183V5.33333Z" fill="#627EEA"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 21.93L15.8917 22.0633V26.4117L16 26.6633L22.6667 17.94L16 21.93Z" fill="#627EEA" fill-opacity="0.7"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 26.6633V21.93L9.33333 17.94L16 26.6633Z" fill="#627EEA"/>
                                </svg>
                            </div>
                            <span>Ethereum</span>
                            ${isEthereum ? '<span class="active-indicator">●</span>' : ''}
                        </button>
                        <button onclick="${isLinea ? 'void(0)' : 'switchNetwork(59144)'}" class="network-btn ${isLinea ? 'network-active cursor-not-allowed opacity-80' : ''} flex items-center">
                            <div class="network-icon linea-icon">
                                <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 24C18.6274 24 24 18.6274 24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24Z" fill="#121212"/>
                                    <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="#00ABFF"/>
                                    <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="#00ABFF"/>
                                    <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="#00ABFF"/>
                                </svg>
                            </div>
                            <span>Linea</span>
                            ${isLinea ? '<span class="active-indicator">●</span>' : ''}
                        </button>
                    </div>
                ` : `
                    <div class="col-span-2 mt-3">
                        <div class="text-yellow-400 text-xs text-center mb-2">Switch to a supported network</div>
                        <div class="flex justify-center space-x-4">
                            <button onclick="switchNetwork(1)" class="network-btn flex items-center">
                                <div class="network-icon eth-icon">
                                    <svg class="w-4 h-4" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 32C24.8366 32 32 24.8366 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32ZM15.9963 5.33333L15.8 5.88333V20.2L15.9963 20.3967L22.6599 16.405L15.9963 5.33333Z" fill="#627EEA" fill-opacity="0.7"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 5.33333L9.33333 16.405L16 20.3967V13.4183V5.33333Z" fill="#627EEA"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 21.93L15.8917 22.0633V26.4117L16 26.6633L22.6667 17.94L16 21.93Z" fill="#627EEA" fill-opacity="0.7"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 26.6633V21.93L9.33333 17.94L16 26.6633Z" fill="#627EEA"/>
                                    </svg>
                                </div>
                                <span>Ethereum</span>
                            </button>
                            <button onclick="switchNetwork(59144)" class="network-btn flex items-center">
                                <div class="network-icon linea-icon">
                                    <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 24C18.6274 24 24 18.6274 24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24Z" fill="#121212"/>
                                        <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="#00ABFF"/>
                                        <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="#00ABFF"/>
                                        <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="#00ABFF"/>
                                    </svg>
                                </div>
                                <span>Linea</span>
                            </button>
                        </div>
                    </div>
                `;
                
                // Calculate optimal action based on current portfolio allocation
                // Add validation to ensure we have valid ETH price before calculations
                const ethValue = walletBalances.eth || 0;
                const usdcValue = walletBalances.usdc || 0;
                const ethPrice = walletBalances.ethusd || 0;
                
                // Skip detailed allocation calculations if price is invalid
                if (ethPrice <= 0 || isNaN(ethPrice)) {
                    // Render basic card without allocation recommendations
                    walletCard.innerHTML = `
                        <div class="p-4">
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                <div class="flex items-center">
                                    <span class="text-xs ${networkClass} mr-2">Network: ${networkName}</span>
                                    <span class="text-xs text-gray-400">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>
                                    <div class="text-gray-400">ETH Balance:</div>
                                    <div class="font-bold text-cyber-text">${ethValue.toFixed(4)} ETH</div>
                                    <div class="text-xs text-gray-400">Price data unavailable</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">USDC Balance:</div>
                                    <div class="font-bold text-cyber-text">${usdcValue.toFixed(2)} USDC</div>
                                    <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                                </div>
                                ${switchNetworkButtons}
                                <div class="col-span-2 mt-3 text-center text-yellow-400">
                                    <p>Unable to calculate allocation - price data unavailable</p>
                                </div>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                const ethValueUSD = ethValue * ethPrice;
                const totalValue = (ethValueUSD + usdcValue) || 0;
                
                // Handle zero balance case properly with additional validation
                const hasNonZeroBalance = (ethValue > 0 || usdcValue > 0) && totalValue > 0;
                const currentEthAllocation = hasNonZeroBalance ? Math.min(100, Math.max(0, (ethValueUSD / totalValue * 100))) : 0;
                const currentUsdcAllocation = hasNonZeroBalance ? Math.min(100, Math.max(0, 100 - currentEthAllocation)) : 0;
                
                // Target allocation range: 60-80% ETH in bullish, 20-40% in bearish
                const marketSentiment = document.getElementById('sentiment');
                const isBullish = marketSentiment && marketSentiment.textContent.includes('bullish');
                
                const targetEthMin = isBullish ? 60 : 20;
                const targetEthMax = isBullish ? 80 : 40;
                
                // Instead of portfolio-based decision, use AI consensus or latest decisions if available
                let recommendedAction = 'HOLD';
                let swapAmount = 0;
                let swapDirection = '';
                
                // Get decisions from AI models
                const geminiDecision = document.getElementById('gemini-decision');
                const groqDecision = document.getElementById('groq-decision');
                const mistralDecision = document.getElementById('mistral-decision');
                
                const decisions = {
                    gemini: geminiDecision ? geminiDecision.textContent : null,
                    groq: groqDecision ? groqDecision.textContent : null,
                    mistral: mistralDecision ? mistralDecision.textContent : null
                };
                
                // Check for consensus
                const aiConsensus = checkLLMConsensus(decisions);
                if (aiConsensus) {
                    recommendedAction = aiConsensus;
                } else if (totalValue > 0) {
                    // Fall back to portfolio-based recommendation if no consensus
                    if (currentEthAllocation < targetEthMin) {
                        recommendedAction = 'BUY';
                        const targetEthValue = (totalValue * targetEthMin / 100);
                        swapAmount = targetEthValue - ethValueUSD;
                        swapDirection = 'USDC → ETH';
                    } else if (currentEthAllocation > targetEthMax) {
                        recommendedAction = 'SELL';
                        const targetEthValue = (totalValue * targetEthMax / 100);
                        swapAmount = ethValueUSD - targetEthValue;
                        swapDirection = 'ETH → USDC';
                    }
                }
                
                // Get recommending models
                let recommendingModels = [];
                if (decisions.gemini === recommendedAction) recommendingModels.push('Gemini');
                if (decisions.groq === recommendedAction) recommendingModels.push('Groq');
                if (decisions.mistral === recommendedAction) recommendingModels.push('Mistral');
                
                const modelText = recommendingModels.length > 0 
                    ? `<div class="text-xs mt-1 text-gray-300">Recommended by: ${recommendingModels.join(', ')}</div>` 
                    : '';
                
                // Modify the portfolio allocation bar display for zero balances
                const portfolioAllocationBar = hasNonZeroBalance 
                    ? `<div class="w-full bg-gray-700 rounded-full h-2.5 mt-1 relative">
                        <div class="${getPortfolioBarColor(currentEthAllocation, targetEthMin, targetEthMax)} h-2.5 rounded-full" style="width: ${currentEthAllocation}%"></div>
                        
                        <!-- Target range indicators -->
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMin}%; height: 100%;"></div>
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMax}%; height: 100%;"></div>
                      </div>
                      <div class="flex justify-between text-xs mt-1">
                        <span>ETH: ${currentEthAllocation.toFixed(1)}%</span>
                        <span>USDC: ${currentUsdcAllocation.toFixed(1)}%</span>
                      </div>`
                    : `<div class="w-full bg-gray-700 rounded-full h-2.5 mt-1 relative">
                        <div class="bg-gray-600 h-2.5 rounded-full" style="width: 0%"></div>
                        
                        <!-- Target range indicators -->
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMin}%; height: 100%;"></div>
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMax}%; height: 100%;"></div>
                      </div>
                      <div class="flex justify-center text-xs mt-1">
                        <span class="text-gray-400">(Empty Portfolio)</span>
                      </div>`;
                
                // Recommendation section based on whether we have balances and AI decisions
                const recommendationSection = `
                    <div class="col-span-2 mt-3 mb-1 space-y-2">
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Recommended Action:</span>
                            <span class="font-bold ${
                                recommendedAction === 'BUY' ? 'text-green-400' :
                                recommendedAction === 'SELL' ? 'text-red-400' :
                                'text-blue-400'
                            }">${recommendedAction}</span>
                        </div>
                        ${recommendingModels.length > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Recommended by:</span>
                            <span class="text-gray-300">${recommendingModels.join(', ')}</span>
                        </div>
                        ` : ''}
                        ${swapAmount > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Suggested Swap:</span>
                            <span class="text-gray-300">~$${swapAmount.toFixed(2)} ${swapDirection}</span>
                        </div>
                        ` : ''}
                        ${totalValue > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Target Allocation:</span>
                            <span class="text-gray-300">${targetEthMin}%-${targetEthMax}% ETH in ${isBullish ? 'bullish' : 'bearish'} market</span>
                        </div>
                        ` : ''}
                    </div>
                `;
                
                walletCard.innerHTML = `
                    <div class="p-4">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            <div class="flex items-center">
                                <span class="text-xs ${networkClass} mr-2">Network: ${networkName}</span>
                                <span class="text-xs text-gray-400">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>
                                <div class="text-gray-400">ETH Balance:</div>
                                <div class="font-bold text-cyber-text">${ethValue.toFixed(4)} ETH</div>
                                <div class="text-xs text-gray-400">$${(ethValue * ethPrice).toFixed(2)}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">USDC Balance:</div>
                                <div class="font-bold text-cyber-text">${usdcValue.toFixed(2)} USDC</div>
                                <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                            </div>
                            
                            <div class="col-span-2 mt-2">
                                <div class="text-gray-400">Portfolio Allocation:</div>
                                ${portfolioAllocationBar}
                            </div>
                            
                            ${switchNetworkButtons}
                            
                            ${recommendationSection}
                        </div>
                    </div>
                `;
            }).catch(err => {
                console.warn("Error getting chain ID:", err.message);
                
                // Fallback wallet card with error state
                walletCard.innerHTML = `
                    <div class="flex flex-col">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                        </div>
                        <div class="flex flex-col items-center justify-center h-24">
                            <p class="text-gray-400 mb-2">Error loading wallet data</p>
                            <p class="text-xs text-red-400">Network error: ${err.message}</p>
                        </div>
                    </div>
                `;
            });
        }
        
        // Function to switch networks
        async function switchNetwork(chainId) {
            if (!window.ethereum || !userAccount) {
                showNotification('MetaMask not connected', 'error');
                return;
            }
            
            try {
                // Show loading state first before attempting switch
                showLoadingWalletState("Switching networks...");
                
                // First, try to switch to the network
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x' + chainId.toString(16) }],
                });
                
                // Success notification is unnecessary - users can see the network changed in the UI
                
                // Reset wallet balances to avoid stale data
                resetWalletBalances();
                
                // Wait a bit longer for MetaMask to complete the network switch
                setTimeout(async () => {
                    try {
                        await getWalletBalances();
                        
                        // Also update model performance and LLM decision cards
                        fetchWalletStats();
                        const tradingData = await fetch('/api/trading-data').then(res => res.json());
                        updateModelDecisions(tradingData, userAccount);
                        
                        // Don't show notification for zero balances, just update the UI
                        if (walletBalances.totalValueUSD <= 0) {
                            updateWalletCard(); // Ensure card updates even with zero balances
                        }
                    } catch (error) {
                        logToServer('error', 'Error refreshing wallet balances after network switch', error);
                        showNotification("Error loading balances", "error");
                    }
                }, 2000); // Increased timeout to 2 seconds
                
            } catch (switchError) {
                // This error code indicates that the chain has not been added to MetaMask
                if (switchError.code === 4902) {
                    try {
                        if (chainId === 59144) {
                            // Add Linea network
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xE708',
                                    chainName: 'Linea Mainnet',
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://rpc.linea.build'],
                                    blockExplorerUrls: ['https://lineascan.build']
                                }]
                            });
                        } else if (chainId === 1) {
                            // Add Ethereum Mainnet (this is unlikely to be needed as it's usually pre-configured)
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x1',
                                    chainName: 'Ethereum Mainnet',
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://mainnet.infura.io/v3/'],
                                    blockExplorerUrls: ['https://etherscan.io']
                                }]
                            });
                        }
                        showNotification(`Added ${chainId === 59144 ? 'Linea' : 'Ethereum'} network to MetaMask`, 'success');
                        
                        // After adding the network, update model performance and LLM decision cards
                        setTimeout(async () => {
                            fetchWalletStats();
                            const tradingData = await fetch('/api/trading-data').then(res => res.json());
                            updateModelDecisions(tradingData, userAccount);
                        }, 1000);
                    } catch (addError) {
                        logToServer('error', 'Error adding network to MetaMask', addError);
                        showNotification('Error adding network to MetaMask', 'error');
                    }
                } else {
                    logToServer('error', 'Error switching network', switchError);
                    showNotification('Error switching network. Check MetaMask.', 'error');
                }
            }
        }
        
        // Helper function to show loading state in wallet card
        function showLoadingWalletState(message) {
            const walletCard = document.getElementById('wallet-card');
            if (walletCard) {
                walletCard.innerHTML = `
                    <div class="flex flex-col">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                        </div>
                        <div class="flex flex-col items-center justify-center h-24">
                            <p class="text-gray-400 mb-2">${message}</p>
                            <div class="spinner"><i class="fas fa-sync-alt fa-spin"></i></div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Update model stats to only show relevant operations when wallet is connected
        function updateModelStatsForWallet() {
            if (!userAccount) {
                // No wallet connected, keep using all trades
                return;
            }
            
            try {
                // Get current ETH price and portfolio values
                const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                const totalValue = walletBalances.totalValueUSD || ethValueUSD; // Fallback if totalValueUSD is 0
                
                // Skip wallet action update if we have no value or invalid price
                if (totalValue <= 0 || !walletBalances.ethusd || isNaN(walletBalances.ethusd)) {
                    console.log("Wallet has no value or invalid price, skipping wallet action update");
                    return;
                }
                
                // Get decisions from AI models - use the model's recommended action instead of portfolio-based one
                const geminiDecision = document.getElementById('gemini-decision');
                const groqDecision = document.getElementById('groq-decision');
                const mistralDecision = document.getElementById('mistral-decision');
                
                const decisions = {
                    gemini: geminiDecision ? geminiDecision.textContent : null,
                    groq: groqDecision ? groqDecision.textContent : null,
                    mistral: mistralDecision ? mistralDecision.textContent : null
                };
                
                // Check for consensus (2 out of 3 models agree)
                let walletAction = checkLLMConsensus(decisions);
                
                // If no consensus, calculate based on portfolio
                if (!walletAction) {
                    // Target allocation range: 60-80% ETH in bullish, 20-40% in bearish
                    const marketSentiment = document.getElementById('sentiment');
                    const isBullish = marketSentiment && marketSentiment.textContent.includes('bullish');
                    
                    const targetEthMin = isBullish ? 60 : 20;
                    const targetEthMax = isBullish ? 80 : 40;
                    
                    // Safely calculate ETH allocation with zero checking
                    const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                    
                    // Default to HOLD
                    walletAction = 'HOLD';
                    
                    // Only make BUY/SELL recommendations if we have some value
                    if (totalValue > 0) {
                        if (currentEthAllocation < targetEthMin) {
                            walletAction = 'BUY';
                        } else if (currentEthAllocation > targetEthMax) {
                            walletAction = 'SELL';
                        }
                    }
                }
                
                // Get current chain ID to send with the API
                web3.eth.getChainId().then(chainId => {
                    // Only send wallet action for supported networks
                    if (chainId !== 1 && chainId !== 59144) {
                        console.log(`Skipping wallet action on unsupported network ${chainId}`);
                        return;
                    }
                    
                    // Safely calculate ETH allocation again for the API call
                    const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                    const totalValue = walletBalances.totalValueUSD || ethValueUSD;
                    const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                    
                    // Update the API to indicate the wallet action
                    fetch('/api/set-wallet-action', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            wallet_address: userAccount,
                            wallet_action: walletAction,
                            eth_balance: walletBalances.eth,
                            usdc_balance: walletBalances.usdc,
                            eth_allocation: currentEthAllocation,
                            network: chainId === 59144 ? 'linea' : 'ethereum'
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.warn(`API error: ${response.status}. This is non-critical.`);
                            return null;
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data) {
                            console.log("Wallet action updated:", data);
                        }
                    })
                    .catch(error => {
                        logToServer('warn', 'Error setting wallet action (non-critical)', error);
                        // Don't show notification to avoid spamming the user
                    });
                }).catch(error => {
                    console.warn('Error getting chain ID:', error.message);
                });
            } catch (error) {
                console.warn('Error in updateModelStatsForWallet:', error.message);
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;

            // Format message with line breaks
            const formattedMessage = message.split('\n').map(line => `<div>${line}</div>`).join('');

            notification.innerHTML = `
                <div class="flex flex-col">
                    ${formattedMessage}
                </div>
            `;

            document.body.appendChild(notification);

            // Remove notification after 8 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 8000);
        }

        // Function to check if 2 out of 3 LLMs agree on a decision
        function checkLLMConsensus(decisions) {
            const buyVotes = Object.values(decisions).filter(d => d === 'BUY').length;
            const sellVotes = Object.values(decisions).filter(d => d === 'SELL').length;
            const holdVotes = Object.values(decisions).filter(d => d === 'HOLD').length;

            if (buyVotes >= 2) {
                return 'BUY';
            } else if (sellVotes >= 2) {
                return 'SELL';
            } else if (holdVotes >= 2) {
                return 'HOLD';
            }
            return null;
        }

        function getModelDecisions(decisions) {
            const modelDecisions = [];
            if (decisions.gemini === 'BUY') modelDecisions.push('Gemini');
            if (decisions.groq === 'BUY') modelDecisions.push('Groq');
            if (decisions.mistral === 'BUY') modelDecisions.push('Mistral');
            return modelDecisions;
        }

        function getModelSellDecisions(decisions) {
            const modelDecisions = [];
            if (decisions.gemini === 'SELL') modelDecisions.push('Gemini');
            if (decisions.groq === 'SELL') modelDecisions.push('Groq');
            if (decisions.mistral === 'SELL') modelDecisions.push('Mistral');
            return modelDecisions;
        }

        function calculateAccuracy(model) {
            const trades = tradeHistory[model];
            if (trades.length === 0) return 0;

            const correctTrades = trades.filter(trade => trade.profitable).length;
            return ((correctTrades / trades.length) * 100).toFixed(1);
        }

        function updateAccuracy(currentPrice) {
            if (lastDecisions.price !== null) {
                const priceChange = currentPrice - lastDecisions.price;
                const priceChangePercent = (priceChange / lastDecisions.price) * 100;

                // Update market volatility
                calculateVolatility(currentPrice);

                // Get dynamic threshold based on market conditions
                const threshold = calculateDynamicThreshold();

                // Update accuracy for each model
                ['gemini', 'groq', 'mistral'].forEach(model => {
                    if (lastDecisions[model]) {
                        const decision = lastDecisions[model];
                        const score = calculateTradeScore(decision, priceChangePercent, threshold);

                        // Record trade with enhanced metrics
                        tradeHistory[model].push({
                            timestamp: new Date(),
                            decision: decision,
                            priceChange: priceChangePercent,
                            score: score,
                            threshold: threshold,
                            volatility: marketVolatility.current,
                            price: currentPrice
                        });

                        // Keep only last 100 trades for more recent performance focus
                        if (tradeHistory[model].length > 100) {
                            tradeHistory[model].shift();
                        }
                    }
                });
            }

            // Update accuracy display with weighted metrics
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                if (accuracyElement) {
                    const trades = tradeHistory[model];
                    if (trades.length > 0) {
                        // Calculate weighted average score
                        const recentTrades = trades.slice(-20); // Last 20 trades
                        const weights = recentTrades.map((_, i) => 1 + (i / recentTrades.length));
                        const totalWeight = weights.reduce((sum, w) => sum + w, 0);

                        const weightedScore = recentTrades.reduce((sum, trade, i) => 
                            sum + (trade.score * weights[i]), 0) / totalWeight;

                        const accuracy = (weightedScore * 100).toFixed(1);
                        accuracyElement.textContent = `${accuracy}%`;
                        accuracyElement.className = `font-bold ${
                            parseFloat(accuracy) >= 65 ? 'text-green-400' :
                            parseFloat(accuracy) >= 45 ? 'text-yellow-400' :
                            'text-red-400'
                        }`;
                    } else {
                        // No trades yet, show 0%
                        accuracyElement.textContent = '0.0%';
                        accuracyElement.className = 'font-bold text-gray-400';
                    }
                }
            });
        }

        function initCharts() {
            Chart.defaults.color = '#e2e8f0';
            Chart.defaults.borderColor = 'rgba(0, 243, 255, 0.1)';

            // Price Chart
            const priceCtx = document.getElementById('price-chart').getContext('2d');
            priceChart = new Chart(priceCtx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'ETH Price (USD)',
                            data: priceHistory,
                            borderColor: '#00f3ff',
                            borderWidth: 2,
                            tension: 0.1,
                            yAxisID: 'y',
                            order: 1
                        },
                        {
                            label: 'Volume',
                            data: volumeHistory,
                            backgroundColor: 'rgba(157, 0, 255, 0.2)',
                            borderColor: 'rgba(157, 0, 255, 0.2)',
                            type: 'bar',
                            yAxisID: 'volume',
                            order: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e2e8f0'
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'x',
                            },
                            pan: {
                                enabled: true,
                                mode: 'x',
                            }
                        },
                        annotation: {
                            annotations: {}
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: {
                                color: 'rgba(0, 243, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e2e8f0'
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: '#e2e8f0'
                            }
                        },
                        volume: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false,
                                color: 'rgba(157, 0, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e2e8f0'
                            },
                            title: {
                                display: true,
                                text: 'Volume',
                                color: '#e2e8f0'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updateCharts(price, sentiment, geminiAction, groqAction, mistralAction, volume) {
            const now = new Date().toLocaleTimeString();

            // Update accuracy
            updateAccuracy(price);

            // Store current decisions for next accuracy calculation
            lastDecisions = {
                gemini: geminiAction,
                groq: groqAction,
                mistral: mistralAction,
                price: price
            };

            // Keep last 100 data points
            if (timeLabels.length > 100) {
                timeLabels.shift();
                priceHistory.shift();
                volumeHistory.shift();
            }

            timeLabels.push(now);
            priceHistory.push(price);
            volumeHistory.push(volume);

            // Update price chart without model annotations
            priceChart.update();

            // Persist chart data
            try {
                localStorage.setItem(STORAGE_KEYS.PRICE_DATA, JSON.stringify(priceHistory));
                localStorage.setItem(STORAGE_KEYS.VOLUME_DATA, JSON.stringify(volumeHistory));
                localStorage.setItem(STORAGE_KEYS.TIME_LABELS, JSON.stringify(timeLabels));
            } catch (error) {
                console.error('Error persisting chart data:', error);
            }
        }

        function updateModelStats(stats) {
            // If no wallet is connected, don't update model stats
            if (!userAccount) {
                displayEmptyStats();
                return;
            }
            
            // Update detailed stats for each model
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const trades = tradeHistory[model];
                const statsContainer = document.getElementById(`${model}-stats`);
                if (statsContainer) {
                    const totalTrades = trades.length;
                    const correctTrades = trades.filter(t => t.profitable).length;
                    const incorrectTrades = totalTrades - correctTrades;

                    // Calculate decision distribution
                    const decisions = {
                        buy: trades.filter(t => t.decision === 'BUY').length,
                        sell: trades.filter(t => t.decision === 'SELL').length,
                        hold: trades.filter(t => t.decision === 'HOLD').length
                    };

                    // Calculate average price change for correct trades
                    const correctTradesAvgChange = correctTrades > 0 
                        ? (trades.filter(t => t.profitable)
                            .reduce((sum, t) => sum + t.priceChange, 0) / correctTrades).toFixed(2)
                        : 0;

                    statsContainer.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>
                                <div class="text-gray-400">Total Trades:</div>
                                <div class="font-bold text-cyber-text">${totalTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Correct Trades:</div>
                                <div class="font-bold text-green-400">${correctTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Incorrect Trades:</div>
                                <div class="font-bold text-red-400">${incorrectTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Avg Profit Trades:</div>
                                <div class="font-bold ${parseFloat(correctTradesAvgChange) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                    ${correctTradesAvgChange}%
                                </div>
                            </div>
                            <div class="col-span-2">
                                <div class="text-gray-400">Decision Distribution:</div>
                                <div class="flex justify-between mt-1">
                                    <span class="text-green-400">Buy: ${decisions.buy}</span>
                                    <span class="text-red-400">Sell: ${decisions.sell}</span>
                                    <span class="text-blue-400">Hold: ${decisions.hold}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
        }

        // Update model stats display
        function updateModelStatsDisplay() {
            // Check if we need to reset daily stats
            checkDailyReset();

            // If wallet is connected, fetch wallet-specific stats
            if (userAccount) {
                fetchWalletStats();
                return;
            }

            // If no wallet connected, display default state with connect wallet message
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                const accuracyElement = document.getElementById(`${model}-accuracy`);

                if (statsContainer) {
                    statsContainer.innerHTML = `
                        <div class="text-center py-2">
                            <p class="text-gray-400 mb-2">Connect your wallet to see model performance.</p>
                            <button onclick="connectWallet()" class="cyber-btn text-xs px-3 py-1">Connect Wallet</button>
                        </div>
                    `;
                }

                if (accuracyElement) {
                    accuracyElement.textContent = '0.0%';
                    accuracyElement.className = 'font-bold text-gray-400';
                }
            });
        }

        // Fetch wallet-specific stats from API
        function fetchWalletStats() {
            if (!userAccount) return;
            
            fetch(`/api/wallet-stats?wallet_address=${userAccount}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to fetch wallet stats');
                    }
                    return response.json();
                })
                .then(data => {
                    updateWalletModelStats(data);
                })
                .catch(error => {
                    console.error('Error fetching wallet stats:', error);
                    // Show error in stats containers
                    ['gemini', 'groq', 'mistral'].forEach(model => {
                        const statsContainer = document.getElementById(`${model}-stats`);
                        if (statsContainer) {
                            statsContainer.innerHTML = `
                                <div class="text-center py-2">
                                    <p class="text-red-400">Error loading stats: ${error.message}</p>
                                </div>
                            `;
                        }
                    });
                });
        }

        // Update model stats with wallet-specific data
        function updateWalletModelStats(walletData) {
            // Extract action distribution and statistics
            const actionDistribution = walletData.statistics?.action_distribution || { BUY: 0, SELL: 0, HOLD: 0 };
            const totalActions = walletData.statistics?.total_actions || 0;
            const profitableActions = walletData.statistics?.profitable_actions || 0;
            const accuracy = walletData.statistics?.accuracy || 0;
            const valueChange = walletData.statistics?.total_value_change || 0;
            
            // Get model-specific stats
            const modelStats = walletData.model_stats || {};
            
            // Update each model's stats container
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                
                const modelStat = modelStats[model] || {
                    total_decisions: 0,
                    correct_decisions: 0,
                    accuracy: 0,
                    decision_counts: { BUY: 0, SELL: 0, HOLD: 0 }
                };
                
                if (statsContainer) {
                    if (modelStat.total_decisions > 0) {
                        statsContainer.innerHTML = `
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div class="col-span-2 mb-1">
                                    <div class="text-xs font-bold text-neon-blue">Your Wallet Activity</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Total Decisions:</div>
                                    <div class="font-bold text-cyber-text">${modelStat.total_decisions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Correct Decisions:</div>
                                    <div class="font-bold text-green-400">${modelStat.correct_decisions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Incorrect Decisions:</div>
                                    <div class="font-bold text-red-400">${modelStat.total_decisions - modelStat.correct_decisions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Accuracy:</div>
                                    <div class="font-bold ${modelStat.accuracy >= 65 ? 'text-green-400' : modelStat.accuracy >= 45 ? 'text-yellow-400' : 'text-red-400'}">
                                        ${modelStat.accuracy.toFixed(1)}%
                                    </div>
                                </div>
                                <div class="col-span-2">
                                    <div class="text-gray-400">Decision Distribution:</div>
                                    <div class="flex justify-between mt-1">
                                        <span class="text-green-400">Buy: ${modelStat.decision_counts.BUY}</span>
                                        <span class="text-red-400">Sell: ${modelStat.decision_counts.SELL}</span>
                                        <span class="text-blue-400">Hold: ${modelStat.decision_counts.HOLD}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        statsContainer.innerHTML = `
                            <div class="text-center py-2">
                                <p class="text-gray-400 mb-2">No trading activity yet for this wallet.</p>
                            </div>
                        `;
                    }
                }
                
                if (accuracyElement) {
                    accuracyElement.textContent = `${modelStat.accuracy.toFixed(1)}%`;
                    accuracyElement.className = `font-bold ${
                        modelStat.accuracy >= 65 ? 'text-green-400' :
                        modelStat.accuracy >= 45 ? 'text-yellow-400' :
                        'text-red-400'
                    }`;
                }
            });
        }

        // Modified updateData function to send wallet notifications
        function updateData() {
            console.log('Fetching new data...');
            fetch('/api/trading-data')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Received data:', data);

                    // Update metrics
                    document.getElementById('eth-price').textContent = `$${data.eth_price.toFixed(2)}`;
                    document.getElementById('eth-volume').textContent = `$${(data.eth_volume_24h/1e6).toFixed(2)}M`;
                    document.getElementById('eth-high').textContent = `$${data.eth_high_24h.toFixed(2)}`;
                    document.getElementById('eth-low').textContent = `$${data.eth_low_24h.toFixed(2)}`;

                    // Update model decisions
                    updateModelDecisions(data, userAccount);

                    // Update gas price information
                    if (data.gas_prices) {
                        document.getElementById('gas-low').textContent = `${data.gas_prices.low} Gwei`;
                        document.getElementById('gas-standard').textContent = `${data.gas_prices.standard} Gwei`;
                        document.getElementById('gas-fast').textContent = `${data.gas_prices.fast} Gwei`;
                    }
                    
                    // Update market sentiment
                    const sentimentText = document.getElementById('sentiment');
                    if (sentimentText && data.market_sentiment) {
                        sentimentText.textContent = `${data.market_sentiment.fear_greed_value} (${data.market_sentiment.fear_greed_sentiment})`;
                        const sentimentClass = data.market_sentiment.fear_greed_sentiment === 'bullish'
                            ? 'bg-green-100 text-green-800'
                            : 'bg-red-100 text-red-800';

                        sentimentText.className = `px-2 py-1 rounded-full text-sm font-semibold ${sentimentClass}`;
                    }

                    // Update charts
                    updateCharts(
                        data.eth_price,
                        data.market_sentiment?.fear_greed_value,
                        data.gemini_action,
                        data.groq_action,
                        data.mistral_action,
                        data.eth_volume_24h
                    );

                    // Only update model stats if wallet is connected
                    if (userAccount && data.model_stats?.comparison) {
                        // Get wallet-specific stats instead of general stats
                        fetchWalletStats();
                    } else {
                        // Make sure model cards show connect wallet message
                        displayEmptyStats();
                    }

                    // Only persist trading history if wallet is connected
                    if (userAccount) {
                        persistTradingHistory();
                    }
                })
                .catch(error => {
                    console.error('Failed to fetch market data:', error);
                    document.querySelectorAll('.cyber-value').forEach(el => {
                        el.textContent = 'Error';
                        el.classList.add('text-red-500');
                    });
                });
        }

        // Update model decisions based on wallet connection status
        function updateModelDecisions(data, walletAddress) {
            const models = ['gemini', 'groq', 'mistral'];
            const modelActions = {
                gemini: data.gemini_action,
                groq: data.groq_action,
                mistral: data.mistral_action
            };

            // For each model decision card
            models.forEach(model => {
                const decisionElement = document.getElementById(`${model}-decision`);
                if (!decisionElement) return;

                // First remove all classes to start fresh
                decisionElement.classList.remove('text-green-400', 'text-red-400', 'text-blue-400', 'text-gray-400', 'text-yellow-400');
                
                if (!walletAddress) {
                    // No wallet connected - show connect wallet message
                    decisionElement.innerHTML = `<span class="text-sm">Connect wallet first</span>`;
                    decisionElement.classList.add('text-gray-400');
                    return;
                }

                // Wallet connected - show action and appropriate color
                const action = modelActions[model];
                
                // If no action yet (null, undefined, empty string), show "Decision in progress"
                if (!action || action === '') {
                    decisionElement.innerHTML = `<span>Decision in progress</span>`;
                    decisionElement.classList.add('text-yellow-400');
                    return;
                }
                
                // Valid action received, show the action with appropriate styling
                let actionClass = '';
                
                switch (action) {
                    case 'BUY':
                        actionClass = 'text-green-400';
                        break;
                    case 'SELL':
                        actionClass = 'text-red-400';
                        break;
                    case 'HOLD':
                        actionClass = 'text-blue-400';
                        break;
                    default:
                        actionClass = 'text-gray-400';
                }
                
                decisionElement.textContent = action;
                decisionElement.classList.add(actionClass);
                
                // Store this decision linked to the current wallet
                storeAIDecisionForWallet(model, action, data.eth_price, walletAddress);
            });

            // Check for consensus and notify if wallet is connected
            if (walletAddress) {
                const decisions = {
                    gemini: data.gemini_action,
                    groq: data.groq_action,
                    mistral: data.mistral_action
                };

                // Filter out undefined or empty decisions
                const validDecisions = {};
                for (const [model, decision] of Object.entries(decisions)) {
                    if (decision && decision !== '') {
                        validDecisions[model] = decision;
                    }
                }

                // Only check consensus if we have at least 2 valid decisions
                if (Object.keys(validDecisions).length >= 2) {
                    const consensus = checkLLMConsensus(validDecisions);
                    if (consensus && (consensus === 'BUY' || consensus === 'SELL')) {
                        const buyModels = getModelDecisions(decisions);
                        const sellModels = getModelSellDecisions(decisions);
                        const currentPrice = data.eth_price.toFixed(2);

                        let message = '';
                        if (consensus === 'BUY') {
                            message = `🟢 BUY Signal at $${currentPrice}\n`;
                            message += `Recommended by: ${buyModels.join(', ')}`;
                        } else if (consensus === 'SELL') {
                            message = `🔴 SELL Signal at $${currentPrice}\n`;
                            message += `Recommended by: ${sellModels.join(', ')}`;
                        }

                        // Show browser notification for all signals (BUY, SELL)
                        showNotification(message, 'info');

                        // Force wallet balance refresh with a slight delay
                        // This ensures the wallet card recommendation is updated first
                        setTimeout(() => {
                            getWalletBalances().then(() => {
                                // Send wallet notification after balances are refreshed - only for BUY and SELL
                                sendWalletNotification(message, consensus);
                            });
                        }, 500);
                    } else if (consensus === 'HOLD') {
                        // For HOLD signals, don't show any notification, just refresh wallet balances
                        console.log('HOLD signal - No notification needed');
                        
                        // Still refresh wallet balances to keep things in sync
                        getWalletBalances();
                    } else {
                        // No consensus, but still refresh wallet balances
                        getWalletBalances();
                    }
                } else {
                    console.log("Not enough valid decisions to determine consensus");
                }
            }
        }
        
        // Store AI decision for specific wallet
        async function storeAIDecisionForWallet(model, decision, price, walletAddress) {
            try {
                await fetch('/api/store-ai-decision', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        decision: decision,
                        eth_price: price,
                        wallet_address: walletAddress
                    })
                });
                console.log(`Stored ${decision} decision for ${model} model linked to wallet ${walletAddress}`);
            } catch (error) {
                console.error('Error storing AI decision for wallet:', error);
            }
        }

        // Add function to fetch daily stats
        function fetchDailyStats() {
            // If wallet is connected, only fetch wallet-specific stats
            if (userAccount) {
                fetch(`/api/wallet-stats?wallet_address=${userAccount}`)
                    .then(response => response.json())
                    .then(walletData => {
                        if (walletData && walletData.statistics) {
                            displayWalletStats(walletData);
                        } else {
                            displayEmptyStats();
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching wallet stats:', error);
                        displayEmptyStats();
                    });
                return; // Skip fetching global stats
            }
            
            // No wallet connected - display empty stats with connect wallet message
            displayEmptyStats();
        }
        
        // Display empty stats for all models
        function displayEmptyStats() {
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                
                if (statsContainer) {
                    statsContainer.innerHTML = `
                        <div class="text-center py-2">
                            <p class="text-gray-400 mb-2">Connect your wallet to see model performance.</p>
                        </div>
                    `;
                }
                
                if (accuracyElement) {
                    accuracyElement.textContent = '0.0%';
                    accuracyElement.className = 'font-bold text-gray-400';
                }
            });
        }
        
        // Display wallet-specific stats
        function displayWalletStats(walletData) {
            const stats = walletData.statistics;
            const actionDistribution = stats.action_distribution || { BUY: 0, SELL: 0, HOLD: 0 };
            
            // Display the same stats for all models since we have one wallet action that applies to all
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                if (statsContainer) {
                    if (stats.total_actions > 0) {
                        statsContainer.innerHTML = `
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div class="col-span-2 mb-1">
                                    <div class="text-xs font-bold text-neon-blue">Wallet Performance</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Total Actions:</div>
                                    <div class="font-bold text-cyber-text">${stats.total_actions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Profitable:</div>
                                    <div class="font-bold text-green-400">${stats.profitable_actions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Unprofitable:</div>
                                    <div class="font-bold text-red-400">${stats.total_actions - stats.profitable_actions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Value Change:</div>
                                    <div class="font-bold ${parseFloat(stats.total_value_change) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                        ${stats.total_value_change.toFixed(2)}%
                                    </div>
                                </div>
                                <div class="col-span-2">
                                    <div class="text-gray-400">Action Distribution:</div>
                                    <div class="flex justify-between mt-1">
                                        <span class="text-green-400">Buy: ${actionDistribution.BUY || 0}</span>
                                        <span class="text-red-400">Sell: ${actionDistribution.SELL || 0}</span>
                                        <span class="text-blue-400">Hold: ${actionDistribution.HOLD || 0}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        statsContainer.innerHTML = `
                            <div class="text-center py-2">
                                <p class="text-gray-400 mb-2">No trading activity yet for this wallet.</p>
                            </div>
                        `;
                    }
                }
                
                // Update accuracy based on wallet performance
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                if (accuracyElement) {
                    accuracyElement.textContent = `${stats.accuracy.toFixed(1)}%`;
                    accuracyElement.className = `font-bold ${
                        stats.accuracy >= 65 ? 'text-green-400' :
                        stats.accuracy >= 45 ? 'text-yellow-400' :
                        'text-red-400'
                    }`;
                }
            });
        }

        // Function to check if this is a fresh session and clear storage if needed
        function checkFreshSession() {
            const lastVisit = localStorage.getItem('stbchef_last_visit');
            const now = Date.now();
            const oneDayInMs = 24 * 60 * 60 * 1000;
            
            // If this is first visit or last visit was more than a day ago
            if (!lastVisit || (now - parseInt(lastVisit)) > oneDayInMs) {
                console.log("Fresh session detected, clearing storage");
                
                // Call backend clear-storage endpoint
                fetch('/clear-storage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Storage cleared response:", data);
                    
                    // Clear all local storage items related to the app
                    Object.values(STORAGE_KEYS).forEach(key => {
                        localStorage.removeItem(key);
                    });
                    
                    // Reset trade history variables
                    tradeHistory = {
                        gemini: [],
                        groq: [],
                        mistral: []
                    };
                    
                    // Set all accuracy elements to 0
                    ['gemini', 'groq', 'mistral'].forEach(model => {
                        const accuracyElement = document.getElementById(`${model}-accuracy`);
                        if (accuracyElement) {
                            accuracyElement.textContent = '0.0%';
                            accuracyElement.className = 'font-bold text-gray-400';
                        }
                    });
                })
                .catch(error => console.error("Error clearing storage:", error));
            }
            
            // Update last visit timestamp
            localStorage.setItem('stbchef_last_visit', now.toString());
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing dashboard...');
            checkFreshSession(); // Check if storage needs clearing
            
            // Initialize UI with empty state first
            displayEmptyStats();
            
            // Initialize charts before any data loading
            initCharts();
            
            // Check for daily reset
            checkDailyReset(); 
            
            // Fetch data after initialization
            updateData();  // Initial data fetch
            
            // Set up auto-refresh every 10 minutes
            const refreshInterval = setInterval(() => {
                console.log('Auto-refresh triggered');
                updateData();
            }, 600000);  // 10 minutes

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                clearInterval(refreshInterval);
                // Only persist if wallet is connected
                if (userAccount) {
                    persistTradingHistory();
                }
            });
        });

        // Add timeframe update function
        function updateTimeframe(timeframe) {
            // Update button styles
            document.querySelectorAll('.cyber-btn').forEach(btn => {
                btn.classList.remove('cyber-btn-active');
            });
            event.target.classList.add('cyber-btn-active');

            // Fetch new data with selected timeframe
            fetch(`/api/model-stats?timeframe=${timeframe}`)
                .then(response => response.json())
                .then(data => {
                    if (data.performance) {
                        updateModelStats(data.performance);
                    }
                    if (data.comparison) {
                        updateModelStats(data.comparison);
                    }
                })
                .catch(error => console.error('Error updating timeframe:', error));
        }

        // Filter trades from the last 24 hours
        function getRecentTrades(trades) {
            const oneDayAgo = new Date();
            oneDayAgo.setHours(oneDayAgo.getHours() - 24);
            return trades.filter(trade => new Date(trade.timestamp) > oneDayAgo);
        }

        // Check if we need to reset daily stats
        function checkDailyReset() {
            const lastReset = localStorage.getItem('last_daily_reset');
            const now = new Date();
            const today = now.toDateString();

            if (lastReset !== today) {
                // Reset daily stats for each model
                ['gemini', 'groq', 'mistral'].forEach(model => {
                    // We don't actually delete trades, just mark when we last reset
                    console.log(`Resetting daily stats for ${model}`);
                });

                // Store today's date as the last reset day
                localStorage.setItem('last_daily_reset', today);
                return true;
            }
            return false;
        }

        // Add wallet notification function
        async function sendWalletNotification(message, signalType) {
            if (!userAccount || !web3) {
                console.log("No wallet connection available - cannot send notification");
                return;
            }
            
            try {
                // Only process BUY or SELL signals (skip HOLD)
                if (signalType !== 'BUY' && signalType !== 'SELL') {
                    console.log(`Skipping wallet notification for ${signalType} signal - only BUY and SELL signals get wallet notifications`);
                    return;
                }
                
                // Log that we're sending a wallet notification
                console.log(`Sending wallet notification for ${signalType} signal to ${userAccount}`);
                
                // Get current wallet balances and validate
                const ethBalance = walletBalances.eth || 0;
                const usdcBalance = walletBalances.usdc || 0;
                const currentPrice = walletBalances.ethusd || 0;
                
                // Skip transaction suggestions if price is invalid
                if (currentPrice <= 0 || isNaN(currentPrice)) {
                    console.log("Invalid ETH price, skipping transaction suggestions");
                    showNotification(`${signalType} signal received - Unable to calculate swap amounts with current price data`, 'warning');
                    return;
                }
                
                // Lower minimum transaction amount for micro-balances
                // Set minimum to the lower of 0.001 ETH or 25% of available balance (with safety check)
                const MIN_ETH_TRANSACTION = ethBalance > 0 ? Math.min(0.001, ethBalance * 0.25) : 0;
                const MIN_USDC_TRANSACTION = usdcBalance > 0 ? Math.min(0.5, usdcBalance * 0.25) : 0;
                
                console.log(`Processing ${signalType} signal with balances: ${ethBalance} ETH, ${usdcBalance} USDC`);
                console.log(`Minimum transactions: ${MIN_ETH_TRANSACTION} ETH, ${MIN_USDC_TRANSACTION} USDC`);
                
                // Record this wallet action in the database
                await recordWalletAction(signalType);
                
                // Get the current chain ID
                const chainId = await web3.eth.getChainId();
                
                // Create a notification message to send to the wallet
                // This will trigger a MetaMask notification rather than just a browser notification
                if (signalType === 'BUY' && usdcBalance > 0) {
                    // For BUY signal, suggest using USDC to buy ETH
                    const usdcToUse = usdcBalance > 0.5 ? Math.max(usdcBalance * 0.05, MIN_USDC_TRANSACTION) : usdcBalance * 0.9;
                    
                    // Safety check: ensure values are valid
                    if (usdcToUse <= 0 || currentPrice <= 0) {
                        console.log("Invalid USDC or price values for BUY calculation");
                        showNotification(`BUY signal received - Unable to calculate conversion amounts`, 'warning');
                        return;
                    }
                    
                    const ethEquivalent = usdcToUse / currentPrice;
                    
                    // Show a notification about the suggested swap
                    showNotification(`Suggested action: Convert ${usdcToUse.toFixed(2)} USDC to approximately ${ethEquivalent.toFixed(4)} ETH`, 'info');
                    
                    // Create and send a transaction to the wallet (this will just prompt the user, not execute automatically)
                    try {
                        // This sends a 0 ETH transaction with the message in the data field, which will trigger a notification
                        await window.ethereum.request({
                            method: 'eth_sendTransaction',
                            params: [{
                                from: userAccount,
                                to: userAccount,
                                value: '0x0', // 0 ETH
                                data: web3.utils.toHex(message), // Put our message in the data field
                                gas: '0x5208', // 21000 gas
                            }],
                        });
                        console.log("Wallet notification sent successfully");
                        
                        // Update model stats after notification
                        updateModelStatsForWallet();
                        // Fetch updated wallet stats
                        fetchWalletStats();
                    } catch (txError) {
                        // User may have rejected the transaction, which is fine
                        console.log("User declined the wallet notification transaction", txError);
                    }
                    
                    return;
                } else if (signalType === 'SELL' && ethBalance > 0) {
                    // For SELL signal, suggest selling ETH for USDC
                    const ethToSell = ethBalance > 0.01 ? Math.max(ethBalance * 0.05, MIN_ETH_TRANSACTION) : ethBalance * 0.9;
                    
                    // Safety check: ensure values are valid
                    if (ethToSell <= 0 || currentPrice <= 0) {
                        console.log("Invalid ETH or price values for SELL calculation");
                        showNotification(`SELL signal received - Unable to calculate conversion amounts`, 'warning');
                        return;
                    }
                    
                    const usdcEquivalent = ethToSell * currentPrice;
                    
                    // Show a notification about the suggested swap
                    showNotification(`Suggested action: Convert ${ethToSell.toFixed(4)} ETH to approximately ${usdcEquivalent.toFixed(2)} USDC`, 'info');
                    
                    // Create and send a transaction to the wallet
                    try {
                        await window.ethereum.request({
                            method: 'eth_sendTransaction',
                            params: [{
                                from: userAccount,
                                to: userAccount,
                                value: '0x0', // 0 ETH
                                data: web3.utils.toHex(message), // Put our message in the data field
                                gas: '0x5208', // 21000 gas
                            }],
                        });
                        console.log("Wallet notification sent successfully");
                        
                        // Update model stats after notification
                        updateModelStatsForWallet();
                        // Fetch updated wallet stats
                        fetchWalletStats();
                    } catch (txError) {
                        console.log("User declined the wallet notification transaction", txError);
                    }
                    
                    return;
                }
                
                // If we reached here, either not enough balance or just notification
                console.log(`Signal received (${signalType}), but no transaction suggestion created`);
                
                // Still try to send a simple notification transaction
                try {
                    await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: userAccount,
                            to: userAccount,
                            value: '0x0', // 0 ETH
                            data: web3.utils.toHex(`${signalType} signal received - Check your portfolio allocation`),
                            gas: '0x5208', // 21000 gas
                        }],
                    });
                    console.log("General wallet notification sent successfully");
                    
                    // Update model stats after notification
                    updateModelStatsForWallet();
                    // Fetch updated wallet stats
                    fetchWalletStats();
                } catch (txError) {
                    console.log("User declined the wallet notification transaction", txError);
                }
                
                // Just show a generic notification
                showNotification(`${signalType} signal received - Check your portfolio allocation`, 'info');
            } catch (error) {
                logToServer('error', 'Error processing wallet notification', error);
                showNotification(`Error processing ${signalType} signal: ${error.message}`, 'error');
            }
        }
        
        // Record wallet action to the database
        async function recordWalletAction(action) {
            if (!userAccount) return;
            
            try {
                // Calculate ETH allocation
                const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                const totalValue = walletBalances.totalValueUSD || ethValueUSD;
                const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                
                // Get current chain ID
                const chainId = await web3.eth.getChainId();
                
                // Send action to server to be recorded
                const response = await fetch('/api/set-wallet-action', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        wallet_address: userAccount,
                        wallet_action: action,
                        eth_balance: walletBalances.eth,
                        usdc_balance: walletBalances.usdc,
                        eth_allocation: currentEthAllocation,
                        network: chainId === 59144 ? 'linea' : 'ethereum'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log("Wallet action recorded successfully:", data);
                    return data;
                } else {
                    console.warn("Failed to record wallet action:", response.status);
                    return null;
                }
            } catch (error) {
                console.error("Error recording wallet action:", error);
                return null;
            }
        }

        // Add notification permission request
        async function requestNotificationPermission() {
            if (!userAccount) return;

            try {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    console.log('Notification permission granted');
                }
            } catch (error) {
                console.error('Error requesting notification permission:', error);
            }
        }

        // Function to check API status
        function checkAPIs() {
            // Change button text to show loading
            const checkBtn = document.getElementById('check-api-btn');
            const originalText = checkBtn.innerHTML;
            checkBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Checking...';
            checkBtn.disabled = true;
            
            // Call the API check endpoint
            fetch('/api/check-apis')
                .then(response => response.json())
                .then(data => {
                    console.log('API check results:', data);
                    
                    // Build notification message
                    let message = '<strong>API Status Check Results:</strong><br>';
                    for (const [api, status] of Object.entries(data)) {
                        const icon = status.status === 'ok' ? '✅' : '❌';
                        message += `${icon} ${api}: ${status.message}<br>`;
                    }
                    
                    // Show notification
                    showNotification(message, 'info');
                    
                    // Restore button
                    checkBtn.innerHTML = originalText;
                    checkBtn.disabled = false;
                    
                    // If Etherscan is working, try to update data
                    if (data.etherscan && data.etherscan.status === 'ok') {
                        // Instead of calling updateData directly which might trigger wallet transactions,
                        // just update the UI elements without triggering consensus checks
                        updateUIWithoutWalletTransactions();
                    }
                })
                .catch(error => {
                    console.error('Error checking APIs:', error);
                    showNotification('Error checking API status: ' + error, 'error');
                    checkBtn.innerHTML = originalText;
                    checkBtn.disabled = false;
                });
        }

        // Function to update UI without triggering wallet transactions
        function updateUIWithoutWalletTransactions() {
            console.log('Updating UI data (without wallet transactions)...');
            fetch('/api/trading-data')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Received data - UI update only');

                    // Update metrics (without wallet transactions)
                    document.getElementById('eth-price').textContent = `$${data.eth_price.toFixed(2)}`;
                    document.getElementById('eth-volume').textContent = `$${(data.eth_volume_24h/1e6).toFixed(2)}M`;
                    document.getElementById('eth-high').textContent = `$${data.eth_high_24h.toFixed(2)}`;
                    document.getElementById('eth-low').textContent = `$${data.eth_low_24h.toFixed(2)}`;

                    // Update gas price information
                    if (data.gas_prices) {
                        document.getElementById('gas-low').textContent = `${data.gas_prices.low} Gwei`;
                        document.getElementById('gas-standard').textContent = `${data.gas_prices.standard} Gwei`;
                        document.getElementById('gas-fast').textContent = `${data.gas_prices.fast} Gwei`;
                    }

                    // Update model decisions and stats
                    ['gemini', 'groq', 'mistral'].forEach(model => {
                        const action = data[`${model}_action`];
                        const decisionElement = document.getElementById(`${model}-decision`);
                        if (decisionElement) {
                            decisionElement.textContent = action || 'N/A';
                            decisionElement.className = `font-bold text-xl cyber-value ${
                                action === 'BUY' ? 'text-green-400' :
                                action === 'SELL' ? 'text-red-400' :
                                'text-blue-400'
                            } animate-pulse`;
                        }
                    });

                    // Update market sentiment
                    const sentimentText = document.getElementById('sentiment');
                    if (sentimentText && data.market_sentiment) {
                        sentimentText.textContent = `${data.market_sentiment.fear_greed_value} (${data.market_sentiment.fear_greed_sentiment})`;
                        const sentimentClass = data.market_sentiment.fear_greed_sentiment === 'bullish'
                            ? 'bg-green-100 text-green-800'
                            : 'bg-red-100 text-red-800';

                        sentimentText.className = `px-2 py-1 rounded-full text-sm font-semibold ${sentimentClass}`;
                    }

                    // Update charts
                    updateCharts(
                        data.eth_price,
                        data.market_sentiment?.fear_greed_value,
                        data.gemini_action,
                        data.groq_action,
                        data.mistral_action,
                        data.eth_volume_24h
                    );

                    // Fetch daily stats (without wallet notifications)
                    fetchDailyStats();
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                });
        }

        // Function to determine portfolio bar color based on target allocation
        function getPortfolioBarColor(allocation, minTarget, maxTarget) {
            // Below minimum target - needs more ETH
            if (allocation < minTarget) {
                return 'bg-gradient-to-r from-yellow-500 to-blue-500';
            } 
            // Above maximum target - too much ETH
            else if (allocation > maxTarget) {
                return 'bg-gradient-to-r from-red-500 to-orange-500';
            } 
            // Within target range - optimal
            else {
                return 'bg-gradient-to-r from-green-500 to-blue-400';
            }
        }
    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <!-- Header -->
    <header class="cyber-header p-4">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center">
                <img src="static/robot.webp" alt="Trading Bot Chef Logo" class="header-logo">
                <h1 class="cyber-title text-2xl">Simple Crypto Trading Bot Chef</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="wallet-btn" onclick="connectWallet()" class="wallet-btn px-4 py-2 rounded">
                    Connect Wallet
                </button>
                <button id="check-api-btn" onclick="checkAPIs()" class="cyber-btn px-4 py-2 rounded flex items-center">
                    <i class="fas fa-sync-alt mr-2"></i>
                    Check APIs
                </button>
                <a href="https://github.com/Qbandev/stbchef" target="_blank" class="cyber-btn px-4 py-2 rounded flex items-center">
                    <i class="fab fa-github mr-2"></i>
                    GitHub
                </a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4 mt-4">
        <div class="grid grid-cols-1 gap-6">
            <!-- ETH/USDC Live Price Card (Full Width) -->
            <div class="cyber-card p-6 rounded-lg shadow mb-6">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
                    <h2 class="text-xl font-semibold cyber-title">ETH/USDC <span class="text-sm text-gray-400">Live Price</span></h2>
                    <div class="flex items-center space-x-4 mt-2 md:mt-0">
                        <div>
                            <span class="text-gray-400 text-sm">Current Price:</span>
                            <span id="eth-price" class="text-2xl font-bold ml-2 cyber-value animate-pulse">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400 text-sm">24h Vol:</span>
                            <span id="eth-volume" class="text-sm font-bold ml-2 cyber-value">-</span>
                        </div>
                    </div>
                </div>
                <!-- ETH Price Chart (Integrated) -->
                <div class="h-64 relative" id="price-chart-container">
                    <canvas id="price-chart"></canvas>
                </div>
                <!-- Price & Gas Info -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                    <!-- Price Data -->
                    <div class="flex justify-between items-center">
                        <div>
                            <span class="text-gray-400">24h High:</span>
                            <span id="eth-high" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">24h Low:</span>
                            <span id="eth-low" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">Sentiment:</span>
                            <span id="sentiment" class="ml-1 px-2 py-0.5 rounded-full text-xs font-semibold bg-gray-700 text-gray-300">-</span>
                        </div>
                    </div>
                    <!-- Gas Prices (Linea) -->
                    <div class="flex justify-between items-center">
                        <div></div> <!-- Empty div to push content to right -->
                        <div class="flex items-center space-x-4">
                            <span class="text-gray-400">Gas Prices:</span>
                            <div class="flex space-x-4">
                                <div class="text-center">
                                    <span class="text-green-400 text-sm mr-1">Low:</span>
                                    <span id="gas-low" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-yellow-400 text-sm mr-1">Medium:</span>
                                    <span id="gas-standard" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-red-400 text-sm mr-1">High:</span>
                                    <span id="gas-fast" class="text-sm font-bold cyber-value">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Wallet Status Card (Full Width) -->
            <div id="wallet-card" class="cyber-card rounded-lg shadow p-6 mb-6">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                </div>
                <div class="flex items-center justify-center h-24">
                    <div class="text-center">
                        <p class="text-gray-400 mb-2">Connect your wallet to see balances</p>
                    </div>
                </div>
            </div>
            
            <!-- AI Model Recommendations -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Gemini AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Gemini AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="gemini-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Gemini 1.5 Flash</div>
                    </div>
                </div>

                <!-- Groq AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Groq AI</h2>
                        <svg class="w-6 h-6 text-neon-purple" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="groq-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by DeepSeek-R1-Distill-Llama-70B</div>
                    </div>
                </div>

                <!-- Mistral AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Mistral AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10l3.5 3.5m0-6.5L13 10m6 0l-3.5 3.5M7 10l-3.5 3.5m0-6.5L7 10m-6 0l3.5 3.5" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="mistral-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Mistral Large</div>
                    </div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">Model Performance</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Gemini Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-blue">Gemini AI</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-gray-400">Performance Score:</span>
                                <div class="tooltip-container">
                                    <span id="gemini-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                    <div class="tooltip">
                                        Weighted average of recent trade scores (last 100 trades)
                                    </div>
                                </div>
                                <div class="tooltip-container">
                                    <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                    <div class="tooltip">
                                        Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 1) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-blue">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="gemini-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Groq Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-purple">Groq DeepSeek</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-gray-400">Performance Score:</span>
                                <div class="tooltip-container">
                                    <span id="groq-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                    <div class="tooltip">
                                        Weighted average of recent trade scores (last 100 trades)
                                    </div>
                                </div>
                                <div class="tooltip-container">
                                    <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                    <div class="tooltip">
                                        Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 1) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-purple">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="groq-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Mistral Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-green">Mistral AI</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-gray-400">Performance Score:</span>
                                <div class="tooltip-container">
                                    <span id="mistral-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                    <div class="tooltip">
                                        Weighted average of recent trade scores (last 100 trades)
                                    </div>
                                </div>
                                <div class="tooltip-container">
                                    <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                    <div class="tooltip">
                                        Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 1) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-green">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="mistral-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>
</body>
</html> 
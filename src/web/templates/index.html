<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Crypto Trading Bot Chef</title>
    <link rel="icon" type="image/webp" href="static/favicon.webp">
    <link rel="stylesheet" href="static/css/styles.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Include utilities JS -->
    <script src="static/js/utils.js"></script>
    <!-- Include market analysis JS -->
    <script src="static/js/marketAnalysis.js"></script>
    <!-- Include chart handlers JS -->
    <script src="static/js/chartHandlers.js"></script>
    <!-- Include wallet manager JS -->
    <script src="static/js/walletManager.js"></script>
    <!-- Include notification manager JS -->
    <script src="static/js/notificationManager.js"></script>
    <!-- Include model predictions JS -->
    <script src="static/js/modelPredictions.js"></script>
    <!-- Include stats manager JS -->
    <script src="static/js/statsManager.js"></script>
    <script>
        // Initialize a notification permission state variable
        let notificationPermissionGranted = false;
        
        // Storage keys for persisting data
        const STORAGE_KEYS = {
            WALLET: 'stbchef_wallet',
            HISTORY: 'stbchef_history',
            LAST_UPDATE: 'stbchef_last_update',
            PRICE_DATA: 'stbchef_price_data',
            VOLUME_DATA: 'stbchef_volume_data',
            TIME_LABELS: 'stbchef_time_labels',
            TRADE_HISTORY: 'stbchef_trade_history',
            MODEL_PERFORMANCE: 'stbchef_model_performance'
        };
        
        // Initialize variables
        window.web3 = null;
        window.userAccount = null;
        let priceChart;
        let performanceChart;
        let priceHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.PRICE_DATA) || '[]');
        let timeLabels = JSON.parse(localStorage.getItem(STORAGE_KEYS.TIME_LABELS) || '[]');
        let volumeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.VOLUME_DATA) || '[]');
        const tradingActions = [];

        // Make chart data available globally
        window.priceHistory = priceHistory;
        window.timeLabels = timeLabels;
        window.volumeHistory = volumeHistory;
        window.STORAGE_KEYS = STORAGE_KEYS;

        // Initialize trade history for each model
        let tradeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.TRADE_HISTORY) || JSON.stringify({
            gemini: [],
            groq: [],
            mistral: []
        }));
        
        // Make tradeHistory available globally
        window.tradeHistory = tradeHistory;

        // Add accuracy tracking variables
        let aiAccuracy = JSON.parse(localStorage.getItem(STORAGE_KEYS.MODEL_PERFORMANCE) || JSON.stringify({
            gemini: { correct: 0, total: 0 },
            groq: { correct: 0, total: 0 },
            mistral: { correct: 0, total: 0 }
        }));
        
        // Make aiAccuracy available globally
        window.aiAccuracy = aiAccuracy;

        // Add market volatility tracking
        let marketVolatility = {
            window: 24, // 24-hour window
            data: [],
            current: 0
        };

        // Functions moved to marketAnalysis.js
        
        let lastDecisions = {
            gemini: null,
            groq: null,
            mistral: null,
            price: null
        };

        // Make lastDecisions available globally
        window.lastDecisions = lastDecisions;
        // Make marketVolatility available globally
        window.marketVolatility = marketVolatility;

        // User account is already initialized as a global variable

        // Load persisted wallet connection on page load
        window.addEventListener('load', async () => {
            const persistedWallet = localStorage.getItem(STORAGE_KEYS.WALLET);
            if (persistedWallet && typeof window.ethereum !== 'undefined') {
                try {
                    window.web3 = new Web3(window.ethereum);
                    
                    // First check if ethereum is connected at all
                    const isConnected = window.ethereum.isConnected();
                    if (!isConnected) {
                        console.log('MetaMask is not connected, waiting for connection...');
                        // Wait for connection
                        await new Promise(resolve => {
                            const connectionCheckInterval = setInterval(() => {
                                if (window.ethereum.isConnected()) {
                                    clearInterval(connectionCheckInterval);
                                    resolve();
                                }
                            }, 100);
                            // Timeout after 3 seconds
                            setTimeout(() => {
                                clearInterval(connectionCheckInterval);
                                resolve();
                            }, 3000);
                        });
                    }
                    
                    // Request accounts - this will NOT prompt if already connected
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    
                    if (accounts.length === 0) {
                        // Need to explicitly request accounts
                        try {
                            const requestedAccounts = await window.ethereum.request({ 
                                method: 'eth_requestAccounts',
                                params: [] 
                            });
                            
                            if (requestedAccounts.length > 0 && 
                                requestedAccounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                                userAccount = requestedAccounts[0];
                            } else if (requestedAccounts.length > 0) {
                                // Different account than stored
                                userAccount = requestedAccounts[0];
                                persistWalletConnection(userAccount);
                            }
                        } catch (err) {
                            console.log('User rejected connection or request failed:', err);
                            localStorage.removeItem(STORAGE_KEYS.WALLET);
                            userAccount = null;
                            updateWalletUI();
                            return;
                        }
                    } else if (accounts[0] && accounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                        userAccount = accounts[0];
                    } else if (accounts.length > 0) {
                        // If account is available but different from stored one, update it
                        userAccount = accounts[0];
                        persistWalletConnection(userAccount);
                    }
                    
                    if (userAccount) {
                        updateWalletUI();
                        
                        // Fetch initial wallet data
                        await getWalletBalances();
                        
                        // Ensure model decisions are updated with wallet connection status
                        fetch('/api/trading-data')
                            .then(response => response.json())
                            .then(data => {
                                updateModelDecisions(data, userAccount);
                            })
                            .catch(error => {
                                console.error("Failed to fetch initial trading data:", error);
                            });
                            
                        // Load wallet-specific stats
                        fetchWalletStats();
                        
                        // Setup session persistence - check connection status periodically
                        setInterval(async () => {
                            if (typeof window.ethereum !== 'undefined') {
                                const isStillConnected = window.ethereum.isConnected();
                                const currentAccounts = await window.ethereum.request({ method: 'eth_accounts' })
                                    .catch(() => []);
                                
                                // If metamask disconnected or account changed unexpectedly
                                if (!isStillConnected || currentAccounts.length === 0 || 
                                    (userAccount && currentAccounts[0].toLowerCase() !== userAccount.toLowerCase())) {
                                    // Attempt to reconnect silently
                                    if (isStillConnected && currentAccounts.length === 0) {
                                        try {
                                            const reconnectAccounts = await window.ethereum.request({ 
                                                method: 'eth_requestAccounts',
                                                params: [] 
                                            }).catch(() => []);
                                            
                                            if (reconnectAccounts.length > 0) {
                                                userAccount = reconnectAccounts[0];
                                                persistWalletConnection(userAccount);
                                                updateWalletUI();
                                                await getWalletBalances();
                                                fetchWalletStats();
                                            }
                                        } catch (e) {
                                            // Silent reconnect failed, don't bother user
                                            console.log('Silent reconnect failed:', e);
                                        }
                                    }
                                }
                            }
                        }, 10000); // Check every 10 seconds
                    }
                } catch (error) {
                    console.error('Error restoring wallet connection:', error);
                    localStorage.removeItem(STORAGE_KEYS.WALLET);
                    userAccount = null;
                    updateWalletUI();
                }
            } else {
                // Ensure model decisions show "Connect wallet first"
                fetch('/api/trading-data')
                    .then(response => response.json())
                    .then(data => {
                        updateModelDecisions(data, null);
                    })
                    .catch(error => {
                        console.error("Failed to fetch initial trading data:", error);
                    });
            }
            clearExpiredData();
            
            // Setup visibility change handler to refresh wallet connection when tab becomes visible again
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    // Tab is now visible, check wallet connection
                    const persistedWallet = localStorage.getItem(STORAGE_KEYS.WALLET);
                    if (persistedWallet && typeof window.ethereum !== 'undefined') {
                        try {
                            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                            if (accounts.length > 0) {
                                // If we have a stored wallet but it doesn't match, update it
                                if (!userAccount || accounts[0].toLowerCase() !== userAccount.toLowerCase()) {
                                    userAccount = accounts[0];
                                    persistWalletConnection(userAccount);
                                    updateWalletUI();
                                    await getWalletBalances();
                                    fetchWalletStats();
                                    
                                    // Update LLM decisions for the new account
                                    const tradingData = await fetch('/api/trading-data').then(res => res.json());
                                    updateModelDecisions(tradingData, userAccount);
                                }
                            } else if (userAccount) {
                                // We have a userAccount but ethereum doesn't show any accounts
                                // Try silently reconnecting
                                try {
                                    const reconnectAccounts = await window.ethereum.request({ 
                                        method: 'eth_requestAccounts',
                                        params: [] 
                                    }).catch(() => []);
                                    
                                    if (reconnectAccounts.length > 0) {
                                        userAccount = reconnectAccounts[0];
                                        persistWalletConnection(userAccount);
                                        updateWalletUI();
                                        await getWalletBalances();
                                        fetchWalletStats();
                                    } else {
                                        // Failed to reconnect silently, reset wallet state
                                        userAccount = null;
                                        persistWalletConnection(null);
                                        updateWalletUI();
                                        displayEmptyStats();
                                    }
                                } catch (e) {
                                    // Silent reconnect failed, reset wallet state
                                    userAccount = null;
                                    persistWalletConnection(null);
                                    updateWalletUI();
                                    displayEmptyStats();
                                }
                            }
                        } catch (error) {
                            console.error('Error checking wallet connection on visibility change:', error);
                        }
                    }
                }
            });
        });

        // Modified wallet connection function
        async function connectWallet() {
            // If already connected, disconnect
            if (window.userAccount) {
                window.userAccount = null;
                window.web3 = null;
                resetWalletBalances();
                
                // Remove from localStorage to prevent auto-reconnect
                localStorage.removeItem(STORAGE_KEYS.WALLET);
                
                // Clear raw accuracy data from localStorage
                localStorage.removeItem('stbchef_raw_accuracy');
                
                // Reset raw accuracy tracking
                aiRawAccuracy = {
                    gemini: { correct: 0, total: 0, accuracy: 0 },
                    groq: { correct: 0, total: 0, accuracy: 0 },
                    mistral: { correct: 0, total: 0, accuracy: 0 }
                };
                
                // Update UI
                updateWalletUI();
                
                // Clear model performance when disconnecting
                displayEmptyStats();
                
                // Update LLM decision cards to show "Connect wallet first"
                try {
                    const tradingData = await fetch('/api/trading-data').then(res => res.json());
                    updateModelDecisions(tradingData, null);
                } catch (error) {
                    console.error('Error updating model decisions after disconnect:', error);
                }
                
                showNotification('Wallet disconnected', 'warning');
                return;
            }
            
            if (typeof window.ethereum !== 'undefined') {
                try {
                    // Show loading state on wallet button
                    const walletBtn = document.getElementById('wallet-btn');
                    if (walletBtn) {
                        walletBtn.innerHTML = '<i class="fas fa-sync-alt fa-spin mr-2"></i> Connecting...';
                        walletBtn.classList.add('connecting');
                    }
                    
                    // Request accounts
                    const accounts = await window.ethereum.request({ 
                        method: 'eth_requestAccounts',
                        params: []
                    }).catch(error => {
                        console.error('User denied account access:', error);
                        
                        // Reset wallet button
                        if (walletBtn) {
                            walletBtn.innerHTML = 'Connect Wallet';
                            walletBtn.classList.remove('connecting');
                        }
                        
                        showNotification('Failed to connect wallet', 'error');
                        throw error;
                    });
                    
                    if (!accounts || accounts.length === 0) {
                        // Reset wallet button
                        if (walletBtn) {
                            walletBtn.innerHTML = 'Connect Wallet';
                            walletBtn.classList.remove('connecting');
                        }
                        
                        showNotification('No accounts found', 'error');
                        return;
                    }
                    
                    window.userAccount = accounts[0];
                    window.web3 = new Web3(window.ethereum);

                    // Check which network we're on
                    const chainId = await window.web3.eth.getChainId();
                    const isLinea = chainId === 59144;
                    const isEthereum = chainId === 1;
                    
                    // Only show warning if on unsupported network, no need for confirmation on supported ones
                    if (!isLinea && !isEthereum) {
                        showNotification(`Connected to unsupported network (ID: ${chainId}). Please switch to Linea (ID: 59144) or Ethereum (ID: 1).`, 'warning');
                    }

                    // Save account immediately
                    persistWalletConnection(window.userAccount);
                    
                    // Show loading state on wallet card
                    const walletCard = document.getElementById('wallet-card');
                    if (walletCard) {
                        walletCard.innerHTML = `
                            <div class="flex flex-col">
                                <div class="flex items-center justify-between mb-3">
                                    <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                </div>
                                <div class="flex flex-col items-center justify-center h-24">
                                    <p class="text-gray-400 mb-2">Loading wallet data...</p>
                                    <div class="spinner"><i class="fas fa-sync-alt fa-spin"></i></div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Update UI before API calls
                    updateWalletUI();
                    
                    try {
                        // Get wallet balances after connecting
                        await getWalletBalances();
                    } catch (error) {
                        console.error('Error fetching wallet balances:', error);
                        showNotification('Connected, but could not fetch wallet balances', 'warning');
                    }
                    
                    try {
                        // Update model performance cards with wallet-specific data
                        await fetchWalletStats();
                    } catch (error) {
                        console.error('Error fetching wallet stats:', error);
                    }
                    
                    try {
                        // Update LLM decision cards
                        const tradingData = await fetch('/api/trading-data').then(res => res.json());
                        updateModelDecisions(tradingData, window.userAccount);
                    } catch (error) {
                        console.error('Error updating model decisions:', error);
                    }
                    
                    showNotification('Wallet connected successfully!', 'success');

                    // Request notification permission after wallet connection
                    await requestNotificationPermission();

                    // Handle account changes - only set up once
                    if (!window.hasSetupMetaMaskEvents) {
                        window.hasSetupMetaMaskEvents = true;
                        
                        window.ethereum.on('accountsChanged', function (accounts) {
                            if (accounts.length === 0) {
                                window.userAccount = null;
                                resetWalletBalances();
                                
                                // Remove from localStorage
                                localStorage.removeItem(STORAGE_KEYS.WALLET);
                                
                                // Clear raw accuracy data from localStorage
                                localStorage.removeItem('stbchef_raw_accuracy');
                                
                                // Reset raw accuracy tracking
                                aiRawAccuracy = {
                                    gemini: { correct: 0, total: 0, accuracy: 0 },
                                    groq: { correct: 0, total: 0, accuracy: 0 },
                                    mistral: { correct: 0, total: 0, accuracy: 0 }
                                };
                                
                                // Update UI
                                updateWalletUI();
                                
                                // Update model stats and LLM decisions on disconnect
                                displayEmptyStats();
                                fetch('/api/trading-data')
                                    .then(res => res.json())
                                    .then(data => updateModelDecisions(data, null))
                                    .catch(error => console.error('Error updating model decisions:', error));
                            } else {
                                userAccount = accounts[0];
                                
                                // Clear old raw accuracy data since we're connecting to a new wallet
                                localStorage.removeItem('stbchef_raw_accuracy');
                                
                                // Reset raw accuracy tracking for new wallet
                                aiRawAccuracy = {
                                    gemini: { correct: 0, total: 0, accuracy: 0 },
                                    groq: { correct: 0, total: 0, accuracy: 0 },
                                    mistral: { correct: 0, total: 0, accuracy: 0 }
                                };
                                
                                // Save to localStorage
                                persistWalletConnection(userAccount);
                                
                                // Update UI
                                updateWalletUI();
                                
                                // Update wallet data
                                getWalletBalances().catch(error => 
                                    console.error('Error fetching wallet balances after account change:', error));
                                
                                // Request permission for new account
                                requestNotificationPermission().catch(error => 
                                    console.error('Error requesting notification permission:', error)); 
                                
                                // Update model stats and LLM decisions on account change
                                fetchWalletStats().catch(error => 
                                    console.error('Error fetching wallet stats after account change:', error));
                                
                                fetch('/api/trading-data')
                                    .then(res => res.json())
                                    .then(data => updateModelDecisions(data, window.userAccount))
                                    .catch(error => console.error('Error updating model decisions:', error));
                            }
                            
                            showNotification(accounts.length === 0 ? 'Wallet disconnected' : 'Wallet account changed', 
                                            accounts.length === 0 ? 'warning' : 'info');
                        });
                        
                        // Update balances when chain changes
                        window.ethereum.on('chainChanged', function (chainIdHex) {
                            const newChainId = parseInt(chainIdHex, 16);
                            const isLinea = newChainId === 59144;
                            const isEthereum = newChainId === 1;
                            
                            // Only show warning if on unsupported network
                            if (!isLinea && !isEthereum) {
                                showNotification(`Switched to unsupported network (ID: ${newChainId}). 
                                                Please switch to Linea (ID: 59144) or Ethereum (ID: 1).`, 'warning');
                            }
                            
                            // Update wallet data
                            getWalletBalances().catch(error => 
                                console.error('Error fetching wallet balances after chain change:', error));
                            
                            // Update UI
                            updateWalletUI();
                            
                            // Update model stats and decisions
                            fetchWalletStats().catch(error => 
                                console.error('Error fetching wallet stats after chain change:', error));
                            
                            fetch('/api/trading-data')
                                .then(res => res.json())
                                .then(data => updateModelDecisions(data, window.userAccount))
                                .catch(error => console.error('Error updating model decisions:', error));
                            
                            showNotification(`Network changed to ID: ${newChainId}`, 'info');
                        });
                        
                        // Handle disconnect event
                        window.ethereum.on('disconnect', function (error) {
                            console.log('MetaMask disconnected:', error);
                            
                            // Only clear if this is our current connection
                            if (window.userAccount) {
                                userAccount = null;
                                resetWalletBalances();
                                
                                // Remove from localStorage
                                localStorage.removeItem(STORAGE_KEYS.WALLET);
                                
                                // Clear raw accuracy data from localStorage
                                localStorage.removeItem('stbchef_raw_accuracy');
                                
                                // Reset raw accuracy tracking
                                aiRawAccuracy = {
                                    gemini: { correct: 0, total: 0, accuracy: 0 },
                                    groq: { correct: 0, total: 0, accuracy: 0 },
                                    mistral: { correct: 0, total: 0, accuracy: 0 }
                                };
                                
                                // Update UI
                                updateWalletUI();
                                
                                // Update model stats and LLM decisions
                                displayEmptyStats();
                                fetch('/api/trading-data')
                                    .then(res => res.json())
                                    .then(data => updateModelDecisions(data, null))
                                    .catch(error => console.error('Error updating model decisions:', error));
                                
                                showNotification('Wallet disconnected', 'warning');
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error connecting wallet:', error);
                    showNotification('Failed to connect wallet', 'error');
                    
                    // Reset wallet button
                    const walletBtn = document.getElementById('wallet-btn');
                    if (walletBtn) {
                        walletBtn.innerHTML = 'Connect Wallet';
                        walletBtn.classList.remove('connecting');
                    }
                }
            } else {
                showNotification('Please install MetaMask!', 'error');
            }
        }
        
        // Define token contract ABIs
        const ERC20_ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            }
        ];
        
        // Wallet balances
        let walletBalances = {
            eth: 0,
            usdc: 0,
            ethusd: 0, // Current ETH/USD price
            totalValueUSD: 0
        };
        
        // Get wallet balances
        async function getWalletBalances() {
            if (!window.userAccount || !window.web3) {
                console.log("No wallet connection available");
                resetWalletBalances();
                return;
            }
            
            try {
                console.log("Fetching wallet balances for", window.userAccount);
                
                // Show loading state while fetching wallet data
                showLoadingWalletState("Retrieving wallet balances...");
                
                // Get current network ID with timeout
                let chainId;
                try {
                    const timeout = ms => new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Chain ID request timed out')), ms));
                    
                    chainId = await Promise.race([
                        window.web3.eth.getChainId(),
                        timeout(3000) // 3 second timeout
                    ]);
                    console.log("Current chain ID:", chainId);
                } catch (chainError) {
                    console.error("Error getting chain ID:", chainError);
                    chainId = 0; // Use 0 as "unknown network"
                    
                    // Update loading state to show network issue
                    showLoadingWalletState("Network detection issue - please check MetaMask");
                }
                
                // Check if we're on Linea (Chain ID 59144) or Ethereum (Chain ID 1)
                const isLinea = chainId === 59144;
                const isEthereum = chainId === 1;
                const isSupportedNetwork = isLinea || isEthereum;
                
                if (!isSupportedNetwork) {
                    showNotification(`Unsupported network (Chain ID: ${chainId}). Please switch to Linea or Ethereum mainnet.`, 'warning');
                    console.warn(`Unsupported network: ${chainId}`);
                    
                    // Update loading state to show network issue
                    showLoadingWalletState("Connected to unsupported network - please switch");
                }
                
                // Get ETH balance
                const ethBalance = await window.web3.eth.getBalance(window.userAccount);
                walletBalances.eth = parseFloat(window.web3.utils.fromWei(ethBalance, 'ether'));
                console.log("ETH balance:", walletBalances.eth);
                
                // Only try to get USDC balance if we're on a supported network
                walletBalances.usdc = 0; // Default to 0
                
                if (isLinea) {
                    // Update loading state to show token balance retrieval
                    showLoadingWalletState("Retrieving Linea USDC balance...");
                    
                    // USDC on Linea
                    const lineaUsdcAddress = '0x176211869cA2b568f2A7D4EE941E073a821EE1ff';
                    try {
                        await getTokenBalance(lineaUsdcAddress);
                    } catch (contractError) {
                        console.warn("Error fetching Linea USDC balance:", contractError.message);
                    }
                } else if (isEthereum) {
                    // Update loading state to show token balance retrieval
                    showLoadingWalletState("Retrieving Ethereum USDC balance...");
                    
                    // USDC on Ethereum Mainnet
                    const ethUsdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
                    try {
                        await getTokenBalance(ethUsdcAddress);
                    } catch (contractError) {
                        console.warn("Error fetching Ethereum USDC balance:", contractError.message);
                    }
                }
                
                // Update loading state to show price data retrieval
                showLoadingWalletState("Retrieving ETH price data...");
                
                // Get ETH price from the UI - NEVER use a default price
                let validPriceFound = false;
                try {
                    const priceText = document.getElementById('eth-price').textContent;
                    if (priceText && priceText !== 'Error' && priceText !== 'Waiting for data...') {
                        const parsedPrice = parseFloat(priceText.replace('$', '').trim());
                        if (!isNaN(parsedPrice) && parsedPrice > 0) {
                            walletBalances.ethusd = parsedPrice;
                            console.log("ETH/USD price from UI:", walletBalances.ethusd);
                            validPriceFound = true;
                        }
                    }
                    
                    // If UI price failed, try the API directly
                    if (!validPriceFound) {
                        const response = await fetch('/api/trading-data');
                        const data = await response.json();
                        if (data && data.eth_price && !isNaN(parseFloat(data.eth_price)) && parseFloat(data.eth_price) > 0) {
                            walletBalances.ethusd = parseFloat(data.eth_price);
                            console.log("ETH/USD price from API:", walletBalances.ethusd);
                            validPriceFound = true;
                        }
                    }
                } catch (priceError) {
                    console.warn("Error getting ETH price:", priceError);
                    validPriceFound = false;
                }
                
                if (!validPriceFound) {
                    console.warn("No valid ETH price available - cannot calculate wallet value");
                    walletBalances.ethusd = 0;
                    walletBalances.totalValueUSD = 0;
                    
                    // Show specific message about missing price data
                    walletCard.innerHTML = `
                        <div class="p-4">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                <div class="flex items-center">
                                    <span class="text-xs ${isLinea ? 'text-green-400' : isEthereum ? 'text-green-400' : 'text-yellow-400'} mr-2">
                                        Network: ${isLinea ? 'Linea' : isEthereum ? 'Ethereum' : 'Unknown'}
                                    </span>
                                    <span class="text-xs text-gray-400">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                </div>
                            </div>
                            <div class="flex flex-col">
                                <div class="grid grid-cols-2 gap-2 text-sm">
                                    <div>
                                        <div class="text-gray-400">ETH Balance:</div>
                                        <div class="font-bold text-cyber-text">${walletBalances.eth.toFixed(4)} ETH</div>
                                    </div>
                                    <div>
                                        <div class="text-gray-400">USDC Balance:</div>
                                        <div class="font-bold text-cyber-text">${walletBalances.usdc.toFixed(2)} USDC</div>
                                    </div>
                                </div>
                                <div class="mt-4 text-center">
                                    <p class="text-yellow-400">Waiting for ETH price data</p>
                                    <p class="text-xs text-gray-400 mt-1">Wallet balances ready, but portfolio analysis requires price data</p>
                                </div>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Calculate total wallet value only if we have a valid price
                walletBalances.totalValueUSD = (walletBalances.eth * walletBalances.ethusd) + walletBalances.usdc;
                console.log("ETH value in USD:", walletBalances.eth * walletBalances.ethusd);
                console.log("USDC value:", walletBalances.usdc);
                console.log("Total wallet value:", walletBalances.totalValueUSD, "USD");
                
                // Update UI
                updateWalletCard();
                updateModelStatsForWallet();
            } catch (error) {
                console.error("Error fetching wallet balances:", error);
                showNotification("Error fetching wallet balances: " + error.message, "error");
                
                // Show specific error message in wallet card
                const walletCard = document.getElementById('wallet-card');
                if (walletCard) {
                    walletCard.innerHTML = `
                        <div class="p-4">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            </div>
                            <div class="flex flex-col items-center justify-center py-4">
                                <p class="text-red-400 mb-2">Error retrieving wallet data</p>
                                <p class="text-xs text-gray-400 text-center">${error.message}</p>
                                <button onclick="getWalletBalances()" class="cyber-btn mt-3 text-xs px-3 py-1">
                                    <i class="fas fa-sync-alt mr-1"></i> Retry
                                </button>
                            </div>
                        </div>
                    `;
                }
                // Don't reset wallet balances here, keep whatever was valid previously
            }
        }
        
        // Get token balance helper function
        async function getTokenBalance(tokenAddress) {
            try {
                console.log(`Attempting to fetch token balance for ${tokenAddress}`);
                
                // Create contract instance with error checking
                let tokenContract;
                try {
                    tokenContract = new window.web3.eth.Contract(ERC20_ABI, tokenAddress);
                    
                    // Check if methods and necessary functions exist on the contract
                    if (!tokenContract.methods || typeof tokenContract.methods.symbol !== 'function') {
                        console.error('Contract methods not properly initialized or symbol method is missing');
                        // Create a properly structured contract to avoid errors
                        tokenContract = {
                            methods: {
                                symbol: () => ({ call: async () => 'UNKNOWN' }),
                                decimals: () => ({ call: async () => '6' }),
                                balanceOf: (address) => ({ call: async () => '0' })
                            }
                        };
                    }
                } catch (contractError) {
                    console.error(`Failed to create contract instance: ${contractError.message}`);
                    // Create a fallback contract object with minimum required methods
                    tokenContract = {
                        methods: {
                            symbol: () => ({ call: async () => 'UNKNOWN' }),
                            decimals: () => ({ call: async () => '6' }),
                            balanceOf: (address) => ({ call: async () => '0' })
                        }
                    };
                }
                
                // Use shorter timeouts to avoid hanging
                const timeout = ms => new Promise((_, reject) => 
                    setTimeout(() => reject(new Error(`Contract call timed out after ${ms}ms`)), ms));
                
                // First check if the contract responds at all with a simple call
                try {
                    // Brief timeout for simple call
                    const contractCheck = await Promise.race([
                        tokenContract.methods.symbol().call(),
                        timeout(2000)
                    ]);
                    console.log(`Contract ${tokenAddress} responds with symbol: ${contractCheck}`);
                } catch (checkError) {
                    console.warn(`Contract not responding properly: ${checkError.message}`);
                    // Continue anyway, might still work
                }
                
                // Attempt the balance calls with shorter timeouts
                console.log(`Fetching decimals and balance from ${tokenAddress}`);
                let decimals, balance;
                
                try {
                    // Try decimals first with short timeout
                    decimals = await Promise.race([
                        tokenContract.methods.decimals().call(),
                        timeout(3000)
                    ]);
                    console.log(`Token decimals: ${decimals}`);
                } catch (decimalsError) {
                    console.warn(`Failed to get decimals: ${decimalsError.message}, using default value 6`);
                    // Default to 6 decimals for USDC as fallback
                    decimals = 6;
                }
                
                try {
                    // Try balance next with short timeout
                    balance = await Promise.race([
                        tokenContract.methods.balanceOf(window.userAccount).call(),
                        timeout(3000)
                    ]);
                    console.log(`Token balance (raw): ${balance}`);
                } catch (balanceError) {
                    console.warn(`Failed to get balance: ${balanceError.message}, using 0`);
                    // Default to 0 balance as fallback
                    balance = "0";
                }
                
                // Validate returned values with defensive programming
                if (balance === undefined || balance === null) {
                    console.warn("Received undefined/null balance, defaulting to 0");
                    balance = "0";
                }
                
                if (decimals === undefined || decimals === null) {
                    console.warn("Received undefined/null decimals, defaulting to 6");
                    decimals = 6;
                }
                
                // Parse values with error checking
                let decimalValue, balanceValue;
                try {
                    decimalValue = parseInt(decimals);
                    if (isNaN(decimalValue)) {
                        console.warn("Invalid decimals value, defaulting to 6");
                        decimalValue = 6;
                    }
                } catch (parseError) {
                    console.warn(`Error parsing decimals: ${parseError.message}, using default 6`);
                    decimalValue = 6;
                }
                
                try {
                    balanceValue = parseFloat(balance);
                    if (isNaN(balanceValue)) {
                        console.warn("Invalid balance value, defaulting to 0");
                        balanceValue = 0;
                    }
                } catch (parseError) {
                    console.warn(`Error parsing balance: ${parseError.message}, using 0`);
                    balanceValue = 0;
                }
                
                // Calculate final balance
                walletBalances.usdc = balanceValue / Math.pow(10, decimalValue);
                console.log(`USDC balance (formatted): ${walletBalances.usdc}`);
                return walletBalances.usdc;
            } catch (error) {
                // Log detailed error information, but don't fail catastrophically
                logToServer('error', "Token contract error", {
                    message: error.message,
                    tokenAddress: tokenAddress,
                    userAccount: window.userAccount,
                    chainId: window.web3.eth.chainId || 'unknown'
                });
                
                // Set USDC to 0 on error
                walletBalances.usdc = 0;
                return 0;
            }
        }
        
        // Reset wallet balances
        function resetWalletBalances() {
            walletBalances = {
                eth: 0,
                usdc: 0,
                ethusd: 0,
                totalValueUSD: 0
            };
            updateWalletCard();
            updateModelStatsForWallet();
        }
        
        // Update wallet card with current balances
        function updateWalletCard() {
            const walletCard = document.getElementById('wallet-card');
            if (!walletCard) return;
            
            if (!window.userAccount || !window.web3) {
                walletCard.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full">
                        <p class="text-gray-400 mb-2">Connect your wallet to see balances</p>
                    </div>
                `;
                return;
            }
            
            // Check if we have valid price data
            const hasValidPrice = walletBalances.ethusd && !isNaN(walletBalances.ethusd) && walletBalances.ethusd > 0;
            
            // Check if we're on Linea network
            window.web3.eth.getChainId().then(chainId => {
                const isLinea = chainId === 59144;
                const isEthereum = chainId === 1;
                const networkName = isLinea ? 'Linea' : isEthereum ? 'Ethereum' : 'Unknown Network';
                const networkClass = isLinea || isEthereum ? 'text-green-400' : 'text-yellow-400';
                
                // Network switching buttons
                const switchNetworkButtons = isLinea || isEthereum ? `
                    <div class="col-span-2 mt-3 flex justify-center space-x-4">
                        <button onclick="${isEthereum ? 'void(0)' : 'switchNetwork(1)'}" class="network-btn ${isEthereum ? 'network-active cursor-not-allowed opacity-80' : ''} flex items-center">
                            <div class="network-icon eth-icon">
                                <svg class="w-4 h-4" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 32C24.8366 32 32 24.8366 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32ZM15.9963 5.33333L15.8 5.88333V20.2L15.9963 20.3967L22.6599 16.405L15.9963 5.33333Z" fill="#627EEA" fill-opacity="0.7"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 5.33333L9.33333 16.405L16 20.3967V13.4183V5.33333Z" fill="#627EEA"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 21.93L15.8917 22.0633V26.4117L16 26.6633L22.6667 17.94L16 21.93Z" fill="#627EEA" fill-opacity="0.7"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 26.6633V21.93L9.33333 17.94L16 26.6633Z" fill="#627EEA"/>
                                </svg>
                            </div>
                            <span>Ethereum</span>
                            ${isEthereum ? '<span class="active-indicator">●</span>' : ''}
                        </button>
                        <button onclick="${isLinea ? 'void(0)' : 'switchNetwork(59144)'}" class="network-btn ${isLinea ? 'network-active cursor-not-allowed opacity-80' : ''} flex items-center">
                            <div class="network-icon linea-icon">
                                <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 24C18.6274 24 24 18.6274 24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24Z" fill="#121212"/>
                                    <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="#00ABFF"/>
                                    <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="#00ABFF"/>
                                    <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="#00ABFF"/>
                                </svg>
                            </div>
                            <span>Linea</span>
                            ${isLinea ? '<span class="active-indicator">●</span>' : ''}
                        </button>
                    </div>
                ` : `
                    <div class="col-span-2 mt-3">
                        <div class="text-yellow-400 text-xs text-center mb-2">Switch to a supported network</div>
                        <div class="flex justify-center space-x-4">
                            <button onclick="switchNetwork(1)" class="network-btn flex items-center">
                                <div class="network-icon eth-icon">
                                    <svg class="w-4 h-4" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 32C24.8366 32 32 24.8366 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32ZM15.9963 5.33333L15.8 5.88333V20.2L15.9963 20.3967L22.6599 16.405L15.9963 5.33333Z" fill="#627EEA" fill-opacity="0.7"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 5.33333L9.33333 16.405L16 20.3967V13.4183V5.33333Z" fill="#627EEA"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 21.93L15.8917 22.0633V26.4117L16 26.6633L22.6667 17.94L16 21.93Z" fill="#627EEA" fill-opacity="0.7"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 26.6633V21.93L9.33333 17.94L16 26.6633Z" fill="#627EEA"/>
                                    </svg>
                                </div>
                                <span>Ethereum</span>
                            </button>
                            <button onclick="switchNetwork(59144)" class="network-btn flex items-center">
                                <div class="network-icon linea-icon">
                                    <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 24C18.6274 24 24 18.6274 24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24Z" fill="#121212"/>
                                        <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="#00ABFF"/>
                                        <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="#00ABFF"/>
                                        <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="#00ABFF"/>
                                    </svg>
                                </div>
                                <span>Linea</span>
                            </button>
                        </div>
                    </div>
                `;
                
                // If we don't have a valid ETH price, show error and don't make calculations
                if (!hasValidPrice) {
                    walletCard.innerHTML = `
                        <div class="p-4">
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 ${isLinea ? 'border-blue-400' : isEthereum ? 'border-indigo-400' : 'border-yellow-400'} hover:shadow-glow transition-all duration-300">
                                    ${isLinea ? `
                                        <div class="network-icon-container mr-2 relative overflow-hidden">
                                            <svg class="w-5 h-5 text-blue-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                                <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(0,171,255,0.1)"/>
                                                <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="currentColor"/>
                                                <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="currentColor"/>
                                                <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="currentColor"/>
                                            </svg>
                                            <div class="absolute inset-0 bg-gradient-to-r from-transparent via-blue-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                        </div>
                                    ` : isEthereum ? `
                                        <div class="network-icon-container mr-2 relative overflow-hidden">
                                            <svg class="w-5 h-5 text-indigo-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                                <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(98,126,234,0.1)"/>
                                                <path d="M11.9982 4L11.8 4.4V15.1133L11.9982 15.275L16.9963 12.3L11.9982 4Z" fill="currentColor" fill-opacity="0.7"/>
                                                <path d="M12 4L7 12.3L12 15.275V10.0582V4Z" fill="currentColor"/>
                                                <path d="M11.9982 16.4826L11.9063 16.597V19.8105L11.9982 20L17 13.4264L11.9982 16.4826Z" fill="currentColor" fill-opacity="0.7"/>
                                                <path d="M12 20V16.4826L7 13.4264L12 20Z" fill="currentColor"/>
                                            </svg>
                                            <div class="absolute inset-0 bg-gradient-to-r from-transparent via-indigo-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                        </div>
                                    ` : `
                                        <div class="network-icon-container mr-2 relative overflow-hidden">
                                            <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                            </svg>
                                        </div>
                                    `}
                                    <div class="flex flex-col">
                                        <div class="text-xs ${isLinea ? 'text-blue-400' : isEthereum ? 'text-indigo-400' : 'text-yellow-400'} font-medium network-name">${networkName}</div>
                                        <div class="flex items-center">
                                            <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                            <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>
                                    <div class="text-gray-400">ETH Balance:</div>
                                    <div class="font-bold text-cyber-text">${walletBalances.eth.toFixed(4)} ETH</div>
                                    <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">USDC Balance:</div>
                                    <div class="font-bold text-cyber-text">${walletBalances.usdc.toFixed(2)} USDC</div>
                                    <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                                </div>
                                ${switchNetworkButtons}
                                <div class="col-span-2 mt-3 text-center">
                                    <p class="text-yellow-400">Wallet portfolio analysis paused</p>
                                    <p class="text-xs text-gray-400 mt-1">Portfolio recommendations will resume once data is available</p>
                                </div>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Calculate optimal action based on current portfolio allocation
                const ethValue = walletBalances.eth || 0;
                const usdcValue = walletBalances.usdc || 0;
                const ethPrice = walletBalances.ethusd || 0;
                
                const ethValueUSD = ethValue * ethPrice;
                const totalValue = (ethValueUSD + usdcValue) || 0;
                
                // Handle zero balance case properly with additional validation
                const hasNonZeroBalance = (ethValue > 0 || usdcValue > 0) && totalValue > 0;
                const currentEthAllocation = hasNonZeroBalance ? Math.min(100, Math.max(0, (ethValueUSD / totalValue * 100))) : 0;
                const currentUsdcAllocation = hasNonZeroBalance ? Math.min(100, Math.max(0, 100 - currentEthAllocation)) : 0;
                
                // Target allocation range: 60-80% ETH in bullish, 20-40% in bearish
                const marketSentiment = document.getElementById('sentiment');
                const isBullish = marketSentiment && marketSentiment.textContent.includes('bullish');
                
                const targetEthMin = isBullish ? 60 : 20;
                const targetEthMax = isBullish ? 80 : 40;
                
                // Instead of portfolio-based decision, use AI consensus or latest decisions if available
                let recommendedAction = 'HOLD';
                let swapAmount = 0;
                let swapDirection = '';
                
                // Get decisions from AI models
                const geminiDecision = document.getElementById('gemini-decision');
                const groqDecision = document.getElementById('groq-decision');
                const mistralDecision = document.getElementById('mistral-decision');
                
                const decisions = {
                    gemini: geminiDecision ? geminiDecision.textContent : null,
                    groq: groqDecision ? groqDecision.textContent : null,
                    mistral: mistralDecision ? mistralDecision.textContent : null
                };
                
                // Check for consensus
                const aiConsensus = checkLLMConsensus(decisions);
                
                // NEW LOGIC - Check for severe portfolio imbalance first
                const severeImbalanceThreshold = 10; // 10% threshold for severe imbalance
                
                if (totalValue > 0) {
                    if (currentEthAllocation < targetEthMin - severeImbalanceThreshold) {
                        // Severe imbalance - too little ETH regardless of consensus
                        recommendedAction = 'BUY';
                        const targetEthValue = (totalValue * targetEthMin / 100);
                        swapAmount = targetEthValue - ethValueUSD;
                        swapDirection = 'USDC → ETH';
                    } else if (currentEthAllocation > targetEthMax + severeImbalanceThreshold) {
                        // Severe imbalance - too much ETH regardless of consensus
                        recommendedAction = 'SELL';
                        const targetEthValue = (totalValue * targetEthMax / 100);
                        swapAmount = ethValueUSD - targetEthValue;
                        swapDirection = 'ETH → USDC';
                    } else if (aiConsensus) {
                        // For moderate imbalance, use consensus if available
                        recommendedAction = aiConsensus;
                        
                        // Calculate swap amount based on consensus
                        if (recommendedAction === 'BUY' && currentEthAllocation < targetEthMin) {
                            const targetEthValue = (totalValue * targetEthMin / 100);
                            swapAmount = targetEthValue - ethValueUSD;
                            swapDirection = 'USDC → ETH';
                        } else if (recommendedAction === 'SELL' && currentEthAllocation > targetEthMax) {
                            const targetEthValue = (totalValue * targetEthMax / 100);
                            swapAmount = ethValueUSD - targetEthValue;
                            swapDirection = 'ETH → USDC';
                        }
                    } else {
                        // Fall back to portfolio-based recommendation if no consensus 
                        // and no severe imbalance
                        if (currentEthAllocation < targetEthMin) {
                            recommendedAction = 'BUY';
                            const targetEthValue = (totalValue * targetEthMin / 100);
                            swapAmount = targetEthValue - ethValueUSD;
                            swapDirection = 'USDC → ETH';
                        } else if (currentEthAllocation > targetEthMax) {
                            recommendedAction = 'SELL';
                            const targetEthValue = (totalValue * targetEthMax / 100);
                            swapAmount = ethValueUSD - targetEthValue;
                            swapDirection = 'ETH → USDC';
                        }
                    }
                }
                
                // Get recommending models
                let recommendingModels = [];
                if (decisions.gemini === recommendedAction) recommendingModels.push('Gemini');
                if (decisions.groq === recommendedAction) recommendingModels.push('Groq');
                if (decisions.mistral === recommendedAction) recommendingModels.push('Mistral');
                
                const modelText = recommendingModels.length > 0 
                    ? `<div class="text-xs mt-1 text-gray-300">Recommended by: ${recommendingModels.join(', ')}</div>` 
                    : '';
                
                // Modify the portfolio allocation bar display for zero balances
                const portfolioAllocationBar = hasNonZeroBalance 
                    ? `<div class="w-full bg-gray-700 rounded-full h-2.5 mt-1 relative">
                        <div class="${getPortfolioBarColor(currentEthAllocation, targetEthMin, targetEthMax)} h-2.5 rounded-full" style="width: ${currentEthAllocation}%"></div>
                        
                        <!-- Target range indicators -->
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMin}%; height: 100%;"></div>
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMax}%; height: 100%;"></div>
                      </div>
                      <div class="flex justify-between text-xs mt-1">
                        <span>ETH: ${currentEthAllocation.toFixed(1)}%</span>
                        <span>USDC: ${currentUsdcAllocation.toFixed(1)}%</span>
                      </div>`
                    : `<div class="w-full bg-gray-700 rounded-full h-2.5 mt-1 relative">
                        <div class="bg-gray-600 h-2.5 rounded-full" style="width: 0%"></div>
                        
                        <!-- Target range indicators -->
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMin}%; height: 100%;"></div>
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMax}%; height: 100%;"></div>
                      </div>
                      <div class="flex justify-center text-xs mt-1">
                        <span class="text-gray-400">(Empty Portfolio)</span>
                      </div>`;
                
                // Recommendation section based on whether we have balances and AI decisions
                const recommendationSection = `
                    <div class="col-span-2 mt-3 mb-1 space-y-2">
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Recommended Action:</span>
                            <span class="font-bold ${
                                recommendedAction === 'BUY' ? 'text-green-400' :
                                recommendedAction === 'SELL' ? 'text-red-400' :
                                'text-blue-400'
                            }">${recommendedAction}</span>
                        </div>
                        ${recommendingModels.length > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Recommended by:</span>
                            <span class="text-gray-300">${recommendingModels.join(', ')}</span>
                        </div>
                        ` : ''}
                        ${swapAmount > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Suggested Swap:</span>
                            <span class="text-gray-300">~$${swapAmount.toFixed(2)} ${swapDirection}</span>
                        </div>
                        ` : ''}
                        ${totalValue > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Target Allocation:</span>
                            <span class="text-gray-300">${targetEthMin}%-${targetEthMax}% ETH in ${isBullish ? 'bullish' : 'bearish'} market</span>
                        </div>
                        ` : ''}
                        ${(currentEthAllocation < targetEthMin - severeImbalanceThreshold || currentEthAllocation > targetEthMax + severeImbalanceThreshold) && totalValue > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Warning:</span>
                            <span class="text-yellow-400">Portfolio significantly ${currentEthAllocation < targetEthMin ? 'below' : 'above'} target range</span>
                        </div>
                        ` : ''}
                    </div>
                `;
                
                walletCard.innerHTML = `
                    <div class="p-4">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 ${isLinea ? 'border-blue-400' : isEthereum ? 'border-indigo-400' : 'border-yellow-400'} hover:shadow-glow transition-all duration-300">
                                ${isLinea ? `
                                    <div class="network-icon-container mr-2 relative overflow-hidden">
                                        <svg class="w-5 h-5 text-blue-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(0,171,255,0.1)"/>
                                            <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="currentColor"/>
                                            <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="currentColor"/>
                                            <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="currentColor"/>
                                        </svg>
                                        <div class="absolute inset-0 bg-gradient-to-r from-transparent via-blue-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                    </div>
                                ` : isEthereum ? `
                                    <div class="network-icon-container mr-2 relative overflow-hidden">
                                        <svg class="w-5 h-5 text-indigo-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(98,126,234,0.1)"/>
                                            <path d="M11.9982 4L11.8 4.4V15.1133L11.9982 15.275L16.9963 12.3L11.9982 4Z" fill="currentColor" fill-opacity="0.7"/>
                                            <path d="M12 4L7 12.3L12 15.275V10.0582V4Z" fill="currentColor"/>
                                            <path d="M11.9982 16.4826L11.9063 16.597V19.8105L11.9982 20L17 13.4264L11.9982 16.4826Z" fill="currentColor" fill-opacity="0.7"/>
                                            <path d="M12 20V16.4826L7 13.4264L12 20Z" fill="currentColor"/>
                                        </svg>
                                        <div class="absolute inset-0 bg-gradient-to-r from-transparent via-indigo-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                    </div>
                                ` : `
                                    <div class="network-icon-container mr-2 relative overflow-hidden">
                                        <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                        </svg>
                                    </div>
                                `}
                                <div class="flex flex-col">
                                    <div class="text-xs ${isLinea ? 'text-blue-400' : isEthereum ? 'text-indigo-400' : 'text-yellow-400'} font-medium network-name">${networkName}</div>
                                    <div class="flex items-center">
                                        <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                        <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>
                                <div class="text-gray-400">ETH Balance:</div>
                                <div class="font-bold text-cyber-text">${ethValue.toFixed(4)} ETH</div>
                                <div class="text-xs text-gray-400">$${(ethValue * ethPrice).toFixed(2)}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">USDC Balance:</div>
                                <div class="font-bold text-cyber-text">${usdcValue.toFixed(2)} USDC</div>
                                <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                            </div>
                            
                            <div class="col-span-2 mt-2">
                                <div class="text-gray-400">Portfolio Allocation:</div>
                                ${portfolioAllocationBar}
                            </div>
                            
                            ${switchNetworkButtons}
                            
                            ${recommendationSection}
                        </div>
                    </div>
                `;
            }).catch(err => {
                console.warn("Error getting chain ID:", err.message);
                
                // Fallback wallet card with error state
                walletCard.innerHTML = `
                    <div class="p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            ${userAccount ? `
                            <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 border-yellow-400 hover:shadow-glow transition-all duration-300">
                                <div class="network-icon-container mr-2 relative overflow-hidden">
                                    <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                    </svg>
                                </div>
                                <div class="flex flex-col">
                                    <div class="text-xs text-yellow-400 font-medium">Connection Issue</div>
                                    <div class="flex items-center">
                                        <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                        <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        <div class="flex flex-col items-center justify-center h-24">
                            <p class="text-red-400 mb-2">Error loading wallet data</p>
                            <p class="text-xs text-gray-400 mb-2">Network error: ${err.message}</p>
                            <button onclick="getWalletBalances()" class="cyber-btn mt-2 text-xs px-3 py-1">
                                <i class="fas fa-sync-alt mr-1"></i> Retry
                            </button>
                        </div>
                    </div>
                `;
            });
        }
        
        // Function to switch networks
        async function switchNetwork(chainId) {
            if (!window.ethereum || !window.userAccount) {
                showNotification('MetaMask not connected', 'error');
                return;
            }
            
            try {
                // Show loading state first before attempting switch
                showLoadingWalletState("Switching network - please confirm in MetaMask");
                
                // First, try to switch to the network
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x' + chainId.toString(16) }],
                });
                
                // Success notification is unnecessary - users can see the network changed in the UI
                
                // Reset wallet balances to avoid stale data
                resetWalletBalances();
                
                // Wait a bit longer for MetaMask to complete the network switch
                setTimeout(async () => {
                    try {
                        // Show loading state for wallet data retrieval
                        showLoadingWalletState("Loading wallet data for new network");
                        
                        await getWalletBalances();
                        
                        // Also update model performance and LLM decision cards
                        fetchWalletStats();
                        const tradingData = await fetch('/api/trading-data').then(res => res.json());
                        updateModelDecisions(tradingData, window.userAccount);
                        
                        // Don't show notification for zero balances, just update the UI
                        if (walletBalances.totalValueUSD <= 0) {
                            updateWalletCard(); // Ensure card updates even with zero balances
                        }
                    } catch (error) {
                        logToServer('error', 'Error refreshing wallet balances after network switch', error);
                        showNotification("Error loading balances", "error");
                    }
                }, 2000); // Increased timeout to 2 seconds
                
            } catch (switchError) {
                // This error code indicates that the chain has not been added to MetaMask
                if (switchError.code === 4902) {
                    try {
                        // Show loading state for adding network
                        showLoadingWalletState("Adding network to MetaMask");
                        
                        if (chainId === 59144) {
                            // Add Linea network
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xE708',
                                    chainName: 'Linea Mainnet',
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://rpc.linea.build'],
                                    blockExplorerUrls: ['https://lineascan.build']
                                }]
                            });
                        } else if (chainId === 1) {
                            // Add Ethereum Mainnet (this is unlikely to be needed as it's usually pre-configured)
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x1',
                                    chainName: 'Ethereum Mainnet',
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://mainnet.infura.io/v3/'],
                                    blockExplorerUrls: ['https://etherscan.io']
                                }]
                            });
                        }
                        showNotification(`Added ${chainId === 59144 ? 'Linea' : 'Ethereum'} network to MetaMask`, 'success');
                        
                        // After adding the network, update model performance and LLM decision cards
                        setTimeout(async () => {
                            // Show loading state for wallet data
                            showLoadingWalletState("Loading wallet data on new network");
                            
                            fetchWalletStats();
                            const tradingData = await fetch('/api/trading-data').then(res => res.json());
                            updateModelDecisions(tradingData, userAccount);
                        }, 1000);
                    } catch (addError) {
                        logToServer('error', 'Error adding network to MetaMask', addError);
                        showNotification('Error adding network to MetaMask', 'error');
                        
                        // Restore normal wallet card state
                        updateWalletCard();
                    }
                } else {
                    logToServer('error', 'Error switching network', switchError);
                    showNotification('Error switching network. Check MetaMask.', 'error');
                    
                    // Restore normal wallet card state
                    updateWalletCard();
                }
            }
        }
        
        // Helper function to show loading state in wallet card
        function showLoadingWalletState(message) {
            const walletCard = document.getElementById('wallet-card');
            if (walletCard) {
                walletCard.innerHTML = `
                    <div class="p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            ${userAccount ? `
                            <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 border-blue-400 hover:shadow-glow transition-all duration-300">
                                <div class="network-icon-container mr-2 relative overflow-hidden">
                                    <svg class="w-5 h-5 text-blue-400 animate-pulse-slow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-blue-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                </div>
                                <div class="flex flex-col">
                                    <div class="text-xs text-blue-400 font-medium">Processing</div>
                                    <div class="flex items-center">
                                        <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                        <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        <div class="flex flex-col items-center justify-center h-24">
                            <p class="text-gray-400 mb-2">${message}</p>
                            <div class="spinner"><i class="fas fa-sync-alt fa-spin"></i></div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Update model stats to only show relevant operations when wallet is connected
        function updateModelStatsForWallet() {
            if (!userAccount) {
                // No wallet connected, keep using all trades
                return;
            }
            
            try {
                // Strictly validate ETH price before attempting any calculations
                if (!walletBalances.ethusd || isNaN(walletBalances.ethusd) || walletBalances.ethusd <= 0) {
                    console.log("No valid ETH price available - skipping model stats update");
                    return;
                }
                
                // Get current ETH price and portfolio values
                const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                const totalValue = walletBalances.totalValueUSD || ethValueUSD; // Fallback if totalValueUSD is 0
                
                // Skip wallet action update if we have no value
                if (totalValue <= 0) {
                    console.log("Wallet has no value, skipping wallet action update");
                    return;
                }
                
                // Get decisions from AI models - use the model's recommended action instead of portfolio-based one
                const geminiDecision = document.getElementById('gemini-decision');
                const groqDecision = document.getElementById('groq-decision');
                const mistralDecision = document.getElementById('mistral-decision');
                
                const decisions = {
                    gemini: geminiDecision ? geminiDecision.textContent : null,
                    groq: groqDecision ? groqDecision.textContent : null,
                    mistral: mistralDecision ? mistralDecision.textContent : null
                };
                
                // Check for consensus (2 out of 3 models agree)
                let walletAction = checkLLMConsensus(decisions);
                
                // If no consensus, calculate based on portfolio
                if (!walletAction) {
                    // Target allocation range: 60-80% ETH in bullish, 20-40% in bearish
                    const marketSentiment = document.getElementById('sentiment');
                    const isBullish = marketSentiment && marketSentiment.textContent.includes('bullish');
                    
                    const targetEthMin = isBullish ? 60 : 20;
                    const targetEthMax = isBullish ? 80 : 40;
                    
                    // Safely calculate ETH allocation with zero checking
                    const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                    
                    // Default to HOLD
                    walletAction = 'HOLD';
                    
                    // Only make BUY/SELL recommendations if we have some value
                    if (totalValue > 0) {
                        if (currentEthAllocation < targetEthMin) {
                            walletAction = 'BUY';
                        } else if (currentEthAllocation > targetEthMax) {
                            walletAction = 'SELL';
                        }
                    }
                }
                
                // Get current chain ID to send with the API
                window.web3.eth.getChainId().then(chainId => {
                    // Only send wallet action for supported networks
                    if (chainId !== 1 && chainId !== 59144) {
                        console.log(`Skipping wallet action on unsupported network ${chainId}`);
                        return;
                    }
                    
                    // Safely calculate ETH allocation again for the API call
                    const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                    const totalValue = walletBalances.totalValueUSD || ethValueUSD;
                    const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                    
                    // Update the API to indicate the wallet action
                    fetch('/api/set-wallet-action', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            wallet_address: window.userAccount,
                            wallet_action: walletAction,
                            eth_balance: walletBalances.eth,
                            usdc_balance: walletBalances.usdc,
                            eth_allocation: currentEthAllocation,
                            network: chainId === 59144 ? 'linea' : 'ethereum'
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.warn(`API error: ${response.status}. This is non-critical.`);
                            return null;
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data) {
                            console.log("Wallet action updated:", data);
                        }
                    })
                    .catch(error => {
                        logToServer('warn', 'Error setting wallet action (non-critical)', error);
                        // Don't show notification to avoid spamming the user
                    });
                }).catch(error => {
                    console.warn('Error getting chain ID:', error.message);
                });
            } catch (error) {
                console.warn('Error in updateModelStatsForWallet:', error.message);
            }
        }

        // showNotification function has been moved to utils.js

        // Function to get models that recommend BUY - moved to modelPredictions.js
        
        // Function to get models that recommend SELL - moved to modelPredictions.js

        // checkLLMConsensus function - moved to modelPredictions.js and marketAnalysis.js

        // Add raw accuracy tracking
        let aiRawAccuracy = JSON.parse(localStorage.getItem('stbchef_raw_accuracy') || JSON.stringify({
                        gemini: { correct: 0, total: 0, accuracy: 0 },
                        groq: { correct: 0, total: 0, accuracy: 0 },
                        mistral: { correct: 0, total: 0, accuracy: 0 }
        }));
        
        // Make aiRawAccuracy available globally
        window.aiRawAccuracy = aiRawAccuracy;

        // Make updateAccuracy available globally - now from modelPredictions.js
        
        // copyToClipboard function has been moved to utils.js

        // calculateAccuracy function moved to modelPredictions.js
        
        // updateAccuracy function moved to modelPredictions.js

        // initCharts function has been moved to chartHandlers.js and is available globally via window.initCharts
        
        // updateCharts function has been moved to chartHandlers.js and is available globally via window.updateCharts

        // updateModelStats function has been moved to statsManager.js
        
        // updateModelStatsDisplay function has been moved to statsManager.js
        
        // displayEmptyStats function has been moved to statsManager.js
        
        // fetchWalletStats function has been moved to statsManager.js

        // updateWalletModelStats function has been moved to statsManager.js
        
        // updateTimeframe function has been moved to statsManager.js
        
        // getRecentTrades function has been moved to statsManager.js
        
        // checkDailyReset function has been moved to statsManager.js

        // sendWalletNotification function has been moved to notificationManager.js

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing dashboard...');
            checkFreshSession(); // Check if storage needs clearing
            
            // Initialize UI with empty state first for model stats
            displayEmptyStats();
            
            // Initialize charts before any data loading
            window.initCharts();
            
            // Check for daily reset
            checkDailyReset(); 
            
            // First, load global market data (this is not wallet-dependent)
            updateData();
            
            // Set up auto-refresh every 10 minutes
            const refreshInterval = setInterval(() => {
                console.log('Auto-refresh triggered');
                updateData();
            }, 600000);  // 10 minutes

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                clearInterval(refreshInterval);
                
                // Make sure wallet connection is saved before page unloads
                if (userAccount) {
                    // Force a synchronous localStorage save before page unload
                    localStorage.setItem(STORAGE_KEYS.WALLET, userAccount);
                    
                    // Also save any pending wallet stats or model decisions
                    try {
                        localStorage.setItem(STORAGE_KEYS.TRADE_HISTORY, JSON.stringify(tradeHistory));
                        localStorage.setItem(STORAGE_KEYS.MODEL_PERFORMANCE, JSON.stringify(aiAccuracy));
                        localStorage.setItem('stbchef_raw_accuracy', JSON.stringify(aiRawAccuracy));
                        localStorage.setItem(STORAGE_KEYS.LAST_UPDATE, Date.now().toString());
                    } catch (e) {
                        // Ignore error in case localStorage is full
                        console.error('Error saving data on unload:', e);
                    }
                }
            });
        });
    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <!-- Header -->
    <header class="cyber-header p-4">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center">
                <img src="static/robot.webp" alt="Trading Bot Chef Logo" class="header-logo">
                <h1 class="cyber-title text-2xl">Simple Crypto Trading Bot Chef</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="wallet-btn" onclick="connectWallet()" class="wallet-btn px-4 py-2 rounded">
                    Connect Wallet
                </button>
                <a href="https://github.com/Qbandev/stbchef" target="_blank" class="cyber-btn px-4 py-2 rounded flex items-center">
                    <i class="fab fa-github mr-2"></i>
                    GitHub
                </a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4 mt-4">
        <div class="grid grid-cols-1 gap-6">
            <!-- ETH/USDC Live Price Card (Full Width) -->
            <div class="cyber-card p-6 rounded-lg shadow mb-6">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
                    <h2 class="text-xl font-semibold cyber-title">ETH/USDC <span class="text-sm text-gray-400">Live Price</span></h2>
                    <div class="flex items-center space-x-4 mt-2 md:mt-0">
                        <div>
                            <span class="text-gray-400 text-sm">Current Price:</span>
                            <span id="eth-price" class="text-2xl font-bold ml-2 cyber-value animate-pulse">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400 text-sm">24h Vol:</span>
                            <span id="eth-volume" class="text-sm font-bold ml-2 cyber-value">-</span>
                        </div>
                    </div>
                </div>
                <!-- ETH Price Chart (Integrated) -->
                <div class="h-64 relative" id="price-chart-container">
                    <canvas id="price-chart"></canvas>
                </div>
                <!-- Price & Gas Info -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                    <!-- Price Data -->
                    <div class="flex justify-between items-center">
                        <div>
                            <span class="text-gray-400">24h High:</span>
                            <span id="eth-high" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">24h Low:</span>
                            <span id="eth-low" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">Sentiment:</span>
                            <span id="sentiment" class="ml-1 px-2 py-0.5 rounded-full text-xs font-semibold bg-gray-700 text-gray-300">-</span>
                        </div>
                    </div>
                    <!-- Gas Prices (Linea) -->
                    <div class="flex justify-between items-center">
                        <div></div> <!-- Empty div to push content to right -->
                        <div class="flex items-center space-x-4">
                            <span class="text-gray-400">Gas Prices:</span>
                            <div class="flex space-x-4">
                                <div class="text-center">
                                    <span class="text-green-400 text-sm mr-1">Low:</span>
                                    <span id="gas-low" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-yellow-400 text-sm mr-1">Medium:</span>
                                    <span id="gas-standard" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-red-400 text-sm mr-1">High:</span>
                                    <span id="gas-fast" class="text-sm font-bold cyber-value">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Wallet Status Card (Full Width) -->
            <div id="wallet-card" class="cyber-card rounded-lg shadow p-6 mb-6">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                </div>
                <div class="flex items-center justify-center h-24">
                    <div class="text-center">
                        <p class="text-gray-400 mb-2">Connect your wallet to see balances</p>
                    </div>
                </div>
            </div>
            
            <!-- AI Model Recommendations -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Gemini AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Gemini AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="gemini-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Gemini 1.5 Flash</div>
                    </div>
                </div>

                <!-- Groq AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Groq AI</h2>
                        <svg class="w-6 h-6 text-neon-purple" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="groq-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by DeepSeek-R1-Distill-Llama-70B</div>
                    </div>
                </div>

                <!-- Mistral AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Mistral AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10l3.5 3.5m0-6.5L13 10m6 0l-3.5 3.5M7 10l-3.5 3.5m0-6.5L7 10m-6 0l3.5 3.5" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="mistral-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Mistral Large</div>
                    </div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">Model Performance</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Gemini Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-blue">Gemini AI</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="gemini-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="gemini-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-blue">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="gemini-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Groq Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-purple">Groq DeepSeek</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="groq-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="groq-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-purple">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="groq-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Mistral Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-green">Mistral AI</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="mistral-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="mistral-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-green">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="mistral-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>
</body>
</html> 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Crypto Trading Bot Chef</title>
    <link rel="icon" type="image/webp" href="static/favicon.webp">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-purple: #9d00ff;
            --neon-pink: #ff0099;
            --cyber-black: #0a0a0f;
            --cyber-dark: #1a1a2e;
            --cyber-text: #e2e8f0;
        }
        body {
            background: var(--cyber-black);
            color: var(--cyber-text);
            font-family: 'Courier New', monospace;
            background-image: 
                linear-gradient(45deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(-45deg, rgba(157, 0, 255, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: center;
        }
        .cyber-card {
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
        }
        .cyber-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            animation: scan-line 2s linear infinite;
        }
        @keyframes scan-line {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .cyber-title {
            color: var(--neon-blue);
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.7);
            position: relative;
        }
        .cyber-value {
            color: var(--neon-purple);
            text-shadow: 0 0 10px rgba(157, 0, 255, 0.7);
            position: relative;
        }
        .cyber-btn {
            background: transparent;
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.7);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .cyber-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            background: rgba(0, 243, 255, 0.2);
            transform: translate(-50%, -50%) rotate(45deg);
            transition: all 0.3s ease;
            opacity: 0;
        }
        .cyber-btn:hover::before {
            opacity: 1;
        }
        .cyber-btn:hover {
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
            transform: translateY(-2px);
        }
        .chart-container {
            border: 1px solid var(--neon-blue);
            background: rgba(26, 26, 46, 0.8);
            height: 400px;
            box-shadow: inset 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        .header-logo {
            max-width: 60px;
            height: auto;
            filter: drop-shadow(0 0 15px rgba(0, 243, 255, 0.7));
            animation: pulse 2s ease-in-out infinite;
            margin-right: 1rem;
        }
        @keyframes pulse {
            0% { filter: drop-shadow(0 0 15px rgba(0, 243, 255, 0.7)); }
            50% { filter: drop-shadow(0 0 25px rgba(157, 0, 255, 0.7)); }
            100% { filter: drop-shadow(0 0 15px rgba(0, 243, 255, 0.7)); }
        }
        .cyber-header {
            background: rgba(26, 26, 46, 0.8);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        .cyber-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            animation: scan-line 2s linear infinite;
        }
        @media (max-width: 768px) {
            .header-logo {
                max-width: 60px;
            }
            .chart-container {
                height: 300px;
            }
            .grid-cols-3 {
                grid-template-columns: 1fr;
            }
        }
        .wallet-btn {
            background: linear-gradient(45deg, var(--neon-purple), var(--neon-pink));
            border: 1px solid var(--neon-purple);
            color: white;
            text-shadow: 0 0 5px rgba(157, 0, 255, 0.7);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .wallet-btn:hover {
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
            box-shadow: 0 0 20px rgba(157, 0, 255, 0.5);
            transform: translateY(-2px);
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem;
            border-radius: 0.5rem;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid var(--neon-purple);
            color: white;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 0 20px rgba(157, 0, 255, 0.3);
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        /* Custom Tooltip Styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        .tooltip {
            visibility: hidden;
            position: fixed;
            z-index: 9999;
            padding: 8px 12px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid var(--neon-blue);
            border-radius: 4px;
            color: var(--cyber-text);
            font-size: 0.875rem;
            white-space: pre-line;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
            min-width: 200px;
            backdrop-filter: blur(5px);
            transform: translateX(-50%) translateY(-100%);
            margin-top: -10px;
        }
        .tooltip::after {
            content: "";
            position: absolute;
            bottom: -5px;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent var(--neon-blue) transparent;
        }
        .tooltip-container:hover .tooltip,
        .tooltip-container:focus-within .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-trigger {
            cursor: help;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script>
        // Storage keys for persistence
        const STORAGE_KEYS = {
            WALLET: 'stbchef_wallet',
            HISTORY: 'stbchef_history',
            LAST_UPDATE: 'stbchef_last_update',
            PRICE_DATA: 'stbchef_price_data',
            VOLUME_DATA: 'stbchef_volume_data',
            TIME_LABELS: 'stbchef_time_labels',
            TRADE_HISTORY: 'stbchef_trade_history',
            MODEL_PERFORMANCE: 'stbchef_model_performance'
        };

        // Initialize variables
        let web3;
        let userAccount;
        let priceChart;
        let performanceChart;
        let priceHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.PRICE_DATA) || '[]');
        let timeLabels = JSON.parse(localStorage.getItem(STORAGE_KEYS.TIME_LABELS) || '[]');
        let volumeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.VOLUME_DATA) || '[]');
        const tradingActions = [];

        // Initialize trade history for each model
        let tradeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.TRADE_HISTORY) || JSON.stringify({
            gemini: [],
            groq: [],
            mistral: []
        }));

        // Add accuracy tracking variables
        let aiAccuracy = JSON.parse(localStorage.getItem(STORAGE_KEYS.MODEL_PERFORMANCE) || JSON.stringify({
            gemini: { correct: 0, total: 0 },
            groq: { correct: 0, total: 0 },
            mistral: { correct: 0, total: 0 }
        }));

        // Add market volatility tracking
        let marketVolatility = {
            window: 24, // 24-hour window
            data: [],
            current: 0
        };

        function calculateVolatility(price) {
            marketVolatility.data.push(price);
            if (marketVolatility.data.length > marketVolatility.window * 60) { // 60 data points per hour
                marketVolatility.data.shift();
            }

            if (marketVolatility.data.length > 1) {
                const returns = marketVolatility.data.slice(1).map((p, i) => 
                    (p - marketVolatility.data[i]) / marketVolatility.data[i]
                );
                marketVolatility.current = Math.sqrt(returns.reduce((sum, r) => sum + r * r, 0) / returns.length) * 100;
            }
        }

        function calculateDynamicThreshold() {
            // Base threshold of 1%, adjusted by volatility
            const baseThreshold = 1.0;
            const volatilityFactor = Math.max(0.5, Math.min(2.0, marketVolatility.current));
            return baseThreshold * volatilityFactor;
        }

        function calculateTradeScore(decision, priceChangePercent, threshold) {
            let score = 0;

            // Base score for correct direction
            if (decision === 'BUY' && priceChangePercent > threshold) {
                score = 1;
            } else if (decision === 'SELL' && priceChangePercent < -threshold) {
                score = 1;
            } else if (decision === 'HOLD' && Math.abs(priceChangePercent) <= threshold) {
                score = 1;
            }

            // Bonus points for magnitude
            if (score > 0) {
                const magnitude = Math.abs(priceChangePercent) - threshold;
                score += Math.min(1, magnitude / threshold); // Up to 1 additional point
            }

            return score;
        }

        let lastDecisions = {
            gemini: null,
            groq: null,
            mistral: null,
            price: null
        };

        // Load persisted wallet connection on page load
        window.addEventListener('load', async () => {
            const persistedWallet = localStorage.getItem(STORAGE_KEYS.WALLET);
            if (persistedWallet && typeof window.ethereum !== 'undefined') {
                try {
                    web3 = new Web3(window.ethereum);
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts[0] && accounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                        userAccount = accounts[0];
                        updateWalletUI();
                    }
                } catch (error) {
                    console.error('Error restoring wallet connection:', error);
                }
            }
            clearExpiredData();
        });

        // Persist wallet connection
        function persistWalletConnection(account) {
            if (account) {
                localStorage.setItem(STORAGE_KEYS.WALLET, account);
            } else {
                localStorage.removeItem(STORAGE_KEYS.WALLET);
            }
        }

        // Update wallet UI
        function updateWalletUI() {
            const walletBtn = document.getElementById('wallet-btn');
            if (userAccount) {
                walletBtn.innerHTML = `${userAccount.substring(0, 6)}...${userAccount.substring(38)}`;
                walletBtn.classList.add('connected');
            } else {
                walletBtn.innerHTML = 'Connect Wallet';
                walletBtn.classList.remove('connected');
            }
        }

        // Load persisted trading history
        function loadPersistedHistory() {
            try {
                const history = localStorage.getItem(STORAGE_KEYS.TRADE_HISTORY);
                const performance = localStorage.getItem(STORAGE_KEYS.MODEL_PERFORMANCE);

                if (history) {
                    tradeHistory = JSON.parse(history);
                }
                if (performance) {
                    aiAccuracy = JSON.parse(performance);
                }

                // Update UI with loaded data
                updateModelStatsDisplay();
            } catch (error) {
                console.error('Error loading persisted history:', error);
            }
        }

        // Persist trading history
        function persistTradingHistory() {
            try {
                localStorage.setItem(STORAGE_KEYS.TRADE_HISTORY, JSON.stringify(tradeHistory));
                localStorage.setItem(STORAGE_KEYS.MODEL_PERFORMANCE, JSON.stringify(aiAccuracy));
                localStorage.setItem(STORAGE_KEYS.LAST_UPDATE, Date.now().toString());
            } catch (error) {
                console.error('Error persisting history:', error);
            }
        }

        // Clear expired data
        function clearExpiredData() {
            const lastUpdate = parseInt(localStorage.getItem(STORAGE_KEYS.LAST_UPDATE) || '0');
            if (Date.now() - lastUpdate > 24 * 60 * 60 * 1000) {
                localStorage.removeItem(STORAGE_KEYS.TRADE_HISTORY);
                localStorage.removeItem(STORAGE_KEYS.MODEL_PERFORMANCE);
                localStorage.removeItem(STORAGE_KEYS.LAST_UPDATE);
                localStorage.removeItem(STORAGE_KEYS.PRICE_DATA);
                localStorage.removeItem(STORAGE_KEYS.VOLUME_DATA);
                localStorage.removeItem(STORAGE_KEYS.TIME_LABELS);
            }
        }

        // Modified wallet connection function
        async function connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    userAccount = accounts[0];
                    web3 = new Web3(window.ethereum);

                    persistWalletConnection(userAccount);
                    updateWalletUI();
                    showNotification('Wallet connected successfully!', 'success');

                    // Request notification permission after wallet connection
                    await requestNotificationPermission();

                    window.ethereum.on('accountsChanged', function (accounts) {
                        if (accounts.length === 0) {
                            userAccount = null;
                            persistWalletConnection(null);
                        } else {
                            userAccount = accounts[0];
                            persistWalletConnection(userAccount);
                            requestNotificationPermission(); // Request permission for new account
                        }
                        updateWalletUI();
                        showNotification(accounts.length === 0 ? 'Wallet disconnected' : 'Wallet account changed', accounts.length === 0 ? 'warning' : 'info');
                    });
                } catch (error) {
                    console.error('User denied account access:', error);
                    showNotification('Failed to connect wallet', 'error');
                }
            } else {
                showNotification('Please install MetaMask!', 'error');
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;

            // Format message with line breaks
            const formattedMessage = message.split('\n').map(line => `<div>${line}</div>`).join('');

            notification.innerHTML = `
                <div class="flex flex-col">
                    ${formattedMessage}
                </div>
            `;

            document.body.appendChild(notification);

            // Remove notification after 8 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 8000);
        }

        // Function to check if 2 out of 3 LLMs agree on a decision
        function checkLLMConsensus(decisions) {
            const buyVotes = Object.values(decisions).filter(d => d === 'BUY').length;
            const sellVotes = Object.values(decisions).filter(d => d === 'SELL').length;

            if (buyVotes >= 2) {
                return 'BUY';
            } else if (sellVotes >= 2) {
                return 'SELL';
            }
            return null;
        }

        function getModelDecisions(decisions) {
            const modelDecisions = [];
            if (decisions.gemini === 'BUY') modelDecisions.push('Gemini');
            if (decisions.groq === 'BUY') modelDecisions.push('Groq');
            if (decisions.mistral === 'BUY') modelDecisions.push('Mistral');
            return modelDecisions;
        }

        function getModelSellDecisions(decisions) {
            const modelDecisions = [];
            if (decisions.gemini === 'SELL') modelDecisions.push('Gemini');
            if (decisions.groq === 'SELL') modelDecisions.push('Groq');
            if (decisions.mistral === 'SELL') modelDecisions.push('Mistral');
            return modelDecisions;
        }

        function calculateAccuracy(model) {
            const trades = tradeHistory[model];
            if (trades.length === 0) return 0;

            const correctTrades = trades.filter(trade => trade.profitable).length;
            return ((correctTrades / trades.length) * 100).toFixed(1);
        }

        function updateAccuracy(currentPrice) {
            if (lastDecisions.price !== null) {
                const priceChange = currentPrice - lastDecisions.price;
                const priceChangePercent = (priceChange / lastDecisions.price) * 100;

                // Update market volatility
                calculateVolatility(currentPrice);

                // Get dynamic threshold based on market conditions
                const threshold = calculateDynamicThreshold();

                // Update accuracy for each model
                ['gemini', 'groq', 'mistral'].forEach(model => {
                    if (lastDecisions[model]) {
                        const decision = lastDecisions[model];
                        const score = calculateTradeScore(decision, priceChangePercent, threshold);

                        // Record trade with enhanced metrics
                        tradeHistory[model].push({
                            timestamp: new Date(),
                            decision: decision,
                            priceChange: priceChangePercent,
                            score: score,
                            threshold: threshold,
                            volatility: marketVolatility.current,
                            price: currentPrice
                        });

                        // Keep only last 100 trades for more recent performance focus
                        if (tradeHistory[model].length > 100) {
                            tradeHistory[model].shift();
                        }
                    }
                });
            }

            // Update accuracy display with weighted metrics
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                if (accuracyElement) {
                    const trades = tradeHistory[model];
                    if (trades.length > 0) {
                        // Calculate weighted average score
                        const recentTrades = trades.slice(-20); // Last 20 trades
                        const weights = recentTrades.map((_, i) => 1 + (i / recentTrades.length));
                        const totalWeight = weights.reduce((sum, w) => sum + w, 0);

                        const weightedScore = recentTrades.reduce((sum, trade, i) => 
                            sum + (trade.score * weights[i]), 0) / totalWeight;

                        const accuracy = (weightedScore * 100).toFixed(1);
                        accuracyElement.textContent = `${accuracy}%`;
                        accuracyElement.className = `font-bold ${
                            parseFloat(accuracy) >= 65 ? 'text-green-400' :
                            parseFloat(accuracy) >= 45 ? 'text-yellow-400' :
                            'text-red-400'
                        }`;
                    } else {
                        // No trades yet, show 0%
                        accuracyElement.textContent = '0.0%';
                        accuracyElement.className = 'font-bold text-gray-400';
                    }
                }
            });
        }

        function initCharts() {
            Chart.defaults.color = '#e2e8f0';
            Chart.defaults.borderColor = 'rgba(0, 243, 255, 0.1)';

            // Price Chart
            const priceCtx = document.getElementById('price-chart').getContext('2d');
            priceChart = new Chart(priceCtx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'ETH Price (USD)',
                            data: priceHistory,
                            borderColor: '#00f3ff',
                            borderWidth: 2,
                            tension: 0.1,
                            yAxisID: 'y',
                            order: 1
                        },
                        {
                            label: 'Volume',
                            data: volumeHistory,
                            backgroundColor: 'rgba(157, 0, 255, 0.2)',
                            borderColor: 'rgba(157, 0, 255, 0.2)',
                            type: 'bar',
                            yAxisID: 'volume',
                            order: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e2e8f0'
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'x',
                            },
                            pan: {
                                enabled: true,
                                mode: 'x',
                            }
                        },
                        annotation: {
                            annotations: {}
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: {
                                color: 'rgba(0, 243, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e2e8f0'
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: '#e2e8f0'
                            }
                        },
                        volume: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false,
                                color: 'rgba(157, 0, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e2e8f0'
                            },
                            title: {
                                display: true,
                                text: 'Volume',
                                color: '#e2e8f0'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updateCharts(price, sentiment, geminiAction, groqAction, mistralAction, volume) {
            const now = new Date().toLocaleTimeString();

            // Update accuracy
            updateAccuracy(price);

            // Store current decisions for next accuracy calculation
            lastDecisions = {
                gemini: geminiAction,
                groq: groqAction,
                mistral: mistralAction,
                price: price
            };

            // Keep last 100 data points
            if (timeLabels.length > 100) {
                timeLabels.shift();
                priceHistory.shift();
                volumeHistory.shift();
            }

            timeLabels.push(now);
            priceHistory.push(price);
            volumeHistory.push(volume);

            // Update price chart without model annotations
            priceChart.update();

            // Persist chart data
            try {
                localStorage.setItem(STORAGE_KEYS.PRICE_DATA, JSON.stringify(priceHistory));
                localStorage.setItem(STORAGE_KEYS.VOLUME_DATA, JSON.stringify(volumeHistory));
                localStorage.setItem(STORAGE_KEYS.TIME_LABELS, JSON.stringify(timeLabels));
            } catch (error) {
                console.error('Error persisting chart data:', error);
            }
        }

        function updateModelStats(stats) {
            // Update detailed stats for each model
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const trades = tradeHistory[model];
                const statsContainer = document.getElementById(`${model}-stats`);
                if (statsContainer) {
                    const totalTrades = trades.length;
                    const correctTrades = trades.filter(t => t.profitable).length;
                    const incorrectTrades = totalTrades - correctTrades;

                    // Calculate decision distribution
                    const decisions = {
                        buy: trades.filter(t => t.decision === 'BUY').length,
                        sell: trades.filter(t => t.decision === 'SELL').length,
                        hold: trades.filter(t => t.decision === 'HOLD').length
                    };

                    // Calculate average price change for correct trades
                    const correctTradesAvgChange = correctTrades > 0 
                        ? (trades.filter(t => t.profitable)
                            .reduce((sum, t) => sum + t.priceChange, 0) / correctTrades).toFixed(2)
                        : 0;

                    statsContainer.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>
                                <div class="text-gray-400">Total Trades:</div>
                                <div class="font-bold text-cyber-text">${totalTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Correct Trades:</div>
                                <div class="font-bold text-green-400">${correctTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Incorrect Trades:</div>
                                <div class="font-bold text-red-400">${incorrectTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Avg Profit Trades:</div>
                                <div class="font-bold ${parseFloat(correctTradesAvgChange) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                    ${correctTradesAvgChange}%
                                </div>
                            </div>
                            <div class="col-span-2">
                                <div class="text-gray-400">Decision Distribution:</div>
                                <div class="flex justify-between mt-1">
                                    <span class="text-green-400">Buy: ${decisions.buy}</span>
                                    <span class="text-red-400">Sell: ${decisions.sell}</span>
                                    <span class="text-blue-400">Hold: ${decisions.hold}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
        }

        // Update model stats display
        function updateModelStatsDisplay() {
            // Check if we need to reset daily stats
            checkDailyReset();

            ['gemini', 'groq', 'mistral'].forEach(model => {
                const trades = tradeHistory[model];
                const statsContainer = document.getElementById(`${model}-stats`);
                const accuracyElement = document.getElementById(`${model}-accuracy`);

                if (statsContainer) {
                    const recentTrades = getRecentTrades(trades);
                    const totalRecentTrades = recentTrades.length;
                    const correctRecentTrades = recentTrades.filter(t => t.score >= 1).length;
                    const incorrectRecentTrades = totalRecentTrades - correctRecentTrades;

                    // Calculate last 24h decision distribution
                    const recentDecisions = {
                        buy: recentTrades.filter(t => t.decision === 'BUY').length,
                        sell: recentTrades.filter(t => t.decision === 'SELL').length,
                        hold: recentTrades.filter(t => t.decision === 'HOLD').length
                    };

                    // Calculate 24h average price change for correct trades
                    const correctTradesAvgChange = correctRecentTrades > 0 
                        ? (recentTrades.filter(t => t.score >= 1)
                            .reduce((sum, t) => sum + t.priceChange, 0) / correctRecentTrades).toFixed(2)
                        : 0;

                    statsContainer.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div class="col-span-2 mb-1">
                                <div class="text-xs font-bold text-neon-blue">Last 24 Hours</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Total Trades:</div>
                                <div class="font-bold text-cyber-text">${totalRecentTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Correct Trades:</div>
                                <div class="font-bold text-green-400">${correctRecentTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Incorrect Trades:</div>
                                <div class="font-bold text-red-400">${incorrectRecentTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Avg Profit Trades:</div>
                                <div class="font-bold ${parseFloat(correctTradesAvgChange) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                    ${correctTradesAvgChange}%
                                </div>
                            </div>
                            <div class="col-span-2">
                                <div class="text-gray-400">Decision Distribution:</div>
                                <div class="flex justify-between mt-1">
                                    <span class="text-green-400">Buy: ${recentDecisions.buy}</span>
                                    <span class="text-red-400">Sell: ${recentDecisions.sell}</span>
                                    <span class="text-blue-400">Hold: ${recentDecisions.hold}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }

                if (accuracyElement) {
                    // For performance score: calculate weighted average of scores from last 100 trades
                    if (trades.length > 0) {
                        // Use last 100 trades for performance score
                        const lastHundredTrades = trades.slice(-100);
                        // Calculate weighted average with more weight to recent trades
                        const weights = lastHundredTrades.map((_, i) => 1 + (i / lastHundredTrades.length));
                        const totalWeight = weights.reduce((sum, w) => sum + w, 0);

                        const weightedScore = lastHundredTrades.reduce((sum, trade, i) => 
                            sum + (trade.score * weights[i]), 0) / totalWeight;

                        const accuracy = (weightedScore * 100).toFixed(1);
                        accuracyElement.textContent = `${accuracy}%`;
                        accuracyElement.className = `font-bold ${
                            parseFloat(accuracy) >= 65 ? 'text-green-400' :
                            parseFloat(accuracy) >= 45 ? 'text-yellow-400' :
                            'text-red-400'
                        }`;
                    } else {
                        accuracyElement.textContent = '0.0%';
                        accuracyElement.className = 'font-bold text-gray-400';
                    }
                }
            });
        }

        // Modified updateData function to send wallet notifications
        function updateData() {
            console.log('Fetching new data...');
            fetch('/api/trading-data')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Received data:', data);

                    // Check for LLM consensus and notify if connected
                    if (userAccount) {
                        const decisions = {
                            gemini: data.gemini_action,
                            groq: data.groq_action,
                            mistral: data.mistral_action
                        };

                        const consensus = checkLLMConsensus(decisions);
                        if (consensus) {
                            const buyModels = getModelDecisions(decisions);
                            const sellModels = getModelSellDecisions(decisions);
                            const currentPrice = data.eth_price.toFixed(2);

                            let message = '';
                            if (consensus === 'BUY') {
                                message = `ðŸŸ¢ BUY Signal at $${currentPrice}\n`;
                                message += `Recommended by: ${buyModels.join(', ')}`;
                            } else if (consensus === 'SELL') {
                                message = `ðŸ”´ SELL Signal at $${currentPrice}\n`;
                                message += `Recommended by: ${sellModels.join(', ')}`;
                            }

                            // Show browser notification
                            showNotification(message, 'info');

                            // Send wallet notification
                            sendWalletNotification(message, consensus);
                        }
                    }

                    // Update metrics
                    document.getElementById('eth-price').textContent = `$${data.eth_price.toFixed(2)}`;
                    document.getElementById('eth-volume').textContent = `$${(data.eth_volume_24h/1e6).toFixed(2)}M`;
                    document.getElementById('eth-high').textContent = `$${data.eth_high_24h.toFixed(2)}`;
                    document.getElementById('eth-low').textContent = `$${data.eth_low_24h.toFixed(2)}`;

                    // Update gas price information
                    if (data.gas_prices) {
                        document.getElementById('gas-low').textContent = `${data.gas_prices.low} Gwei`;
                        document.getElementById('gas-standard').textContent = `${data.gas_prices.standard} Gwei`;
                        document.getElementById('gas-fast').textContent = `${data.gas_prices.fast} Gwei`;
                    }

                    // Update model decisions and stats
                    ['gemini', 'groq', 'mistral'].forEach(model => {
                        const action = data[`${model}_action`];
                        const stats = data.model_stats?.comparison?.[model] || { accuracy: 0 };

                        // Update decision
                        const decisionElement = document.getElementById(`${model}-decision`);
                        if (decisionElement) {
                            decisionElement.textContent = action || 'N/A';
                            decisionElement.className = `font-bold text-xl cyber-value ${
                                action === 'BUY' ? 'text-green-400' :
                                action === 'SELL' ? 'text-red-400' :
                                'text-blue-400'
                            } animate-pulse`;
                        }

                        // Update accuracy
                        const accuracyElement = document.getElementById(`${model}-accuracy`);
                        if (accuracyElement) {
                            const accuracy = stats.accuracy || 0;
                            accuracyElement.textContent = `${accuracy.toFixed(1)}%`;
                            accuracyElement.className = `font-bold ${
                                accuracy >= 65 ? 'text-green-400' :
                                accuracy >= 45 ? 'text-yellow-400' :
                                'text-red-400'
                            }`;
                        }
                    });

                    // Update market sentiment
                    const sentimentText = document.getElementById('sentiment');
                    if (sentimentText && data.market_sentiment) {
                        sentimentText.textContent = `${data.market_sentiment.fear_greed_value} (${data.market_sentiment.fear_greed_sentiment})`;
                        const sentimentClass = data.market_sentiment.fear_greed_sentiment === 'bullish'
                            ? 'bg-green-100 text-green-800'
                            : 'bg-red-100 text-red-800';

                        sentimentText.className = `px-2 py-1 rounded-full text-sm font-semibold ${sentimentClass}`;
                    }

                    // Update charts
                    updateCharts(
                        data.eth_price,
                        data.market_sentiment?.fear_greed_value,
                        data.gemini_action,
                        data.groq_action,
                        data.mistral_action,
                        data.eth_volume_24h
                    );

                    // Update detailed model stats
                    if (data.model_stats?.comparison) {
                        updateModelStats(data.model_stats);
                    }

                    // Persist trading history after updates
                    persistTradingHistory();
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.querySelectorAll('.cyber-value').forEach(el => {
                        el.textContent = 'Error';
                        el.classList.add('text-red-500');
                    });
                });
        }

        // Add function to fetch daily stats
        function fetchDailyStats() {
            fetch('/api/daily-stats')
                .then(response => response.json())
                .then(data => {
                    // Log the data
                    console.log('Daily stats:', data);
                    
                    // For each model, update the stats display
                    ['gemini', 'groq', 'mistral'].forEach(model => {
                        if (data[model] && data[model].length > 0) {
                            // Get the most recent day's stats
                            const todayStats = data[model][0];
                            
                            const statsContainer = document.getElementById(`${model}-stats`);
                            if (statsContainer) {
                                statsContainer.innerHTML = `
                                    <div class="grid grid-cols-2 gap-2 text-sm">
                                        <div class="col-span-2 mb-1">
                                            <div class="text-xs font-bold text-neon-blue">Last 24 Hours</div>
                                        </div>
                                        <div>
                                            <div class="text-gray-400">Total Trades:</div>
                                            <div class="font-bold text-cyber-text">${todayStats.total_trades}</div>
                                        </div>
                                        <div>
                                            <div class="text-gray-400">Correct Trades:</div>
                                            <div class="font-bold text-green-400">${todayStats.correct_trades}</div>
                                        </div>
                                        <div>
                                            <div class="text-gray-400">Incorrect Trades:</div>
                                            <div class="font-bold text-red-400">${todayStats.incorrect_trades}</div>
                                        </div>
                                        <div>
                                            <div class="text-gray-400">Avg Profit Trades:</div>
                                            <div class="font-bold ${parseFloat(todayStats.avg_profit) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                                ${todayStats.avg_profit.toFixed(2)}%
                                            </div>
                                        </div>
                                        <div class="col-span-2">
                                            <div class="text-gray-400">Decision Distribution:</div>
                                            <div class="flex justify-between mt-1">
                                                <span class="text-green-400">Buy: ${todayStats.buy_decisions}</span>
                                                <span class="text-red-400">Sell: ${todayStats.sell_decisions}</span>
                                                <span class="text-blue-400">Hold: ${todayStats.hold_decisions}</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    });
                })
                .catch(error => console.error('Error fetching daily stats:', error));
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing dashboard...');
            loadPersistedHistory(); // Load persisted data first
            checkDailyReset(); // Check if we need to reset daily stats
            initCharts();
            updateData();  // Initial data fetch
            fetchDailyStats(); // Fetch daily stats

            // Set up auto-refresh every 10 minutes
            const refreshInterval = setInterval(() => {
                console.log('Auto-refresh triggered');
                updateData();
                fetchDailyStats(); // Also refresh daily stats
            }, 600000);  // 10 minutes

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                clearInterval(refreshInterval);
                persistTradingHistory(); // Ensure data is saved before unload
            });
        });

        // Add timeframe update function
        function updateTimeframe(timeframe) {
            // Update button styles
            document.querySelectorAll('.cyber-btn').forEach(btn => {
                btn.classList.remove('cyber-btn-active');
            });
            event.target.classList.add('cyber-btn-active');

            // Fetch new data with selected timeframe
            fetch(`/api/model-stats?timeframe=${timeframe}`)
                .then(response => response.json())
                .then(data => {
                    if (data.performance) {
                        updateModelStats(data.performance);
                    }
                    if (data.comparison) {
                        updateModelStats(data.comparison);
                    }
                })
                .catch(error => console.error('Error updating timeframe:', error));
        }

        // Filter trades from the last 24 hours
        function getRecentTrades(trades) {
            const oneDayAgo = new Date();
            oneDayAgo.setHours(oneDayAgo.getHours() - 24);
            return trades.filter(trade => new Date(trade.timestamp) > oneDayAgo);
        }

        // Check if we need to reset daily stats
        function checkDailyReset() {
            const lastReset = localStorage.getItem('last_daily_reset');
            const now = new Date();
            const today = now.toDateString();

            if (lastReset !== today) {
                // Reset daily stats for each model
                ['gemini', 'groq', 'mistral'].forEach(model => {
                    // We don't actually delete trades, just mark when we last reset
                    console.log(`Resetting daily stats for ${model}`);
                });

                // Store today's date as the last reset day
                localStorage.setItem('last_daily_reset', today);
                return true;
            }
            return false;
        }

        // Add wallet notification function
        async function sendWalletNotification(message, signalType) {
            if (!userAccount || !web3) return;

            try {
                // Create notification transaction
                const notificationData = web3.eth.abi.encodeFunctionSignature('notify(string,string)') +
                    web3.eth.abi.encodeParameters(
                        ['string', 'string'],
                        [signalType, message]
                    ).slice(2);

                // Send notification transaction
                await web3.eth.sendTransaction({
                    from: userAccount,
                    to: userAccount, // Send to self for notification
                    data: notificationData,
                    gas: 200000,
                    gasPrice: await web3.eth.getGasPrice()
                });

                console.log('Wallet notification sent successfully');
            } catch (error) {
                console.error('Error sending wallet notification:', error);
            }
        }

        // Add notification permission request
        async function requestNotificationPermission() {
            if (!userAccount) return;

            try {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    console.log('Notification permission granted');
                }
            } catch (error) {
                console.error('Error requesting notification permission:', error);
            }
        }
    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <!-- Header -->
    <header class="cyber-header p-4">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center">
                <img src="static/robot.webp" alt="Trading Bot Chef Logo" class="header-logo">
                <h1 class="cyber-title text-2xl">Simple Crypto Trading Bot Chef</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="wallet-btn" onclick="connectWallet()" class="wallet-btn px-4 py-2 rounded">
                    Connect Wallet
                </button>
                <a href="https://github.com/Qbandev/stbchef" target="_blank" class="cyber-btn px-4 py-2 rounded flex items-center">
                    <i class="fab fa-github mr-2"></i>
                    GitHub
                </a>
            </div>
        </div>
    </header>

    <div class="container mx-auto px-4 py-4">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- ETH Price Info -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">ETH Price</h2>
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Current Price:</span>
                        <span id="eth-price" class="font-semibold cyber-value">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">24h Volume:</span>
                        <span id="eth-volume" class="font-semibold cyber-value">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">24h High:</span>
                        <span id="eth-high" class="font-semibold cyber-value">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">24h Low:</span>
                        <span id="eth-low" class="font-semibold cyber-value">-</span>
                    </div>
                </div>
            </div>

            <!-- Gas Prices -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">Gas Prices</h2>
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Low:</span>
                        <span id="gas-low" class="font-semibold cyber-value">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Standard:</span>
                        <span id="gas-standard" class="font-semibold cyber-value">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Fast:</span>
                        <span id="gas-fast" class="font-semibold cyber-value">-</span>
                    </div>
                </div>
            </div>

            <!-- Trading Signals -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">Market Signals</h2>
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Market Sentiment:</span>
                        <span id="sentiment" class="font-semibold cyber-value">-</span>
                    </div>
                </div>
            </div>

            <!-- Gemini AI Recommendation -->
            <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold cyber-title">Gemini AI</h2>
                    <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                </div>
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <span class="text-gray-400">Decision:</span>
                        <span id="gemini-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                    </div>
                    <div class="text-xs text-gray-400 text-right">Powered by Gemini 1.5 Flash</div>
                </div>
            </div>

            <!-- Groq AI Recommendation -->
            <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold cyber-title">Groq AI</h2>
                    <svg class="w-6 h-6 text-neon-purple" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                    </svg>
                </div>
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <span class="text-gray-400">Decision:</span>
                        <span id="groq-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                    </div>
                    <div class="text-xs text-gray-400 text-right">Powered by DeepSeek-R1-Distill-Llama-70B</div>
                </div>
            </div>

            <!-- Mistral AI Recommendation -->
            <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold cyber-title">Mistral AI</h2>
                    <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10l3.5 3.5m0-6.5L13 10m6 0l-3.5 3.5M7 10l-3.5 3.5m0-6.5L7 10m-6 0l3.5 3.5" />
                    </svg>
                </div>
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <span class="text-gray-400">Decision:</span>
                        <span id="mistral-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                    </div>
                    <div class="text-xs text-gray-400 text-right">Powered by Mistral Large</div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="cyber-card rounded-lg shadow p-6 col-span-3">
                <h2 class="text-xl font-semibold mb-4 cyber-title">Model Performance</h2>
                <div class="grid grid-cols-3 gap-6">
                    <!-- Gemini Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-blue">Gemini AI</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-gray-400">Performance Score:</span>
                                <div class="tooltip-container">
                                    <span id="gemini-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                    <div class="tooltip">
                                        Weighted average of recent trade scores (last 100 trades)
                                    </div>
                                </div>
                                <div class="tooltip-container">
                                    <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                    <div class="tooltip">
                                        Score Calculation:
â€¢ Base score (1 point) for correct direction (BUY/SELL/HOLD)
â€¢ Bonus points (up to 1) for magnitude of correct decision
â€¢ Recent trades weighted more heavily
â€¢ Based on last 100 trades
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-blue">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="gemini-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Groq Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-purple">Groq DeepSeek</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-gray-400">Performance Score:</span>
                                <div class="tooltip-container">
                                    <span id="groq-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                    <div class="tooltip">
                                        Weighted average of recent trade scores (last 100 trades)
                                    </div>
                                </div>
                                <div class="tooltip-container">
                                    <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                    <div class="tooltip">
                                        Score Calculation:
â€¢ Base score (1 point) for correct direction (BUY/SELL/HOLD)
â€¢ Bonus points (up to 1) for magnitude of correct decision
â€¢ Recent trades weighted more heavily
â€¢ Based on last 100 trades
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-purple">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="groq-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Mistral Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-green">Mistral AI</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-gray-400">Performance Score:</span>
                                <div class="tooltip-container">
                                    <span id="mistral-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                    <div class="tooltip">
                                        Weighted average of recent trade scores (last 100 trades)
                                    </div>
                                </div>
                                <div class="tooltip-container">
                                    <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                    <div class="tooltip">
                                        Score Calculation:
â€¢ Base score (1 point) for correct direction (BUY/SELL/HOLD)
â€¢ Bonus points (up to 1) for magnitude of correct decision
â€¢ Recent trades weighted more heavily
â€¢ Based on last 100 trades
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-green">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="mistral-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Charts -->
        <div class="grid grid-cols-1 gap-6 mt-6">
            <!-- Price Chart -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">ETH Price Trend</h2>
                <div class="chart-container">
                    <canvas id="price-chart"></canvas>
                </div>
            </div>
        </div>
    </div>
</body>
</html> 
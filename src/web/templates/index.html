<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Crypto Trading Bot Chef</title>
    <link rel="icon" type="image/webp" href="static/favicon.webp">
    <link rel="stylesheet" href="static/css/styles.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Include utilities JS -->
    <script src="static/js/utils.js"></script>
    <!-- Include market analysis JS -->
    <script src="static/js/marketAnalysis.js"></script>
    <!-- Include chart handlers JS -->
    <script src="static/js/chartHandlers.js"></script>
    <!-- Include wallet manager JS -->
    <script src="static/js/walletManager.js"></script>
    <script>
        // Initialize a notification permission state variable
        let notificationPermissionGranted = false;
        
        // Storage keys for persisting data
        const STORAGE_KEYS = {
            WALLET: 'stbchef_wallet',
            HISTORY: 'stbchef_history',
            LAST_UPDATE: 'stbchef_last_update',
            PRICE_DATA: 'stbchef_price_data',
            VOLUME_DATA: 'stbchef_volume_data',
            TIME_LABELS: 'stbchef_time_labels',
            TRADE_HISTORY: 'stbchef_trade_history',
            MODEL_PERFORMANCE: 'stbchef_model_performance'
        };
        
        // Initialize variables
        window.web3 = null;
        window.userAccount = null;
        let priceChart;
        let performanceChart;
        let priceHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.PRICE_DATA) || '[]');
        let timeLabels = JSON.parse(localStorage.getItem(STORAGE_KEYS.TIME_LABELS) || '[]');
        let volumeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.VOLUME_DATA) || '[]');
        const tradingActions = [];

        // Make chart data available globally
        window.priceHistory = priceHistory;
        window.timeLabels = timeLabels;
        window.volumeHistory = volumeHistory;
        window.STORAGE_KEYS = STORAGE_KEYS;

        // Initialize trade history for each model
        let tradeHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.TRADE_HISTORY) || JSON.stringify({
            gemini: [],
            groq: [],
            mistral: []
        }));
        
        // Make tradeHistory available globally
        window.tradeHistory = tradeHistory;

        // Add accuracy tracking variables
        let aiAccuracy = JSON.parse(localStorage.getItem(STORAGE_KEYS.MODEL_PERFORMANCE) || JSON.stringify({
            gemini: { correct: 0, total: 0 },
            groq: { correct: 0, total: 0 },
            mistral: { correct: 0, total: 0 }
        }));
        
        // Make aiAccuracy available globally
        window.aiAccuracy = aiAccuracy;

        // Add market volatility tracking
        let marketVolatility = {
            window: 24, // 24-hour window
            data: [],
            current: 0
        };

        // Functions moved to marketAnalysis.js
        
        let lastDecisions = {
            gemini: null,
            groq: null,
            mistral: null,
            price: null
        };

        // Make lastDecisions available globally
        window.lastDecisions = lastDecisions;
        
        // User account is already initialized as a global variable

        // Load persisted wallet connection on page load
        window.addEventListener('load', async () => {
            const persistedWallet = localStorage.getItem(STORAGE_KEYS.WALLET);
            if (persistedWallet && typeof window.ethereum !== 'undefined') {
                try {
                    window.web3 = new Web3(window.ethereum);
                    
                    // First check if ethereum is connected at all
                    const isConnected = window.ethereum.isConnected();
                    if (!isConnected) {
                        console.log('MetaMask is not connected, waiting for connection...');
                        // Wait for connection
                        await new Promise(resolve => {
                            const connectionCheckInterval = setInterval(() => {
                                if (window.ethereum.isConnected()) {
                                    clearInterval(connectionCheckInterval);
                                    resolve();
                                }
                            }, 100);
                            // Timeout after 3 seconds
                            setTimeout(() => {
                                clearInterval(connectionCheckInterval);
                                resolve();
                            }, 3000);
                        });
                    }
                    
                    // Request accounts - this will NOT prompt if already connected
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    
                    if (accounts.length === 0) {
                        // Need to explicitly request accounts
                        try {
                            const requestedAccounts = await window.ethereum.request({ 
                                method: 'eth_requestAccounts',
                                params: [] 
                            });
                            
                            if (requestedAccounts.length > 0 && 
                                requestedAccounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                                userAccount = requestedAccounts[0];
                            } else if (requestedAccounts.length > 0) {
                                // Different account than stored
                                userAccount = requestedAccounts[0];
                                persistWalletConnection(userAccount);
                            }
                        } catch (err) {
                            console.log('User rejected connection or request failed:', err);
                            localStorage.removeItem(STORAGE_KEYS.WALLET);
                            userAccount = null;
                            updateWalletUI();
                            return;
                        }
                    } else if (accounts[0] && accounts[0].toLowerCase() === persistedWallet.toLowerCase()) {
                        userAccount = accounts[0];
                    } else if (accounts.length > 0) {
                        // If account is available but different from stored one, update it
                        userAccount = accounts[0];
                        persistWalletConnection(userAccount);
                    }
                    
                    if (userAccount) {
                        updateWalletUI();
                        
                        // Fetch initial wallet data
                        await getWalletBalances();
                        
                        // Ensure model decisions are updated with wallet connection status
                        fetch('/api/trading-data')
                            .then(response => response.json())
                            .then(data => {
                                updateModelDecisions(data, userAccount);
                            })
                            .catch(error => {
                                console.error("Failed to fetch initial trading data:", error);
                            });
                            
                        // Load wallet-specific stats
                        fetchWalletStats();
                        
                        // Setup session persistence - check connection status periodically
                        setInterval(async () => {
                            if (typeof window.ethereum !== 'undefined') {
                                const isStillConnected = window.ethereum.isConnected();
                                const currentAccounts = await window.ethereum.request({ method: 'eth_accounts' })
                                    .catch(() => []);
                                
                                // If metamask disconnected or account changed unexpectedly
                                if (!isStillConnected || currentAccounts.length === 0 || 
                                    (userAccount && currentAccounts[0].toLowerCase() !== userAccount.toLowerCase())) {
                                    // Attempt to reconnect silently
                                    if (isStillConnected && currentAccounts.length === 0) {
                                        try {
                                            const reconnectAccounts = await window.ethereum.request({ 
                                                method: 'eth_requestAccounts',
                                                params: [] 
                                            }).catch(() => []);
                                            
                                            if (reconnectAccounts.length > 0) {
                                                userAccount = reconnectAccounts[0];
                                                persistWalletConnection(userAccount);
                                                updateWalletUI();
                                                await getWalletBalances();
                                                fetchWalletStats();
                                            }
                                        } catch (e) {
                                            // Silent reconnect failed, don't bother user
                                            console.log('Silent reconnect failed:', e);
                                        }
                                    }
                                }
                            }
                        }, 10000); // Check every 10 seconds
                    }
                } catch (error) {
                    console.error('Error restoring wallet connection:', error);
                    localStorage.removeItem(STORAGE_KEYS.WALLET);
                    userAccount = null;
                    updateWalletUI();
                }
            } else {
                // Ensure model decisions show "Connect wallet first"
                fetch('/api/trading-data')
                    .then(response => response.json())
                    .then(data => {
                        updateModelDecisions(data, null);
                    })
                    .catch(error => {
                        console.error("Failed to fetch initial trading data:", error);
                    });
            }
            clearExpiredData();
            
            // Setup visibility change handler to refresh wallet connection when tab becomes visible again
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    // Tab is now visible, check wallet connection
                    const persistedWallet = localStorage.getItem(STORAGE_KEYS.WALLET);
                    if (persistedWallet && typeof window.ethereum !== 'undefined') {
                        try {
                            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                            if (accounts.length > 0) {
                                // If we have a stored wallet but it doesn't match, update it
                                if (!userAccount || accounts[0].toLowerCase() !== userAccount.toLowerCase()) {
                                    userAccount = accounts[0];
                                    persistWalletConnection(userAccount);
                                    updateWalletUI();
                                    await getWalletBalances();
                                    fetchWalletStats();
                                    
                                    // Update LLM decisions for the new account
                                    const tradingData = await fetch('/api/trading-data').then(res => res.json());
                                    updateModelDecisions(tradingData, userAccount);
                                }
                            } else if (userAccount) {
                                // We have a userAccount but ethereum doesn't show any accounts
                                // Try silently reconnecting
                                try {
                                    const reconnectAccounts = await window.ethereum.request({ 
                                        method: 'eth_requestAccounts',
                                        params: [] 
                                    }).catch(() => []);
                                    
                                    if (reconnectAccounts.length > 0) {
                                        userAccount = reconnectAccounts[0];
                                        persistWalletConnection(userAccount);
                                        updateWalletUI();
                                        await getWalletBalances();
                                        fetchWalletStats();
                                    } else {
                                        // Failed to reconnect silently, reset wallet state
                                        userAccount = null;
                                        persistWalletConnection(null);
                                        updateWalletUI();
                                        displayEmptyStats();
                                    }
                                } catch (e) {
                                    // Silent reconnect failed, reset wallet state
                                    userAccount = null;
                                    persistWalletConnection(null);
                                    updateWalletUI();
                                    displayEmptyStats();
                                }
                            }
                        } catch (error) {
                            console.error('Error checking wallet connection on visibility change:', error);
                        }
                    }
                }
            });
        });

        // Modified wallet connection function
        async function connectWallet() {
            // If already connected, disconnect
            if (window.userAccount) {
                window.userAccount = null;
                window.web3 = null;
                resetWalletBalances();
                
                // Remove from localStorage to prevent auto-reconnect
                localStorage.removeItem(STORAGE_KEYS.WALLET);
                
                // Clear raw accuracy data from localStorage
                localStorage.removeItem('stbchef_raw_accuracy');
                
                // Reset raw accuracy tracking
                aiRawAccuracy = {
                    gemini: { correct: 0, total: 0, accuracy: 0 },
                    groq: { correct: 0, total: 0, accuracy: 0 },
                    mistral: { correct: 0, total: 0, accuracy: 0 }
                };
                
                // Update UI
                updateWalletUI();
                
                // Clear model performance when disconnecting
                displayEmptyStats();
                
                // Update LLM decision cards to show "Connect wallet first"
                try {
                    const tradingData = await fetch('/api/trading-data').then(res => res.json());
                    updateModelDecisions(tradingData, null);
                } catch (error) {
                    console.error('Error updating model decisions after disconnect:', error);
                }
                
                showNotification('Wallet disconnected', 'warning');
                return;
            }
            
            if (typeof window.ethereum !== 'undefined') {
                try {
                    // Show loading state on wallet button
                    const walletBtn = document.getElementById('wallet-btn');
                    if (walletBtn) {
                        walletBtn.innerHTML = '<i class="fas fa-sync-alt fa-spin mr-2"></i> Connecting...';
                        walletBtn.classList.add('connecting');
                    }
                    
                    // Request accounts
                    const accounts = await window.ethereum.request({ 
                        method: 'eth_requestAccounts',
                        params: []
                    }).catch(error => {
                        console.error('User denied account access:', error);
                        
                        // Reset wallet button
                        if (walletBtn) {
                            walletBtn.innerHTML = 'Connect Wallet';
                            walletBtn.classList.remove('connecting');
                        }
                        
                        showNotification('Failed to connect wallet', 'error');
                        throw error;
                    });
                    
                    if (!accounts || accounts.length === 0) {
                        // Reset wallet button
                        if (walletBtn) {
                            walletBtn.innerHTML = 'Connect Wallet';
                            walletBtn.classList.remove('connecting');
                        }
                        
                        showNotification('No accounts found', 'error');
                        return;
                    }
                    
                    window.userAccount = accounts[0];
                    window.web3 = new Web3(window.ethereum);

                    // Check which network we're on
                    const chainId = await window.web3.eth.getChainId();
                    const isLinea = chainId === 59144;
                    const isEthereum = chainId === 1;
                    
                    // Only show warning if on unsupported network, no need for confirmation on supported ones
                    if (!isLinea && !isEthereum) {
                        showNotification(`Connected to unsupported network (ID: ${chainId}). Please switch to Linea (ID: 59144) or Ethereum (ID: 1).`, 'warning');
                    }

                    // Save account immediately
                    persistWalletConnection(window.userAccount);
                    
                    // Show loading state on wallet card
                    const walletCard = document.getElementById('wallet-card');
                    if (walletCard) {
                        walletCard.innerHTML = `
                            <div class="flex flex-col">
                                <div class="flex items-center justify-between mb-3">
                                    <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                </div>
                                <div class="flex flex-col items-center justify-center h-24">
                                    <p class="text-gray-400 mb-2">Loading wallet data...</p>
                                    <div class="spinner"><i class="fas fa-sync-alt fa-spin"></i></div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Update UI before API calls
                    updateWalletUI();
                    
                    try {
                        // Get wallet balances after connecting
                        await getWalletBalances();
                    } catch (error) {
                        console.error('Error fetching wallet balances:', error);
                        showNotification('Connected, but could not fetch wallet balances', 'warning');
                    }
                    
                    try {
                        // Update model performance cards with wallet-specific data
                        await fetchWalletStats();
                    } catch (error) {
                        console.error('Error fetching wallet stats:', error);
                    }
                    
                    try {
                        // Update LLM decision cards
                        const tradingData = await fetch('/api/trading-data').then(res => res.json());
                        updateModelDecisions(tradingData, window.userAccount);
                    } catch (error) {
                        console.error('Error updating model decisions:', error);
                    }
                    
                    showNotification('Wallet connected successfully!', 'success');

                    // Request notification permission after wallet connection
                    await requestNotificationPermission();

                    // Handle account changes - only set up once
                    if (!window.hasSetupMetaMaskEvents) {
                        window.hasSetupMetaMaskEvents = true;
                        
                        window.ethereum.on('accountsChanged', function (accounts) {
                            if (accounts.length === 0) {
                                window.userAccount = null;
                                resetWalletBalances();
                                
                                // Remove from localStorage
                                localStorage.removeItem(STORAGE_KEYS.WALLET);
                                
                                // Clear raw accuracy data from localStorage
                                localStorage.removeItem('stbchef_raw_accuracy');
                                
                                // Reset raw accuracy tracking
                                aiRawAccuracy = {
                                    gemini: { correct: 0, total: 0, accuracy: 0 },
                                    groq: { correct: 0, total: 0, accuracy: 0 },
                                    mistral: { correct: 0, total: 0, accuracy: 0 }
                                };
                                
                                // Update UI
                                updateWalletUI();
                                
                                // Update model stats and LLM decisions on disconnect
                                displayEmptyStats();
                                fetch('/api/trading-data')
                                    .then(res => res.json())
                                    .then(data => updateModelDecisions(data, null))
                                    .catch(error => console.error('Error updating model decisions:', error));
                            } else {
                                userAccount = accounts[0];
                                
                                // Clear old raw accuracy data since we're connecting to a new wallet
                                localStorage.removeItem('stbchef_raw_accuracy');
                                
                                // Reset raw accuracy tracking for new wallet
                                aiRawAccuracy = {
                                    gemini: { correct: 0, total: 0, accuracy: 0 },
                                    groq: { correct: 0, total: 0, accuracy: 0 },
                                    mistral: { correct: 0, total: 0, accuracy: 0 }
                                };
                                
                                // Save to localStorage
                                persistWalletConnection(userAccount);
                                
                                // Update UI
                                updateWalletUI();
                                
                                // Update wallet data
                                getWalletBalances().catch(error => 
                                    console.error('Error fetching wallet balances after account change:', error));
                                
                                // Request permission for new account
                                requestNotificationPermission().catch(error => 
                                    console.error('Error requesting notification permission:', error)); 
                                
                                // Update model stats and LLM decisions on account change
                                fetchWalletStats().catch(error => 
                                    console.error('Error fetching wallet stats after account change:', error));
                                
                                fetch('/api/trading-data')
                                    .then(res => res.json())
                                    .then(data => updateModelDecisions(data, window.userAccount))
                                    .catch(error => console.error('Error updating model decisions:', error));
                            }
                            
                            showNotification(accounts.length === 0 ? 'Wallet disconnected' : 'Wallet account changed', 
                                            accounts.length === 0 ? 'warning' : 'info');
                        });
                        
                        // Update balances when chain changes
                        window.ethereum.on('chainChanged', function (chainIdHex) {
                            const newChainId = parseInt(chainIdHex, 16);
                            const isLinea = newChainId === 59144;
                            const isEthereum = newChainId === 1;
                            
                            // Only show warning if on unsupported network
                            if (!isLinea && !isEthereum) {
                                showNotification(`Switched to unsupported network (ID: ${newChainId}). 
                                                Please switch to Linea (ID: 59144) or Ethereum (ID: 1).`, 'warning');
                            }
                            
                            // Update wallet data
                            getWalletBalances().catch(error => 
                                console.error('Error fetching wallet balances after chain change:', error));
                            
                            // Update UI
                            updateWalletUI();
                            
                            // Update model stats and decisions
                            fetchWalletStats().catch(error => 
                                console.error('Error fetching wallet stats after chain change:', error));
                            
                            fetch('/api/trading-data')
                                .then(res => res.json())
                                .then(data => updateModelDecisions(data, window.userAccount))
                                .catch(error => console.error('Error updating model decisions:', error));
                            
                            showNotification(`Network changed to ID: ${newChainId}`, 'info');
                        });
                        
                        // Handle disconnect event
                        window.ethereum.on('disconnect', function (error) {
                            console.log('MetaMask disconnected:', error);
                            
                            // Only clear if this is our current connection
                            if (window.userAccount) {
                                userAccount = null;
                                resetWalletBalances();
                                
                                // Remove from localStorage
                                localStorage.removeItem(STORAGE_KEYS.WALLET);
                                
                                // Clear raw accuracy data from localStorage
                                localStorage.removeItem('stbchef_raw_accuracy');
                                
                                // Reset raw accuracy tracking
                                aiRawAccuracy = {
                                    gemini: { correct: 0, total: 0, accuracy: 0 },
                                    groq: { correct: 0, total: 0, accuracy: 0 },
                                    mistral: { correct: 0, total: 0, accuracy: 0 }
                                };
                                
                                // Update UI
                                updateWalletUI();
                                
                                // Update model stats and LLM decisions
                                displayEmptyStats();
                                fetch('/api/trading-data')
                                    .then(res => res.json())
                                    .then(data => updateModelDecisions(data, null))
                                    .catch(error => console.error('Error updating model decisions:', error));
                                
                                showNotification('Wallet disconnected', 'warning');
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error connecting wallet:', error);
                    showNotification('Failed to connect wallet', 'error');
                    
                    // Reset wallet button
                    const walletBtn = document.getElementById('wallet-btn');
                    if (walletBtn) {
                        walletBtn.innerHTML = 'Connect Wallet';
                        walletBtn.classList.remove('connecting');
                    }
                }
            } else {
                showNotification('Please install MetaMask!', 'error');
            }
        }
        
        // Define token contract ABIs
        const ERC20_ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            }
        ];
        
        // Wallet balances
        let walletBalances = {
            eth: 0,
            usdc: 0,
            ethusd: 0, // Current ETH/USD price
            totalValueUSD: 0
        };
        
        // Get wallet balances
        async function getWalletBalances() {
            if (!window.userAccount || !window.web3) {
                console.log("No wallet connection available");
                resetWalletBalances();
                return;
            }
            
            try {
                console.log("Fetching wallet balances for", window.userAccount);
                
                // Show loading state while fetching wallet data
                showLoadingWalletState("Retrieving wallet balances...");
                
                // Get current network ID with timeout
                let chainId;
                try {
                    const timeout = ms => new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Chain ID request timed out')), ms));
                    
                    chainId = await Promise.race([
                        window.web3.eth.getChainId(),
                        timeout(3000) // 3 second timeout
                    ]);
                    console.log("Current chain ID:", chainId);
                } catch (chainError) {
                    console.error("Error getting chain ID:", chainError);
                    chainId = 0; // Use 0 as "unknown network"
                    
                    // Update loading state to show network issue
                    showLoadingWalletState("Network detection issue - please check MetaMask");
                }
                
                // Check if we're on Linea (Chain ID 59144) or Ethereum (Chain ID 1)
                const isLinea = chainId === 59144;
                const isEthereum = chainId === 1;
                const isSupportedNetwork = isLinea || isEthereum;
                
                if (!isSupportedNetwork) {
                    showNotification(`Unsupported network (Chain ID: ${chainId}). Please switch to Linea or Ethereum mainnet.`, 'warning');
                    console.warn(`Unsupported network: ${chainId}`);
                    
                    // Update loading state to show network issue
                    showLoadingWalletState("Connected to unsupported network - please switch");
                }
                
                // Get ETH balance
                const ethBalance = await window.web3.eth.getBalance(window.userAccount);
                walletBalances.eth = parseFloat(window.web3.utils.fromWei(ethBalance, 'ether'));
                console.log("ETH balance:", walletBalances.eth);
                
                // Only try to get USDC balance if we're on a supported network
                walletBalances.usdc = 0; // Default to 0
                
                if (isLinea) {
                    // Update loading state to show token balance retrieval
                    showLoadingWalletState("Retrieving Linea USDC balance...");
                    
                    // USDC on Linea
                    const lineaUsdcAddress = '0x176211869cA2b568f2A7D4EE941E073a821EE1ff';
                    try {
                        await getTokenBalance(lineaUsdcAddress);
                    } catch (contractError) {
                        console.warn("Error fetching Linea USDC balance:", contractError.message);
                    }
                } else if (isEthereum) {
                    // Update loading state to show token balance retrieval
                    showLoadingWalletState("Retrieving Ethereum USDC balance...");
                    
                    // USDC on Ethereum Mainnet
                    const ethUsdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
                    try {
                        await getTokenBalance(ethUsdcAddress);
                    } catch (contractError) {
                        console.warn("Error fetching Ethereum USDC balance:", contractError.message);
                    }
                }
                
                // Update loading state to show price data retrieval
                showLoadingWalletState("Retrieving ETH price data...");
                
                // Get ETH price from the UI - NEVER use a default price
                let validPriceFound = false;
                try {
                    const priceText = document.getElementById('eth-price').textContent;
                    if (priceText && priceText !== 'Error' && priceText !== 'Waiting for data...') {
                        const parsedPrice = parseFloat(priceText.replace('$', '').trim());
                        if (!isNaN(parsedPrice) && parsedPrice > 0) {
                            walletBalances.ethusd = parsedPrice;
                            console.log("ETH/USD price from UI:", walletBalances.ethusd);
                            validPriceFound = true;
                        }
                    }
                    
                    // If UI price failed, try the API directly
                    if (!validPriceFound) {
                        const response = await fetch('/api/trading-data');
                        const data = await response.json();
                        if (data && data.eth_price && !isNaN(parseFloat(data.eth_price)) && parseFloat(data.eth_price) > 0) {
                            walletBalances.ethusd = parseFloat(data.eth_price);
                            console.log("ETH/USD price from API:", walletBalances.ethusd);
                            validPriceFound = true;
                        }
                    }
                } catch (priceError) {
                    console.warn("Error getting ETH price:", priceError);
                    validPriceFound = false;
                }
                
                if (!validPriceFound) {
                    console.warn("No valid ETH price available - cannot calculate wallet value");
                    walletBalances.ethusd = 0;
                    walletBalances.totalValueUSD = 0;
                    
                    // Show specific message about missing price data
                    walletCard.innerHTML = `
                        <div class="p-4">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                <div class="flex items-center">
                                    <span class="text-xs ${isLinea ? 'text-green-400' : isEthereum ? 'text-green-400' : 'text-yellow-400'} mr-2">
                                        Network: ${isLinea ? 'Linea' : isEthereum ? 'Ethereum' : 'Unknown'}
                                    </span>
                                    <span class="text-xs text-gray-400">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                </div>
                            </div>
                            <div class="flex flex-col">
                                <div class="grid grid-cols-2 gap-2 text-sm">
                                    <div>
                                        <div class="text-gray-400">ETH Balance:</div>
                                        <div class="font-bold text-cyber-text">${walletBalances.eth.toFixed(4)} ETH</div>
                                    </div>
                                    <div>
                                        <div class="text-gray-400">USDC Balance:</div>
                                        <div class="font-bold text-cyber-text">${walletBalances.usdc.toFixed(2)} USDC</div>
                                    </div>
                                </div>
                                <div class="mt-4 text-center">
                                    <p class="text-yellow-400">Waiting for ETH price data</p>
                                    <p class="text-xs text-gray-400 mt-1">Wallet balances ready, but portfolio analysis requires price data</p>
                                </div>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Calculate total wallet value only if we have a valid price
                walletBalances.totalValueUSD = (walletBalances.eth * walletBalances.ethusd) + walletBalances.usdc;
                console.log("ETH value in USD:", walletBalances.eth * walletBalances.ethusd);
                console.log("USDC value:", walletBalances.usdc);
                console.log("Total wallet value:", walletBalances.totalValueUSD, "USD");
                
                // Update UI
                updateWalletCard();
                updateModelStatsForWallet();
            } catch (error) {
                console.error("Error fetching wallet balances:", error);
                showNotification("Error fetching wallet balances: " + error.message, "error");
                
                // Show specific error message in wallet card
                const walletCard = document.getElementById('wallet-card');
                if (walletCard) {
                    walletCard.innerHTML = `
                        <div class="p-4">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            </div>
                            <div class="flex flex-col items-center justify-center py-4">
                                <p class="text-red-400 mb-2">Error retrieving wallet data</p>
                                <p class="text-xs text-gray-400 text-center">${error.message}</p>
                                <button onclick="getWalletBalances()" class="cyber-btn mt-3 text-xs px-3 py-1">
                                    <i class="fas fa-sync-alt mr-1"></i> Retry
                                </button>
                            </div>
                        </div>
                    `;
                }
                // Don't reset wallet balances here, keep whatever was valid previously
            }
        }
        
        // Get token balance helper function
        async function getTokenBalance(tokenAddress) {
            try {
                console.log(`Attempting to fetch token balance for ${tokenAddress}`);
                
                // Create contract instance with error checking
                let tokenContract;
                try {
                    tokenContract = new window.web3.eth.Contract(ERC20_ABI, tokenAddress);
                    
                    // Check if methods and necessary functions exist on the contract
                    if (!tokenContract.methods || typeof tokenContract.methods.symbol !== 'function') {
                        console.error('Contract methods not properly initialized or symbol method is missing');
                        // Create a properly structured contract to avoid errors
                        tokenContract = {
                            methods: {
                                symbol: () => ({ call: async () => 'UNKNOWN' }),
                                decimals: () => ({ call: async () => '6' }),
                                balanceOf: (address) => ({ call: async () => '0' })
                            }
                        };
                    }
                } catch (contractError) {
                    console.error(`Failed to create contract instance: ${contractError.message}`);
                    // Create a fallback contract object with minimum required methods
                    tokenContract = {
                        methods: {
                            symbol: () => ({ call: async () => 'UNKNOWN' }),
                            decimals: () => ({ call: async () => '6' }),
                            balanceOf: (address) => ({ call: async () => '0' })
                        }
                    };
                }
                
                // Use shorter timeouts to avoid hanging
                const timeout = ms => new Promise((_, reject) => 
                    setTimeout(() => reject(new Error(`Contract call timed out after ${ms}ms`)), ms));
                
                // First check if the contract responds at all with a simple call
                try {
                    // Brief timeout for simple call
                    const contractCheck = await Promise.race([
                        tokenContract.methods.symbol().call(),
                        timeout(2000)
                    ]);
                    console.log(`Contract ${tokenAddress} responds with symbol: ${contractCheck}`);
                } catch (checkError) {
                    console.warn(`Contract not responding properly: ${checkError.message}`);
                    // Continue anyway, might still work
                }
                
                // Attempt the balance calls with shorter timeouts
                console.log(`Fetching decimals and balance from ${tokenAddress}`);
                let decimals, balance;
                
                try {
                    // Try decimals first with short timeout
                    decimals = await Promise.race([
                        tokenContract.methods.decimals().call(),
                        timeout(3000)
                    ]);
                    console.log(`Token decimals: ${decimals}`);
                } catch (decimalsError) {
                    console.warn(`Failed to get decimals: ${decimalsError.message}, using default value 6`);
                    // Default to 6 decimals for USDC as fallback
                    decimals = 6;
                }
                
                try {
                    // Try balance next with short timeout
                    balance = await Promise.race([
                        tokenContract.methods.balanceOf(window.userAccount).call(),
                        timeout(3000)
                    ]);
                    console.log(`Token balance (raw): ${balance}`);
                } catch (balanceError) {
                    console.warn(`Failed to get balance: ${balanceError.message}, using 0`);
                    // Default to 0 balance as fallback
                    balance = "0";
                }
                
                // Validate returned values with defensive programming
                if (balance === undefined || balance === null) {
                    console.warn("Received undefined/null balance, defaulting to 0");
                    balance = "0";
                }
                
                if (decimals === undefined || decimals === null) {
                    console.warn("Received undefined/null decimals, defaulting to 6");
                    decimals = 6;
                }
                
                // Parse values with error checking
                let decimalValue, balanceValue;
                try {
                    decimalValue = parseInt(decimals);
                    if (isNaN(decimalValue)) {
                        console.warn("Invalid decimals value, defaulting to 6");
                        decimalValue = 6;
                    }
                } catch (parseError) {
                    console.warn(`Error parsing decimals: ${parseError.message}, using default 6`);
                    decimalValue = 6;
                }
                
                try {
                    balanceValue = parseFloat(balance);
                    if (isNaN(balanceValue)) {
                        console.warn("Invalid balance value, defaulting to 0");
                        balanceValue = 0;
                    }
                } catch (parseError) {
                    console.warn(`Error parsing balance: ${parseError.message}, using 0`);
                    balanceValue = 0;
                }
                
                // Calculate final balance
                walletBalances.usdc = balanceValue / Math.pow(10, decimalValue);
                console.log(`USDC balance (formatted): ${walletBalances.usdc}`);
                return walletBalances.usdc;
            } catch (error) {
                // Log detailed error information, but don't fail catastrophically
                logToServer('error', "Token contract error", {
                    message: error.message,
                    tokenAddress: tokenAddress,
                    userAccount: window.userAccount,
                    chainId: window.web3.eth.chainId || 'unknown'
                });
                
                // Set USDC to 0 on error
                walletBalances.usdc = 0;
                return 0;
            }
        }
        
        // Reset wallet balances
        function resetWalletBalances() {
            walletBalances = {
                eth: 0,
                usdc: 0,
                ethusd: 0,
                totalValueUSD: 0
            };
            updateWalletCard();
            updateModelStatsForWallet();
        }
        
        // Update wallet card with current balances
        function updateWalletCard() {
            const walletCard = document.getElementById('wallet-card');
            if (!walletCard) return;
            
            if (!window.userAccount || !window.web3) {
                walletCard.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full">
                        <p class="text-gray-400 mb-2">Connect your wallet to see balances</p>
                    </div>
                `;
                return;
            }
            
            // Check if we have valid price data
            const hasValidPrice = walletBalances.ethusd && !isNaN(walletBalances.ethusd) && walletBalances.ethusd > 0;
            
            // Check if we're on Linea network
            window.web3.eth.getChainId().then(chainId => {
                const isLinea = chainId === 59144;
                const isEthereum = chainId === 1;
                const networkName = isLinea ? 'Linea' : isEthereum ? 'Ethereum' : 'Unknown Network';
                const networkClass = isLinea || isEthereum ? 'text-green-400' : 'text-yellow-400';
                
                // Network switching buttons
                const switchNetworkButtons = isLinea || isEthereum ? `
                    <div class="col-span-2 mt-3 flex justify-center space-x-4">
                        <button onclick="${isEthereum ? 'void(0)' : 'switchNetwork(1)'}" class="network-btn ${isEthereum ? 'network-active cursor-not-allowed opacity-80' : ''} flex items-center">
                            <div class="network-icon eth-icon">
                                <svg class="w-4 h-4" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 32C24.8366 32 32 24.8366 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32ZM15.9963 5.33333L15.8 5.88333V20.2L15.9963 20.3967L22.6599 16.405L15.9963 5.33333Z" fill="#627EEA" fill-opacity="0.7"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 5.33333L9.33333 16.405L16 20.3967V13.4183V5.33333Z" fill="#627EEA"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 21.93L15.8917 22.0633V26.4117L16 26.6633L22.6667 17.94L16 21.93Z" fill="#627EEA" fill-opacity="0.7"/>
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 26.6633V21.93L9.33333 17.94L16 26.6633Z" fill="#627EEA"/>
                                </svg>
                            </div>
                            <span>Ethereum</span>
                            ${isEthereum ? '<span class="active-indicator">●</span>' : ''}
                        </button>
                        <button onclick="${isLinea ? 'void(0)' : 'switchNetwork(59144)'}" class="network-btn ${isLinea ? 'network-active cursor-not-allowed opacity-80' : ''} flex items-center">
                            <div class="network-icon linea-icon">
                                <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 24C18.6274 24 24 18.6274 24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24Z" fill="#121212"/>
                                    <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="#00ABFF"/>
                                    <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="#00ABFF"/>
                                    <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="#00ABFF"/>
                                </svg>
                            </div>
                            <span>Linea</span>
                            ${isLinea ? '<span class="active-indicator">●</span>' : ''}
                        </button>
                    </div>
                ` : `
                    <div class="col-span-2 mt-3">
                        <div class="text-yellow-400 text-xs text-center mb-2">Switch to a supported network</div>
                        <div class="flex justify-center space-x-4">
                            <button onclick="switchNetwork(1)" class="network-btn flex items-center">
                                <div class="network-icon eth-icon">
                                    <svg class="w-4 h-4" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 32C24.8366 32 32 24.8366 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32ZM15.9963 5.33333L15.8 5.88333V20.2L15.9963 20.3967L22.6599 16.405L15.9963 5.33333Z" fill="#627EEA" fill-opacity="0.7"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 5.33333L9.33333 16.405L16 20.3967V13.4183V5.33333Z" fill="#627EEA"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 21.93L15.8917 22.0633V26.4117L16 26.6633L22.6667 17.94L16 21.93Z" fill="#627EEA" fill-opacity="0.7"/>
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M16 26.6633V21.93L9.33333 17.94L16 26.6633Z" fill="#627EEA"/>
                                    </svg>
                                </div>
                                <span>Ethereum</span>
                            </button>
                            <button onclick="switchNetwork(59144)" class="network-btn flex items-center">
                                <div class="network-icon linea-icon">
                                    <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 24C18.6274 24 24 18.6274 24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24Z" fill="#121212"/>
                                        <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="#00ABFF"/>
                                        <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="#00ABFF"/>
                                        <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="#00ABFF"/>
                                    </svg>
                                </div>
                                <span>Linea</span>
                            </button>
                        </div>
                    </div>
                `;
                
                // If we don't have a valid ETH price, show error and don't make calculations
                if (!hasValidPrice) {
                    walletCard.innerHTML = `
                        <div class="p-4">
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                                <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 ${isLinea ? 'border-blue-400' : isEthereum ? 'border-indigo-400' : 'border-yellow-400'} hover:shadow-glow transition-all duration-300">
                                    ${isLinea ? `
                                        <div class="network-icon-container mr-2 relative overflow-hidden">
                                            <svg class="w-5 h-5 text-blue-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                                <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(0,171,255,0.1)"/>
                                                <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="currentColor"/>
                                                <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="currentColor"/>
                                                <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="currentColor"/>
                                            </svg>
                                            <div class="absolute inset-0 bg-gradient-to-r from-transparent via-blue-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                        </div>
                                    ` : isEthereum ? `
                                        <div class="network-icon-container mr-2 relative overflow-hidden">
                                            <svg class="w-5 h-5 text-indigo-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                                <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(98,126,234,0.1)"/>
                                                <path d="M11.9982 4L11.8 4.4V15.1133L11.9982 15.275L16.9963 12.3L11.9982 4Z" fill="currentColor" fill-opacity="0.7"/>
                                                <path d="M12 4L7 12.3L12 15.275V10.0582V4Z" fill="currentColor"/>
                                                <path d="M11.9982 16.4826L11.9063 16.597V19.8105L11.9982 20L17 13.4264L11.9982 16.4826Z" fill="currentColor" fill-opacity="0.7"/>
                                                <path d="M12 20V16.4826L7 13.4264L12 20Z" fill="currentColor"/>
                                            </svg>
                                            <div class="absolute inset-0 bg-gradient-to-r from-transparent via-indigo-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                        </div>
                                    ` : `
                                        <div class="network-icon-container mr-2 relative overflow-hidden">
                                            <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                            </svg>
                                        </div>
                                    `}
                                    <div class="flex flex-col">
                                        <div class="text-xs ${isLinea ? 'text-blue-400' : isEthereum ? 'text-indigo-400' : 'text-yellow-400'} font-medium network-name">${networkName}</div>
                                        <div class="flex items-center">
                                            <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                            <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>
                                    <div class="text-gray-400">ETH Balance:</div>
                                    <div class="font-bold text-cyber-text">${walletBalances.eth.toFixed(4)} ETH</div>
                                    <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">USDC Balance:</div>
                                    <div class="font-bold text-cyber-text">${walletBalances.usdc.toFixed(2)} USDC</div>
                                    <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                                </div>
                                ${switchNetworkButtons}
                                <div class="col-span-2 mt-3 text-center">
                                    <p class="text-yellow-400">Wallet portfolio analysis paused</p>
                                    <p class="text-xs text-gray-400 mt-1">Portfolio recommendations will resume once data is available</p>
                                </div>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Calculate optimal action based on current portfolio allocation
                const ethValue = walletBalances.eth || 0;
                const usdcValue = walletBalances.usdc || 0;
                const ethPrice = walletBalances.ethusd || 0;
                
                const ethValueUSD = ethValue * ethPrice;
                const totalValue = (ethValueUSD + usdcValue) || 0;
                
                // Handle zero balance case properly with additional validation
                const hasNonZeroBalance = (ethValue > 0 || usdcValue > 0) && totalValue > 0;
                const currentEthAllocation = hasNonZeroBalance ? Math.min(100, Math.max(0, (ethValueUSD / totalValue * 100))) : 0;
                const currentUsdcAllocation = hasNonZeroBalance ? Math.min(100, Math.max(0, 100 - currentEthAllocation)) : 0;
                
                // Target allocation range: 60-80% ETH in bullish, 20-40% in bearish
                const marketSentiment = document.getElementById('sentiment');
                const isBullish = marketSentiment && marketSentiment.textContent.includes('bullish');
                
                const targetEthMin = isBullish ? 60 : 20;
                const targetEthMax = isBullish ? 80 : 40;
                
                // Instead of portfolio-based decision, use AI consensus or latest decisions if available
                let recommendedAction = 'HOLD';
                let swapAmount = 0;
                let swapDirection = '';
                
                // Get decisions from AI models
                const geminiDecision = document.getElementById('gemini-decision');
                const groqDecision = document.getElementById('groq-decision');
                const mistralDecision = document.getElementById('mistral-decision');
                
                const decisions = {
                    gemini: geminiDecision ? geminiDecision.textContent : null,
                    groq: groqDecision ? groqDecision.textContent : null,
                    mistral: mistralDecision ? mistralDecision.textContent : null
                };
                
                // Check for consensus
                const aiConsensus = checkLLMConsensus(decisions);
                
                // NEW LOGIC - Check for severe portfolio imbalance first
                const severeImbalanceThreshold = 10; // 10% threshold for severe imbalance
                
                if (totalValue > 0) {
                    if (currentEthAllocation < targetEthMin - severeImbalanceThreshold) {
                        // Severe imbalance - too little ETH regardless of consensus
                        recommendedAction = 'BUY';
                        const targetEthValue = (totalValue * targetEthMin / 100);
                        swapAmount = targetEthValue - ethValueUSD;
                        swapDirection = 'USDC → ETH';
                    } else if (currentEthAllocation > targetEthMax + severeImbalanceThreshold) {
                        // Severe imbalance - too much ETH regardless of consensus
                        recommendedAction = 'SELL';
                        const targetEthValue = (totalValue * targetEthMax / 100);
                        swapAmount = ethValueUSD - targetEthValue;
                        swapDirection = 'ETH → USDC';
                    } else if (aiConsensus) {
                        // For moderate imbalance, use consensus if available
                        recommendedAction = aiConsensus;
                        
                        // Calculate swap amount based on consensus
                        if (recommendedAction === 'BUY' && currentEthAllocation < targetEthMin) {
                            const targetEthValue = (totalValue * targetEthMin / 100);
                            swapAmount = targetEthValue - ethValueUSD;
                            swapDirection = 'USDC → ETH';
                        } else if (recommendedAction === 'SELL' && currentEthAllocation > targetEthMax) {
                            const targetEthValue = (totalValue * targetEthMax / 100);
                            swapAmount = ethValueUSD - targetEthValue;
                            swapDirection = 'ETH → USDC';
                        }
                    } else {
                        // Fall back to portfolio-based recommendation if no consensus 
                        // and no severe imbalance
                        if (currentEthAllocation < targetEthMin) {
                            recommendedAction = 'BUY';
                            const targetEthValue = (totalValue * targetEthMin / 100);
                            swapAmount = targetEthValue - ethValueUSD;
                            swapDirection = 'USDC → ETH';
                        } else if (currentEthAllocation > targetEthMax) {
                            recommendedAction = 'SELL';
                            const targetEthValue = (totalValue * targetEthMax / 100);
                            swapAmount = ethValueUSD - targetEthValue;
                            swapDirection = 'ETH → USDC';
                        }
                    }
                }
                
                // Get recommending models
                let recommendingModels = [];
                if (decisions.gemini === recommendedAction) recommendingModels.push('Gemini');
                if (decisions.groq === recommendedAction) recommendingModels.push('Groq');
                if (decisions.mistral === recommendedAction) recommendingModels.push('Mistral');
                
                const modelText = recommendingModels.length > 0 
                    ? `<div class="text-xs mt-1 text-gray-300">Recommended by: ${recommendingModels.join(', ')}</div>` 
                    : '';
                
                // Modify the portfolio allocation bar display for zero balances
                const portfolioAllocationBar = hasNonZeroBalance 
                    ? `<div class="w-full bg-gray-700 rounded-full h-2.5 mt-1 relative">
                        <div class="${getPortfolioBarColor(currentEthAllocation, targetEthMin, targetEthMax)} h-2.5 rounded-full" style="width: ${currentEthAllocation}%"></div>
                        
                        <!-- Target range indicators -->
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMin}%; height: 100%;"></div>
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMax}%; height: 100%;"></div>
                      </div>
                      <div class="flex justify-between text-xs mt-1">
                        <span>ETH: ${currentEthAllocation.toFixed(1)}%</span>
                        <span>USDC: ${currentUsdcAllocation.toFixed(1)}%</span>
                      </div>`
                    : `<div class="w-full bg-gray-700 rounded-full h-2.5 mt-1 relative">
                        <div class="bg-gray-600 h-2.5 rounded-full" style="width: 0%"></div>
                        
                        <!-- Target range indicators -->
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMin}%; height: 100%;"></div>
                        <div class="absolute top-0 bottom-0 border-l border-white opacity-50" style="left: ${targetEthMax}%; height: 100%;"></div>
                      </div>
                      <div class="flex justify-center text-xs mt-1">
                        <span class="text-gray-400">(Empty Portfolio)</span>
                      </div>`;
                
                // Recommendation section based on whether we have balances and AI decisions
                const recommendationSection = `
                    <div class="col-span-2 mt-3 mb-1 space-y-2">
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Recommended Action:</span>
                            <span class="font-bold ${
                                recommendedAction === 'BUY' ? 'text-green-400' :
                                recommendedAction === 'SELL' ? 'text-red-400' :
                                'text-blue-400'
                            }">${recommendedAction}</span>
                        </div>
                        ${recommendingModels.length > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Recommended by:</span>
                            <span class="text-gray-300">${recommendingModels.join(', ')}</span>
                        </div>
                        ` : ''}
                        ${swapAmount > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Suggested Swap:</span>
                            <span class="text-gray-300">~$${swapAmount.toFixed(2)} ${swapDirection}</span>
                        </div>
                        ` : ''}
                        ${totalValue > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Target Allocation:</span>
                            <span class="text-gray-300">${targetEthMin}%-${targetEthMax}% ETH in ${isBullish ? 'bullish' : 'bearish'} market</span>
                        </div>
                        ` : ''}
                        ${(currentEthAllocation < targetEthMin - severeImbalanceThreshold || currentEthAllocation > targetEthMax + severeImbalanceThreshold) && totalValue > 0 ? `
                        <div class="flex items-center">
                            <span class="text-gray-400 w-40">Warning:</span>
                            <span class="text-yellow-400">Portfolio significantly ${currentEthAllocation < targetEthMin ? 'below' : 'above'} target range</span>
                        </div>
                        ` : ''}
                    </div>
                `;
                
                walletCard.innerHTML = `
                    <div class="p-4">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 ${isLinea ? 'border-blue-400' : isEthereum ? 'border-indigo-400' : 'border-yellow-400'} hover:shadow-glow transition-all duration-300">
                                ${isLinea ? `
                                    <div class="network-icon-container mr-2 relative overflow-hidden">
                                        <svg class="w-5 h-5 text-blue-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(0,171,255,0.1)"/>
                                            <path d="M18.75 6.75H5.25V8.25H18.75V6.75Z" fill="currentColor"/>
                                            <path d="M18.75 11.25H5.25V12.75H18.75V11.25Z" fill="currentColor"/>
                                            <path d="M18.75 15.75H5.25V17.25H18.75V15.75Z" fill="currentColor"/>
                                        </svg>
                                        <div class="absolute inset-0 bg-gradient-to-r from-transparent via-blue-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                    </div>
                                ` : isEthereum ? `
                                    <div class="network-icon-container mr-2 relative overflow-hidden">
                                        <svg class="w-5 h-5 text-indigo-400 animate-pulse-slow" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <circle cx="12" cy="12" r="11.5" stroke="currentColor" fill="rgba(98,126,234,0.1)"/>
                                            <path d="M11.9982 4L11.8 4.4V15.1133L11.9982 15.275L16.9963 12.3L11.9982 4Z" fill="currentColor" fill-opacity="0.7"/>
                                            <path d="M12 4L7 12.3L12 15.275V10.0582V4Z" fill="currentColor"/>
                                            <path d="M11.9982 16.4826L11.9063 16.597V19.8105L11.9982 20L17 13.4264L11.9982 16.4826Z" fill="currentColor" fill-opacity="0.7"/>
                                            <path d="M12 20V16.4826L7 13.4264L12 20Z" fill="currentColor"/>
                                        </svg>
                                        <div class="absolute inset-0 bg-gradient-to-r from-transparent via-indigo-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                    </div>
                                ` : `
                                    <div class="network-icon-container mr-2 relative overflow-hidden">
                                        <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                        </svg>
                                    </div>
                                `}
                                <div class="flex flex-col">
                                    <div class="text-xs ${isLinea ? 'text-blue-400' : isEthereum ? 'text-indigo-400' : 'text-yellow-400'} font-medium network-name">${networkName}</div>
                                    <div class="flex items-center">
                                        <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                        <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>
                                <div class="text-gray-400">ETH Balance:</div>
                                <div class="font-bold text-cyber-text">${ethValue.toFixed(4)} ETH</div>
                                <div class="text-xs text-gray-400">$${(ethValue * ethPrice).toFixed(2)}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">USDC Balance:</div>
                                <div class="font-bold text-cyber-text">${usdcValue.toFixed(2)} USDC</div>
                                <div class="text-xs text-gray-400">${!isLinea && !isEthereum ? '(Only available on Linea or Ethereum)' : ''}</div>
                            </div>
                            
                            <div class="col-span-2 mt-2">
                                <div class="text-gray-400">Portfolio Allocation:</div>
                                ${portfolioAllocationBar}
                            </div>
                            
                            ${switchNetworkButtons}
                            
                            ${recommendationSection}
                        </div>
                    </div>
                `;
            }).catch(err => {
                console.warn("Error getting chain ID:", err.message);
                
                // Fallback wallet card with error state
                walletCard.innerHTML = `
                    <div class="p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            ${userAccount ? `
                            <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 border-yellow-400 hover:shadow-glow transition-all duration-300">
                                <div class="network-icon-container mr-2 relative overflow-hidden">
                                    <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                    </svg>
                                </div>
                                <div class="flex flex-col">
                                    <div class="text-xs text-yellow-400 font-medium">Connection Issue</div>
                                    <div class="flex items-center">
                                        <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                        <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        <div class="flex flex-col items-center justify-center h-24">
                            <p class="text-red-400 mb-2">Error loading wallet data</p>
                            <p class="text-xs text-gray-400 mb-2">Network error: ${err.message}</p>
                            <button onclick="getWalletBalances()" class="cyber-btn mt-2 text-xs px-3 py-1">
                                <i class="fas fa-sync-alt mr-1"></i> Retry
                            </button>
                        </div>
                    </div>
                `;
            });
        }
        
        // Function to switch networks
        async function switchNetwork(chainId) {
            if (!window.ethereum || !window.userAccount) {
                showNotification('MetaMask not connected', 'error');
                return;
            }
            
            try {
                // Show loading state first before attempting switch
                showLoadingWalletState("Switching network - please confirm in MetaMask");
                
                // First, try to switch to the network
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x' + chainId.toString(16) }],
                });
                
                // Success notification is unnecessary - users can see the network changed in the UI
                
                // Reset wallet balances to avoid stale data
                resetWalletBalances();
                
                // Wait a bit longer for MetaMask to complete the network switch
                setTimeout(async () => {
                    try {
                        // Show loading state for wallet data retrieval
                        showLoadingWalletState("Loading wallet data for new network");
                        
                        await getWalletBalances();
                        
                        // Also update model performance and LLM decision cards
                        fetchWalletStats();
                        const tradingData = await fetch('/api/trading-data').then(res => res.json());
                        updateModelDecisions(tradingData, window.userAccount);
                        
                        // Don't show notification for zero balances, just update the UI
                        if (walletBalances.totalValueUSD <= 0) {
                            updateWalletCard(); // Ensure card updates even with zero balances
                        }
                    } catch (error) {
                        logToServer('error', 'Error refreshing wallet balances after network switch', error);
                        showNotification("Error loading balances", "error");
                    }
                }, 2000); // Increased timeout to 2 seconds
                
            } catch (switchError) {
                // This error code indicates that the chain has not been added to MetaMask
                if (switchError.code === 4902) {
                    try {
                        // Show loading state for adding network
                        showLoadingWalletState("Adding network to MetaMask");
                        
                        if (chainId === 59144) {
                            // Add Linea network
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xE708',
                                    chainName: 'Linea Mainnet',
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://rpc.linea.build'],
                                    blockExplorerUrls: ['https://lineascan.build']
                                }]
                            });
                        } else if (chainId === 1) {
                            // Add Ethereum Mainnet (this is unlikely to be needed as it's usually pre-configured)
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x1',
                                    chainName: 'Ethereum Mainnet',
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://mainnet.infura.io/v3/'],
                                    blockExplorerUrls: ['https://etherscan.io']
                                }]
                            });
                        }
                        showNotification(`Added ${chainId === 59144 ? 'Linea' : 'Ethereum'} network to MetaMask`, 'success');
                        
                        // After adding the network, update model performance and LLM decision cards
                        setTimeout(async () => {
                            // Show loading state for wallet data
                            showLoadingWalletState("Loading wallet data on new network");
                            
                            fetchWalletStats();
                            const tradingData = await fetch('/api/trading-data').then(res => res.json());
                            updateModelDecisions(tradingData, userAccount);
                        }, 1000);
                    } catch (addError) {
                        logToServer('error', 'Error adding network to MetaMask', addError);
                        showNotification('Error adding network to MetaMask', 'error');
                        
                        // Restore normal wallet card state
                        updateWalletCard();
                    }
                } else {
                    logToServer('error', 'Error switching network', switchError);
                    showNotification('Error switching network. Check MetaMask.', 'error');
                    
                    // Restore normal wallet card state
                    updateWalletCard();
                }
            }
        }
        
        // Helper function to show loading state in wallet card
        function showLoadingWalletState(message) {
            const walletCard = document.getElementById('wallet-card');
            if (walletCard) {
                walletCard.innerHTML = `
                    <div class="p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                            ${userAccount ? `
                            <div class="network-address-badge flex items-center bg-cyber-dark rounded-full px-2 py-1 border border-opacity-30 border-blue-400 hover:shadow-glow transition-all duration-300">
                                <div class="network-icon-container mr-2 relative overflow-hidden">
                                    <svg class="w-5 h-5 text-blue-400 animate-pulse-slow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-blue-400 to-transparent opacity-30 blur-sm network-scan"></div>
                                </div>
                                <div class="flex flex-col">
                                    <div class="text-xs text-blue-400 font-medium">Processing</div>
                                    <div class="flex items-center">
                                        <span class="wallet-address text-xs font-mono bg-gradient-to-r from-gray-400 to-white bg-clip-text text-transparent transition-all duration-300">${userAccount.substring(0, 6)}...${userAccount.substring(38)}</span>
                                        <button onclick="copyToClipboard('${userAccount}')" class="ml-1 text-gray-400 hover:text-blue-400 transition-colors duration-200">
                                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        <div class="flex flex-col items-center justify-center h-24">
                            <p class="text-gray-400 mb-2">${message}</p>
                            <div class="spinner"><i class="fas fa-sync-alt fa-spin"></i></div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Update model stats to only show relevant operations when wallet is connected
        function updateModelStatsForWallet() {
            if (!userAccount) {
                // No wallet connected, keep using all trades
                return;
            }
            
            try {
                // Strictly validate ETH price before attempting any calculations
                if (!walletBalances.ethusd || isNaN(walletBalances.ethusd) || walletBalances.ethusd <= 0) {
                    console.log("No valid ETH price available - skipping model stats update");
                    return;
                }
                
                // Get current ETH price and portfolio values
                const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                const totalValue = walletBalances.totalValueUSD || ethValueUSD; // Fallback if totalValueUSD is 0
                
                // Skip wallet action update if we have no value
                if (totalValue <= 0) {
                    console.log("Wallet has no value, skipping wallet action update");
                    return;
                }
                
                // Get decisions from AI models - use the model's recommended action instead of portfolio-based one
                const geminiDecision = document.getElementById('gemini-decision');
                const groqDecision = document.getElementById('groq-decision');
                const mistralDecision = document.getElementById('mistral-decision');
                
                const decisions = {
                    gemini: geminiDecision ? geminiDecision.textContent : null,
                    groq: groqDecision ? groqDecision.textContent : null,
                    mistral: mistralDecision ? mistralDecision.textContent : null
                };
                
                // Check for consensus (2 out of 3 models agree)
                let walletAction = checkLLMConsensus(decisions);
                
                // If no consensus, calculate based on portfolio
                if (!walletAction) {
                    // Target allocation range: 60-80% ETH in bullish, 20-40% in bearish
                    const marketSentiment = document.getElementById('sentiment');
                    const isBullish = marketSentiment && marketSentiment.textContent.includes('bullish');
                    
                    const targetEthMin = isBullish ? 60 : 20;
                    const targetEthMax = isBullish ? 80 : 40;
                    
                    // Safely calculate ETH allocation with zero checking
                    const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                    
                    // Default to HOLD
                    walletAction = 'HOLD';
                    
                    // Only make BUY/SELL recommendations if we have some value
                    if (totalValue > 0) {
                        if (currentEthAllocation < targetEthMin) {
                            walletAction = 'BUY';
                        } else if (currentEthAllocation > targetEthMax) {
                            walletAction = 'SELL';
                        }
                    }
                }
                
                // Get current chain ID to send with the API
                window.web3.eth.getChainId().then(chainId => {
                    // Only send wallet action for supported networks
                    if (chainId !== 1 && chainId !== 59144) {
                        console.log(`Skipping wallet action on unsupported network ${chainId}`);
                        return;
                    }
                    
                    // Safely calculate ETH allocation again for the API call
                    const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                    const totalValue = walletBalances.totalValueUSD || ethValueUSD;
                    const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                    
                    // Update the API to indicate the wallet action
                    fetch('/api/set-wallet-action', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            wallet_address: window.userAccount,
                            wallet_action: walletAction,
                            eth_balance: walletBalances.eth,
                            usdc_balance: walletBalances.usdc,
                            eth_allocation: currentEthAllocation,
                            network: chainId === 59144 ? 'linea' : 'ethereum'
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.warn(`API error: ${response.status}. This is non-critical.`);
                            return null;
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data) {
                            console.log("Wallet action updated:", data);
                        }
                    })
                    .catch(error => {
                        logToServer('warn', 'Error setting wallet action (non-critical)', error);
                        // Don't show notification to avoid spamming the user
                    });
                }).catch(error => {
                    console.warn('Error getting chain ID:', error.message);
                });
            } catch (error) {
                console.warn('Error in updateModelStatsForWallet:', error.message);
            }
        }

        // showNotification function has been moved to utils.js

        // Function to get models that recommend BUY
        function getModelDecisions(decisions) {
            const modelDecisions = [];
            if (decisions.gemini === 'BUY') modelDecisions.push('Gemini');
            if (decisions.groq === 'BUY') modelDecisions.push('Groq');
            if (decisions.mistral === 'BUY') modelDecisions.push('Mistral');
            return modelDecisions;
        }

        // Function to get models that recommend SELL
        function getModelSellDecisions(decisions) {
            const modelDecisions = [];
            if (decisions.gemini === 'SELL') modelDecisions.push('Gemini');
            if (decisions.groq === 'SELL') modelDecisions.push('Groq');
            if (decisions.mistral === 'SELL') modelDecisions.push('Mistral');
            return modelDecisions;
        }

        // checkLLMConsensus function has been moved to marketAnalysis.js

        function calculateAccuracy(model) {
            const trades = tradeHistory[model];
            if (trades.length === 0) return 0;

            const correctTrades = trades.filter(trade => trade.profitable).length;
            return ((correctTrades / trades.length) * 100).toFixed(1);
        }

        function updateAccuracy(currentPrice) {
            if (lastDecisions.price !== null) {
                const priceChange = currentPrice - lastDecisions.price;
                const priceChangePercent = (priceChange / lastDecisions.price) * 100;

                // Update market volatility
                calculateVolatility(currentPrice, marketVolatility);

                // Get dynamic threshold based on market conditions
                const threshold = calculateDynamicThreshold(marketVolatility.current);

                // Update accuracy for each model
                ['gemini', 'groq', 'mistral'].forEach(model => {
                    if (lastDecisions[model]) {
                        const decision = lastDecisions[model];
                        const score = calculateTradeScore(decision, priceChangePercent, threshold);
                        
                        // Determine if the decision was correct (for raw accuracy)
                        let isCorrect = false;
                        if ((decision === 'BUY' && priceChangePercent > threshold) ||
                            (decision === 'SELL' && priceChangePercent < -threshold) ||
                            (decision === 'HOLD' && Math.abs(priceChangePercent) <= threshold)) {
                            isCorrect = true;
                        }
                        
                        // Update raw accuracy tracking
                        aiRawAccuracy[model].total++;
                        if (isCorrect) {
                            aiRawAccuracy[model].correct++;
                        }
                        aiRawAccuracy[model].accuracy = (aiRawAccuracy[model].correct / aiRawAccuracy[model].total) * 100;

                        // Record trade with enhanced metrics
                        tradeHistory[model].push({
                            timestamp: new Date(),
                            decision: decision,
                            priceChange: priceChangePercent,
                            score: score,
                            threshold: threshold,
                            volatility: marketVolatility.current,
                            price: currentPrice,
                            isCorrect: isCorrect
                        });

                        // Keep only last 100 trades for more recent performance focus
                        if (tradeHistory[model].length > 100) {
                            tradeHistory[model].shift();
                        }
                    }
                });
            }

            // Update accuracy display with weighted metrics
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                const rawAccuracyElement = document.getElementById(`${model}-raw-accuracy`);
                
                if (accuracyElement) {
                    const trades = tradeHistory[model];
                    if (trades.length > 0) {
                        // Calculate weighted average score
                        const recentTrades = trades.slice(-20); // Last 20 trades
                        const weights = recentTrades.map((_, i) => 1 + (i / recentTrades.length));
                        const totalWeight = weights.reduce((sum, w) => sum + w, 0);

                        const weightedScore = recentTrades.reduce((sum, trade, i) => 
                            sum + (trade.score * weights[i]), 0) / totalWeight;

                        const accuracy = (weightedScore * 100).toFixed(1);
                        accuracyElement.textContent = `${accuracy}%`;
                        accuracyElement.className = `font-bold ${
                            parseFloat(accuracy) >= 65 ? 'text-green-400' :
                            parseFloat(accuracy) >= 45 ? 'text-yellow-400' :
                            'text-red-400'
                        }`;
                    } else {
                        // No trades yet, show 0%
                        accuracyElement.textContent = '0.0%';
                        accuracyElement.className = 'font-bold text-gray-400';
                    }
                }
                
                // Update raw accuracy display if available - ONLY if wallet is connected
                if (rawAccuracyElement && window.userAccount && aiRawAccuracy[model].total > 0) {
                    const rawAccuracy = aiRawAccuracy[model].accuracy.toFixed(1);
                    rawAccuracyElement.textContent = `${rawAccuracy}%`;
                    rawAccuracyElement.className = `font-bold ${
                        parseFloat(rawAccuracy) >= 65 ? 'text-green-400' :
                        parseFloat(rawAccuracy) >= 45 ? 'text-yellow-400' :
                        'text-red-400'
                    }`;
                } else if (rawAccuracyElement && !window.userAccount) {
                    // If wallet is not connected, don't show any accuracy data
                    rawAccuracyElement.textContent = '0.0%';
                    rawAccuracyElement.className = 'font-bold text-xs text-gray-400';
                }
            });
        }

        // initCharts function has been moved to chartHandlers.js and is available globally via window.initCharts
        
        // updateCharts function has been moved to chartHandlers.js and is available globally via window.updateCharts

        function updateModelStats(stats) {
            // If no wallet is connected, don't update model stats
            if (!userAccount) {
                displayEmptyStats();
                return;
            }
            
            // Update detailed stats for each model
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const trades = tradeHistory[model];
                const statsContainer = document.getElementById(`${model}-stats`);
                if (statsContainer) {
                    const totalTrades = trades.length;
                    const correctTrades = trades.filter(t => t.profitable).length;
                    const incorrectTrades = totalTrades - correctTrades;

                    // Calculate decision distribution
                    const decisions = {
                        buy: trades.filter(t => t.decision === 'BUY').length,
                        sell: trades.filter(t => t.decision === 'SELL').length,
                        hold: trades.filter(t => t.decision === 'HOLD').length
                    };

                    // Calculate average price change for correct trades
                    const correctTradesAvgChange = correctTrades > 0 
                        ? (trades.filter(t => t.profitable)
                            .reduce((sum, t) => sum + t.priceChange, 0) / correctTrades).toFixed(2)
                        : 0;

                    statsContainer.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>
                                <div class="text-gray-400">Total Trades:</div>
                                <div class="font-bold text-cyber-text">${totalTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Correct Trades:</div>
                                <div class="font-bold text-green-400">${correctTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Incorrect Trades:</div>
                                <div class="font-bold text-red-400">${incorrectTrades}</div>
                            </div>
                            <div>
                                <div class="text-gray-400">Avg Profit Trades:</div>
                                <div class="font-bold ${parseFloat(correctTradesAvgChange) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                    ${correctTradesAvgChange}%
                                </div>
                            </div>
                            <div class="col-span-2">
                                <div class="text-gray-400">Decision Distribution:</div>
                                <div class="flex justify-between mt-1">
                                    <span class="text-green-400">Buy: ${decisions.buy}</span>
                                    <span class="text-red-400">Sell: ${decisions.sell}</span>
                                    <span class="text-blue-400">Hold: ${decisions.hold}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
        }

        // Update model stats display
        function updateModelStatsDisplay() {
            // Check if we need to reset daily stats
            checkDailyReset();

            // If wallet is connected, fetch wallet-specific stats
            if (window.userAccount) {
                fetchWalletStats();
                return;
            }

            // If no wallet connected, display default state with connect wallet message
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                const rawAccuracyElement = document.getElementById(`${model}-raw-accuracy`);

                if (statsContainer) {
                    statsContainer.innerHTML = `
                        <div class="text-center py-2">
                            <p class="text-gray-400 mb-2">Connect your wallet to see model performance.</p>
                            <button onclick="connectWallet()" class="cyber-btn text-xs px-3 py-1">Connect Wallet</button>
                        </div>
                    `;
                }

                if (accuracyElement) {
                    accuracyElement.textContent = '0.0%';
                    accuracyElement.className = 'font-bold text-gray-400';
                }
                
                // Also reset raw accuracy display when wallet is disconnected
                if (rawAccuracyElement) {
                    rawAccuracyElement.textContent = '0.0%';
                    rawAccuracyElement.className = 'font-bold text-xs text-gray-400';
                }
            });
        }

        // Make updateModelStatsDisplay available globally
        window.updateModelStatsDisplay = updateModelStatsDisplay;

        // Fetch wallet-specific stats from API
        function fetchWalletStats() {
            if (!userAccount) return;
            
            fetch(`/api/wallet-stats?wallet_address=${userAccount}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to fetch wallet stats');
                    }
                    return response.json();
                })
                .then(data => {
                    updateWalletModelStats(data);
                })
                .catch(error => {
                    console.error('Error fetching wallet stats:', error);
                    // Show error in stats containers
                    ['gemini', 'groq', 'mistral'].forEach(model => {
                        const statsContainer = document.getElementById(`${model}-stats`);
                        if (statsContainer) {
                            statsContainer.innerHTML = `
                                <div class="text-center py-2">
                                    <p class="text-red-400">Error loading stats: ${error.message}</p>
                                </div>
                            `;
                        }
                    });
                });
        }

        // Update model stats with wallet-specific data
        function updateWalletModelStats(walletData) {
            // Extract action distribution and statistics
            const actionDistribution = walletData.statistics?.action_distribution || { BUY: 0, SELL: 0, HOLD: 0 };
            const totalActions = walletData.statistics?.total_actions || 0;
            const profitableActions = walletData.statistics?.profitable_actions || 0;
            const accuracy = walletData.statistics?.accuracy || 0;
            const rawAccuracy = walletData.statistics?.raw_accuracy || 0;  // Add raw accuracy
            const valueChange = walletData.statistics?.total_value_change || 0;
            
            // Get model-specific stats
            const modelStats = walletData.model_stats || {};
            
            // Update each model's stats container
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                const rawAccuracyElement = document.getElementById(`${model}-raw-accuracy`);
                
                const modelStat = modelStats[model] || {
                    total_decisions: 0,
                    correct_decisions: 0,
                    accuracy: 0,
                    raw_accuracy: 0,
                    decision_counts: { BUY: 0, SELL: 0, HOLD: 0 }
                };
                
                if (statsContainer) {
                    if (modelStat.total_decisions > 0) {
                        statsContainer.innerHTML = `
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div class="col-span-2 mb-1">
                                    <div class="text-xs font-bold text-neon-blue">Your Wallet Activity</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Total Decisions:</div>
                                    <div class="font-bold text-cyber-text">${modelStat.total_decisions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Correct Decisions:</div>
                                    <div class="font-bold text-green-400">${modelStat.correct_decisions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Incorrect Decisions:</div>
                                    <div class="font-bold text-red-400">${modelStat.total_decisions - modelStat.correct_decisions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Raw Accuracy:</div>
                                    <div class="font-bold ${modelStat.raw_accuracy >= 65 ? 'text-green-400' : modelStat.raw_accuracy >= 45 ? 'text-yellow-400' : 'text-red-400'}">
                                        ${modelStat.raw_accuracy.toFixed(1)}%
                                    </div>
                                </div>
                                <div class="col-span-2">
                                    <div class="text-gray-400">Decision Distribution:</div>
                                    <div class="flex justify-between mt-1">
                                        <span class="text-green-400">Buy: ${modelStat.decision_counts.BUY}</span>
                                        <span class="text-red-400">Sell: ${modelStat.decision_counts.SELL}</span>
                                        <span class="text-blue-400">Hold: ${modelStat.decision_counts.HOLD}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        statsContainer.innerHTML = `
                            <div class="text-center py-2">
                                <p class="text-gray-400 mb-2">No trading activity yet for this wallet.</p>
                            </div>
                        `;
                    }
                }
                
                if (accuracyElement) {
                    accuracyElement.textContent = `${modelStat.accuracy.toFixed(1)}%`;
                    accuracyElement.className = `font-bold ${
                        modelStat.accuracy >= 65 ? 'text-green-400' :
                        modelStat.accuracy >= 45 ? 'text-yellow-400' :
                        'text-red-400'
                    }`;
                }
                
                if (rawAccuracyElement) {
                    rawAccuracyElement.textContent = `${modelStat.raw_accuracy.toFixed(1)}%`;
                    rawAccuracyElement.className = `font-bold text-xs ${
                        modelStat.raw_accuracy >= 65 ? 'text-green-400' :
                        modelStat.raw_accuracy >= 45 ? 'text-yellow-400' :
                        'text-red-400'
                    }`;
                }
            });
        }

        // Modified updateData function to send wallet notifications
        function updateData() {
            console.log('Fetching new data...');
            fetch('/api/trading-data')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Received data:', data);

                    // Validate ETH price first
                    const hasValidPrice = data.eth_price && !isNaN(parseFloat(data.eth_price)) && parseFloat(data.eth_price) > 0;

                    // Update metrics with proper error handling
                    try {
                        // Check if we have valid price data
                        if (hasValidPrice) {
                            document.getElementById('eth-price').textContent = `$${parseFloat(data.eth_price).toFixed(2)}`;
                            document.getElementById('eth-volume').textContent = `$${(parseFloat(data.eth_volume_24h || 0)/1e6).toFixed(2)}M`;
                            document.getElementById('eth-high').textContent = `$${parseFloat(data.eth_high_24h || 0).toFixed(2)}`;
                            document.getElementById('eth-low').textContent = `$${parseFloat(data.eth_low_24h || 0).toFixed(2)}`;
                        } else {
                            document.getElementById('eth-price').textContent = `Waiting for data...`;
                            document.getElementById('eth-volume').textContent = `Waiting for data...`;
                            document.getElementById('eth-high').textContent = `Waiting for data...`;
                            document.getElementById('eth-low').textContent = `Waiting for data...`;
                        }
                    } catch (error) {
                        console.error('Error updating price metrics:', error);
                        document.getElementById('eth-price').textContent = `Error`;
                        document.getElementById('eth-volume').textContent = `Error`;
                        document.getElementById('eth-high').textContent = `Error`;
                        document.getElementById('eth-low').textContent = `Error`;
                    }

                    // Update model decisions with error handling
                    try {
                        updateModelDecisions(data, userAccount);
                    } catch (error) {
                        console.error('Error updating model decisions:', error);
                    }

                    // Update gas price information with error handling
                    try {
                        if (data.gas_prices && 
                            data.gas_prices.low !== undefined && 
                            data.gas_prices.standard !== undefined && 
                            data.gas_prices.fast !== undefined) {
                            document.getElementById('gas-low').textContent = `${data.gas_prices.low} Gwei`;
                            document.getElementById('gas-standard').textContent = `${data.gas_prices.standard} Gwei`;
                            document.getElementById('gas-fast').textContent = `${data.gas_prices.fast} Gwei`;
                        } else {
                            document.getElementById('gas-low').textContent = `Waiting for data...`;
                            document.getElementById('gas-standard').textContent = `Waiting for data...`;
                            document.getElementById('gas-fast').textContent = `Waiting for data...`;
                        }
                    } catch (error) {
                        console.error('Error updating gas prices:', error);
                        document.getElementById('gas-low').textContent = `Error`;
                        document.getElementById('gas-standard').textContent = `Error`;
                        document.getElementById('gas-fast').textContent = `Error`;
                    }
                    
                    // Update market sentiment with error handling
                    try {
                        const sentimentText = document.getElementById('sentiment');
                        if (sentimentText && data.market_sentiment && 
                            data.market_sentiment.fear_greed_value && 
                            data.market_sentiment.fear_greed_sentiment) {
                            sentimentText.textContent = `${data.market_sentiment.fear_greed_value} (${data.market_sentiment.fear_greed_sentiment})`;
                            const sentimentClass = data.market_sentiment.fear_greed_sentiment === 'bullish'
                                ? 'bg-green-100 text-green-800'
                                : 'bg-red-100 text-red-800';

                            sentimentText.className = `px-2 py-1 rounded-full text-sm font-semibold ${sentimentClass}`;
                        } else if (sentimentText) {
                            sentimentText.textContent = `-`;
                            sentimentText.className = `px-2 py-1 rounded-full text-sm font-semibold bg-gray-100 text-gray-800`;
                        }
                    } catch (error) {
                        console.error('Error updating market sentiment:', error);
                        const sentimentText = document.getElementById('sentiment');
                        if (sentimentText) {
                            sentimentText.textContent = `Error`;
                            sentimentText.className = `px-2 py-1 rounded-full text-sm font-semibold bg-red-100 text-red-800`;
                        }
                    }

                    // Update charts with error handling
                    try {
                        if (hasValidPrice) {
                            window.updateCharts(
                                parseFloat(data.eth_price),
                                data.market_sentiment?.fear_greed_value,
                                data.gemini_action,
                                data.groq_action,
                                data.mistral_action,
                                parseFloat(data.eth_volume_24h || 0)
                            );
                        }
                    } catch (error) {
                        console.error('Error updating charts:', error);
                    }

                    // Only update model stats if wallet is connected
                    try {
                        if (userAccount && hasValidPrice && data.model_stats?.comparison) {
                            // Get wallet-specific stats instead of general stats
                            fetchWalletStats();
                        } else {
                            // Make sure model cards show connect wallet message
                            displayEmptyStats();
                        }
                    } catch (error) {
                        console.error('Error updating model stats:', error);
                        displayEmptyStats();
                    }

                    // Only persist trading history if wallet is connected
                    try {
                        if (userAccount && hasValidPrice) {
                            persistTradingHistory();
                        }
                    } catch (error) {
                        console.error('Error persisting trading history:', error);
                    }
                })
                .catch(error => {
                    console.error('Failed to fetch market data:', error);
                    document.querySelectorAll('.cyber-value').forEach(el => {
                        el.textContent = 'Error';
                        el.classList.add('text-red-500');
                    });
                });

            // If we have a wallet but no valid price, update wallet card
            if (userAccount && !hasValidPrice) {
                updateWalletCard();
            }
        }

        // Update model decisions based on wallet connection status
        function updateModelDecisions(data, walletAddress) {
            const models = ['gemini', 'groq', 'mistral'];
            const modelActions = {
                gemini: data.gemini_action,
                groq: data.groq_action,
                mistral: data.mistral_action
            };

            // First, validate ETH price data
            const hasValidPrice = data.eth_price && !isNaN(parseFloat(data.eth_price)) && parseFloat(data.eth_price) > 0;
            
            // For each model decision card
            models.forEach(model => {
                const decisionElement = document.getElementById(`${model}-decision`);
                if (!decisionElement) return;

                // First remove all classes to start fresh
                decisionElement.classList.remove('text-green-400', 'text-red-400', 'text-blue-400', 'text-gray-400', 'text-yellow-400');
                
                if (!walletAddress) {
                    // No wallet connected - show connect wallet message
                    decisionElement.innerHTML = `<span class="text-sm">Connect wallet first</span>`;
                    decisionElement.classList.add('text-gray-400');
                    return;
                }
                
                // If ETH price is invalid, show error message
                if (!hasValidPrice) {
                    decisionElement.innerHTML = `<span class="text-sm">Waiting for price data</span>`;
                    decisionElement.classList.add('text-yellow-400');
                    return;
                }

                // Wallet connected - show action and appropriate color
                const action = modelActions[model];
                
                // If no action yet (null, undefined, empty string), show "Decision in progress"
                if (!action || action === '') {
                    decisionElement.innerHTML = `<span>Decision in progress</span>`;
                    decisionElement.classList.add('text-yellow-400');
                    return;
                }
                
                // Valid action received, show the action with appropriate styling
                let actionClass = '';
                
                switch (action) {
                    case 'BUY':
                        actionClass = 'text-green-400';
                        break;
                    case 'SELL':
                        actionClass = 'text-red-400';
                        break;
                    case 'HOLD':
                        actionClass = 'text-blue-400';
                        break;
                    default:
                        actionClass = 'text-gray-400';
                }
                
                decisionElement.textContent = action;
                decisionElement.classList.add(actionClass);
                
                // Only store decisions when wallet is connected
                if (walletAddress) {
                    // Store this decision linked to the current wallet
                    storeAIDecisionForWallet(model, action, data.eth_price, walletAddress);
                }
            });

            // Check for consensus and notify if wallet is connected
            if (walletAddress && hasValidPrice) {
                const decisions = {
                    gemini: data.gemini_action,
                    groq: data.groq_action,
                    mistral: data.mistral_action
                };

                // Filter out undefined or empty decisions
                const validDecisions = {};
                for (const [model, decision] of Object.entries(decisions)) {
                    if (decision && decision !== '') {
                        validDecisions[model] = decision;
                    }
                }

                // Only check consensus if we have at least 2 valid decisions
                if (Object.keys(validDecisions).length >= 2) {
                    const consensus = checkLLMConsensus(validDecisions);
                    if (consensus && (consensus === 'BUY' || consensus === 'SELL')) {
                        const buyModels = getModelDecisions(decisions);
                        const sellModels = getModelSellDecisions(decisions);
                        const currentPrice = data.eth_price.toFixed(2);

                        let message = '';
                        if (consensus === 'BUY') {
                            message = `🟢 BUY Signal at $${currentPrice}\n`;
                            message += `Recommended by: ${buyModels.join(', ')}`;
                        } else if (consensus === 'SELL') {
                            message = `🔴 SELL Signal at $${currentPrice}\n`;
                            message += `Recommended by: ${sellModels.join(', ')}`;
                        }

                        // Show browser notification for BUY and SELL signals only
                        showNotification(message, 'info');

                        // Force wallet balance refresh with a slight delay
                        // This ensures the wallet card recommendation is updated first
                        setTimeout(() => {
                            getWalletBalances().then(() => {
                                // Send wallet notification after balances are refreshed - only for BUY and SELL
                                sendWalletNotification(consensus, message);
                            });
                        }, 500);
                    } else if (consensus === 'HOLD') {
                        // For HOLD signals, don't show any notification, just refresh wallet balances
                        console.log('HOLD signal - No notification needed');
                        
                        // Still refresh wallet balances to keep things in sync
                        getWalletBalances();
                    } else {
                        // No consensus, but still refresh wallet balances
                        getWalletBalances();
                    }
                } else {
                    console.log("Not enough valid decisions to determine consensus");
                }
            }
        }
        
        // Store AI decision for specific wallet
        async function storeAIDecisionForWallet(model, decision, price, walletAddress) {
            try {
                await fetch('/api/store-ai-decision', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        decision: decision,
                        eth_price: price,
                        wallet_address: walletAddress
                    })
                });
                console.log(`Stored ${decision} decision for ${model} model linked to wallet ${walletAddress}`);
            } catch (error) {
                console.error('Error storing AI decision for wallet:', error);
            }
        }

        // Add function to fetch daily stats
        function fetchDailyStats() {
            // If wallet is connected, only fetch wallet-specific stats
            if (userAccount) {
                fetch(`/api/wallet-stats?wallet_address=${userAccount}`)
                    .then(response => response.json())
                    .then(walletData => {
                        if (walletData && walletData.statistics) {
                            displayWalletStats(walletData);
                        } else {
                            displayEmptyStats();
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching wallet stats:', error);
                        displayEmptyStats();
                    });
                return; // Skip fetching global stats
            }
            
            // No wallet connected - display empty stats with connect wallet message
            displayEmptyStats();
        }
        
        // Display empty stats for all models
        function displayEmptyStats() {
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                const rawAccuracyElement = document.getElementById(`${model}-raw-accuracy`);
                
                if (statsContainer) {
                    statsContainer.innerHTML = `
                        <div class="text-center py-2">
                            <p class="text-gray-400 mb-2">Connect your wallet to see model performance.</p>
                        </div>
                    `;
                }
                
                if (accuracyElement) {
                    accuracyElement.textContent = '0.0%';
                    accuracyElement.className = 'font-bold text-gray-400';
                }

                // Also reset the raw accuracy element
                if (rawAccuracyElement) {
                    rawAccuracyElement.textContent = '0.0%';
                    rawAccuracyElement.className = 'font-bold text-xs text-gray-400';
                }
            });
        }
        
        // Make displayEmptyStats available globally
        window.displayEmptyStats = displayEmptyStats;

        // Display wallet-specific stats
        function displayWalletStats(walletData) {
            const stats = walletData.statistics;
            const actionDistribution = stats.action_distribution || { BUY: 0, SELL: 0, HOLD: 0 };
            
            // Display the same stats for all models since we have one wallet action that applies to all
            ['gemini', 'groq', 'mistral'].forEach(model => {
                const statsContainer = document.getElementById(`${model}-stats`);
                if (statsContainer) {
                    if (stats.total_actions > 0) {
                        statsContainer.innerHTML = `
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div class="col-span-2 mb-1">
                                    <div class="text-xs font-bold text-neon-blue">Wallet Performance</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Total Actions:</div>
                                    <div class="font-bold text-cyber-text">${stats.total_actions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Profitable:</div>
                                    <div class="font-bold text-green-400">${stats.profitable_actions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Unprofitable:</div>
                                    <div class="font-bold text-red-400">${stats.total_actions - stats.profitable_actions}</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Value Change:</div>
                                    <div class="font-bold ${parseFloat(stats.total_value_change) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                        ${stats.total_value_change.toFixed(2)}%
                                    </div>
                                </div>
                                <div class="col-span-2">
                                    <div class="text-gray-400">Action Distribution:</div>
                                    <div class="flex justify-between mt-1">
                                        <span class="text-green-400">Buy: ${actionDistribution.BUY || 0}</span>
                                        <span class="text-red-400">Sell: ${actionDistribution.SELL || 0}</span>
                                        <span class="text-blue-400">Hold: ${actionDistribution.HOLD || 0}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        statsContainer.innerHTML = `
                            <div class="text-center py-2">
                                <p class="text-gray-400 mb-2">No trading activity yet for this wallet.</p>
                            </div>
                        `;
                    }
                }
                
                // Update accuracy based on wallet performance
                const accuracyElement = document.getElementById(`${model}-accuracy`);
                if (accuracyElement) {
                    accuracyElement.textContent = `${stats.accuracy.toFixed(1)}%`;
                    accuracyElement.className = `font-bold ${
                        stats.accuracy >= 65 ? 'text-green-400' :
                        stats.accuracy >= 45 ? 'text-yellow-400' :
                        'text-red-400'
                    }`;
                }
            });
        }

        // Function to check if this is a fresh session and clear storage if needed
        function checkFreshSession() {
            const lastVisit = localStorage.getItem('stbchef_last_visit');
            const now = Date.now();
            const oneDayInMs = 24 * 60 * 60 * 1000;
            
            // If this is first visit or last visit was more than a day ago
            if (!lastVisit || (now - parseInt(lastVisit)) > oneDayInMs) {
                console.log("Fresh session detected, clearing storage");
                
                // Call backend clear-storage endpoint
                fetch('/clear-storage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Storage cleared response:", data);
                    
                    // Clear all local storage items related to the app
                    Object.values(STORAGE_KEYS).forEach(key => {
                        localStorage.removeItem(key);
                    });
                    
                    // Also clear raw accuracy data
                    localStorage.removeItem('stbchef_raw_accuracy');
                    
                    // Reset trade history variables
                    tradeHistory = {
                        gemini: [],
                        groq: [],
                        mistral: []
                    };
                    
                    // Reset raw accuracy tracking
                    aiRawAccuracy = {
                        gemini: { correct: 0, total: 0, accuracy: 0 },
                        groq: { correct: 0, total: 0, accuracy: 0 },
                        mistral: { correct: 0, total: 0, accuracy: 0 }
                    };
                    
                    // Set all accuracy elements to 0
                    ['gemini', 'groq', 'mistral'].forEach(model => {
                        const accuracyElement = document.getElementById(`${model}-accuracy`);
                        if (accuracyElement) {
                            accuracyElement.textContent = '0.0%';
                            accuracyElement.className = 'font-bold text-gray-400';
                        }
                        
                        const rawAccuracyElement = document.getElementById(`${model}-raw-accuracy`);
                        if (rawAccuracyElement) {
                            rawAccuracyElement.textContent = '0.0%';
                            rawAccuracyElement.className = 'font-bold text-xs text-gray-400';
                        }
                    });
                })
                .catch(error => console.error("Error clearing storage:", error));
            }
            
            // Update last visit timestamp
            localStorage.setItem('stbchef_last_visit', now.toString());
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing dashboard...');
            checkFreshSession(); // Check if storage needs clearing
            
            // Initialize UI with empty state first for model stats
            displayEmptyStats();
            
            // Initialize charts before any data loading
            window.initCharts();
            
            // Check for daily reset
            checkDailyReset(); 
            
            // First, load global market data (this is not wallet-dependent)
            updateData();
            
            // Set up auto-refresh every 10 minutes
            const refreshInterval = setInterval(() => {
                console.log('Auto-refresh triggered');
                updateData();
            }, 600000);  // 10 minutes

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                clearInterval(refreshInterval);
                
                // Make sure wallet connection is saved before page unloads
                if (userAccount) {
                    // Force a synchronous localStorage save before page unload
                    localStorage.setItem(STORAGE_KEYS.WALLET, userAccount);
                    
                    // Also save any pending wallet stats or model decisions
                    try {
                        localStorage.setItem(STORAGE_KEYS.TRADE_HISTORY, JSON.stringify(tradeHistory));
                        localStorage.setItem(STORAGE_KEYS.MODEL_PERFORMANCE, JSON.stringify(aiAccuracy));
                        localStorage.setItem('stbchef_raw_accuracy', JSON.stringify(aiRawAccuracy));
                        localStorage.setItem(STORAGE_KEYS.LAST_UPDATE, Date.now().toString());
                    } catch (e) {
                        // Ignore error in case localStorage is full
                        console.error('Error saving data on unload:', e);
                    }
                }
            });
        });

        // Add timeframe update function
        function updateTimeframe(timeframe) {
            // Update button styles
            document.querySelectorAll('.cyber-btn').forEach(btn => {
                btn.classList.remove('cyber-btn-active');
            });
            event.target.classList.add('cyber-btn-active');

            // Fetch new data with selected timeframe
            fetch(`/api/model-stats?timeframe=${timeframe}`)
                .then(response => response.json())
                .then(data => {
                    if (data.performance) {
                        updateModelStats(data.performance);
                    }
                    if (data.comparison) {
                        updateModelStats(data.comparison);
                    }
                })
                .catch(error => console.error('Error updating timeframe:', error));
        }

        // Filter trades from the last 24 hours
        function getRecentTrades(trades) {
            const oneDayAgo = new Date();
            oneDayAgo.setHours(oneDayAgo.getHours() - 24);
            return trades.filter(trade => new Date(trade.timestamp) > oneDayAgo);
        }

        // Check if we need to reset daily stats
        function checkDailyReset() {
            const lastReset = localStorage.getItem('last_daily_reset');
            const now = new Date();
            const today = now.toDateString();

            if (lastReset !== today) {
                // Reset daily stats for each model
                ['gemini', 'groq', 'mistral'].forEach(model => {
                    // We don't actually delete trades, just mark when we last reset
                    console.log(`Resetting daily stats for ${model}`);
                });

                // Store today's date as the last reset day
                localStorage.setItem('last_daily_reset', today);
                return true;
            }
            return false;
        }

        // Add wallet notification function
        async function sendWalletNotification(signalType, message) {
            if (!window.userAccount || !window.ethereum || !window.web3) {
                console.log("Cannot send wallet notification: no wallet connected");
                return;
            }
            
            try {
                // Only process BUY or SELL signals (skip HOLD)
                if (signalType !== 'BUY' && signalType !== 'SELL') {
                    console.log(`Skipping wallet notification for ${signalType} signal - only BUY and SELL signals get wallet notifications`);
                    return;
                }
                
                // Log that we're sending a wallet notification
                console.log(`Sending wallet notification for ${signalType} signal to ${userAccount}`);
                
                // Get current wallet balances and validate
                const ethBalance = walletBalances.eth || 0;
                const usdcBalance = walletBalances.usdc || 0;
                const currentPrice = walletBalances.ethusd || 0;
                
                // Strictly validate price data is available - NEVER use default values
                if (currentPrice <= 0 || isNaN(currentPrice)) {
                    console.log("No valid ETH price available - cannot send transaction suggestion");
                    showNotification(`${signalType} signal received but ETH price data unavailable. No transaction suggested.`, 'warning');
                    return;
                }
                
                // Get current chain ID
                const chainId = await window.web3.eth.getChainId();
                const isLinea = chainId === 59144;
                const isEthereum = chainId === 1;
                
                // Get gas price data for the transaction
                let gasPrice;
                let maxFeePerGas;
                let maxPriorityFeePerGas;
                let gasLimit = '0x5208'; // 21000 gas for standard transfer
                
                try {
                    // Fetch current gas prices from backend
                    const gasDataResponse = await fetch('/api/trading-data');
                    const gasData = await gasDataResponse.json();
                    
                    if (gasData && gasData.gas_prices) {
                        // Use the standard gas price (convert from Gwei to Wei)
                        const standardGasPriceGwei = gasData.gas_prices.standard;
                        gasPrice = window.web3.utils.toWei(standardGasPriceGwei.toString(), 'gwei');
                        
                        // For EIP-1559 compatible networks
                        if (gasData.gas_prices.base_fee) {
                            const baseFeeGwei = gasData.gas_prices.base_fee;
                            // maxFeePerGas = 2 * baseFee + priorityFee
                            const priorityFeeGwei = 1.5; // 1.5 Gwei as priority fee
                            maxPriorityFeePerGas = window.web3.utils.toWei(priorityFeeGwei.toString(), 'gwei');
                            maxFeePerGas = window.web3.utils.toWei((2 * baseFeeGwei + priorityFeeGwei).toString(), 'gwei');
                        }
                    }
                } catch (gasError) {
                    console.warn("Error fetching gas data:", gasError);
                    // Fallback gas values based on network
                    if (isEthereum) {
                        gasPrice = window.web3.utils.toWei('50', 'gwei'); // 50 Gwei fallback for Ethereum
                        maxPriorityFeePerGas = window.web3.utils.toWei('1.5', 'gwei');
                        maxFeePerGas = window.web3.utils.toWei('100', 'gwei');
                    } else if (isLinea) {
                        gasPrice = window.web3.utils.toWei('0.1', 'gwei'); // 0.1 Gwei fallback for Linea
                        maxPriorityFeePerGas = window.web3.utils.toWei('0.05', 'gwei');
                        maxFeePerGas = window.web3.utils.toWei('0.2', 'gwei');
                    } else {
                        // Use a reasonable default for other networks
                        gasPrice = window.web3.utils.toWei('30', 'gwei');
                    }
                }
                
                // Record this wallet action in the database
                await recordWalletAction(signalType);
                
                // Lower minimum transaction amount for micro-balances
                // Set minimum to the lower of 0.001 ETH or 25% of available balance (with safety check)
                const MIN_ETH_TRANSACTION = ethBalance > 0 ? Math.min(0.001, ethBalance * 0.25) : 0;
                const MIN_USDC_TRANSACTION = usdcBalance > 0 ? Math.min(0.5, usdcBalance * 0.25) : 0;
                
                console.log(`Processing ${signalType} signal with balances: ${ethBalance} ETH, ${usdcBalance} USDC`);
                console.log(`Minimum transactions: ${MIN_ETH_TRANSACTION} ETH, ${MIN_USDC_TRANSACTION} USDC`);
                
                // Create a notification message to send to the wallet
                if (signalType === 'BUY' && usdcBalance > 0) {
                    // For BUY signal, suggest using USDC to buy ETH
                    const usdcToUse = usdcBalance > 0.5 ? Math.max(usdcBalance * 0.05, MIN_USDC_TRANSACTION) : usdcBalance * 0.9;
                    
                    // Safety check: ensure values are valid
                    if (usdcToUse <= 0 || currentPrice <= 0) {
                        console.log("Invalid USDC or price values for BUY calculation");
                        showNotification(`BUY signal received - Unable to calculate conversion amounts`, 'warning');
                        return;
                    }
                    
                    const ethEquivalent = usdcToUse / currentPrice;
                    
                    // Show a notification about the suggested swap
                    showNotification(`Suggested action: Convert ${usdcToUse.toFixed(2)} USDC to approximately ${ethEquivalent.toFixed(4)} ETH`, 'info');
                    
                    // Create and send a transaction to the wallet (this will just prompt the user, not execute automatically)
                    try {
                        // Prepare transaction parameters based on network support for EIP-1559
                        let txParams = {
                            from: window.userAccount,
                            to: window.userAccount,
                            value: window.web3.utils.toHex(window.web3.utils.toWei('0.0001', 'ether')), // Small amount for visibility
                            data: window.web3.utils.toHex(message),
                            gas: gasLimit,
                        };
                        
                        // Add appropriate gas parameters based on the network
                        if (isEthereum) {
                            // Ethereum mainnet uses EIP-1559
                            if (maxFeePerGas && maxPriorityFeePerGas) {
                                txParams.maxFeePerGas = window.web3.utils.toHex(maxFeePerGas);
                                txParams.maxPriorityFeePerGas = window.web3.utils.toHex(maxPriorityFeePerGas);
                            } else {
                                txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                            }
                        } else if (isLinea) {
                            // Linea uses EIP-1559
                            if (maxFeePerGas && maxPriorityFeePerGas) {
                                txParams.maxFeePerGas = window.web3.utils.toHex(maxFeePerGas);
                                txParams.maxPriorityFeePerGas = window.web3.utils.toHex(maxPriorityFeePerGas);
                            } else {
                                txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                            }
                        } else {
                            // Fallback for other networks
                            txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                        }
                        
                        await window.ethereum.request({
                            method: 'eth_sendTransaction',
                            params: [txParams],
                        });
                        
                        console.log("Wallet notification sent successfully");
                        
                        // Update model stats after notification
                        updateModelStatsForWallet();
                        // Fetch updated wallet stats
                        fetchWalletStats();
                    } catch (txError) {
                        // User may have rejected the transaction, which is fine
                        console.log("User declined the wallet notification transaction", txError);
                    }
                    
                    return;
                } else if (signalType === 'SELL' && ethBalance > 0) {
                    // For SELL signal, suggest selling ETH for USDC
                    const ethToSell = ethBalance > 0.01 ? Math.max(ethBalance * 0.05, MIN_ETH_TRANSACTION) : ethBalance * 0.9;
                    
                    // Safety check: ensure values are valid
                    if (ethToSell <= 0 || currentPrice <= 0) {
                        console.log("Invalid ETH or price values for SELL calculation");
                        showNotification(`SELL signal received - Unable to calculate conversion amounts`, 'warning');
                        return;
                    }
                    
                    const usdcEquivalent = ethToSell * currentPrice;
                    
                    // Show a notification about the suggested swap
                    showNotification(`Suggested action: Convert ${ethToSell.toFixed(4)} ETH to approximately ${usdcEquivalent.toFixed(2)} USDC`, 'info');
                    
                    // Create and send a transaction to the wallet
                    try {
                        // Prepare transaction parameters based on network support for EIP-1559
                        let txParams = {
                            from: window.userAccount,
                            to: window.userAccount,
                            value: window.web3.utils.toHex(window.web3.utils.toWei('0.0001', 'ether')), // Small amount for visibility
                            data: window.web3.utils.toHex(message),
                            gas: gasLimit,
                        };
                        
                        // Add appropriate gas parameters based on the network
                        if (isEthereum) {
                            // Ethereum mainnet uses EIP-1559
                            if (maxFeePerGas && maxPriorityFeePerGas) {
                                txParams.maxFeePerGas = window.web3.utils.toHex(maxFeePerGas);
                                txParams.maxPriorityFeePerGas = window.web3.utils.toHex(maxPriorityFeePerGas);
                            } else {
                                txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                            }
                        } else if (isLinea) {
                            // Linea uses EIP-1559
                            if (maxFeePerGas && maxPriorityFeePerGas) {
                                txParams.maxFeePerGas = window.web3.utils.toHex(maxFeePerGas);
                                txParams.maxPriorityFeePerGas = window.web3.utils.toHex(maxPriorityFeePerGas);
                            } else {
                                txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                            }
                        } else {
                            // Fallback for other networks
                            txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                        }
                        
                        await window.ethereum.request({
                            method: 'eth_sendTransaction',
                            params: [txParams],
                        });
                        
                        console.log("Wallet notification sent successfully");
                        
                        // Update model stats after notification
                        updateModelStatsForWallet();
                        // Fetch updated wallet stats
                        fetchWalletStats();
                    } catch (txError) {
                        console.log("User declined the wallet notification transaction", txError);
                    }
                    
                    return;
                }
                
                // If we reached here, either not enough balance or just notification
                console.log(`Signal received (${signalType}), but no transaction suggestion created`);
                
                // Still try to send a simple notification transaction
                try {
                    // Prepare transaction parameters based on network support for EIP-1559
                    let txParams = {
                        from: window.userAccount,
                        to: window.userAccount,
                        value: window.web3.utils.toHex(window.web3.utils.toWei('0.0001', 'ether')), // Small amount for visibility
                        data: window.web3.utils.toHex(`${signalType} signal received - Check your portfolio allocation`),
                        gas: gasLimit,
                    };
                    
                    // Add appropriate gas parameters based on the network
                    if (isEthereum) {
                        // Ethereum mainnet uses EIP-1559
                        if (maxFeePerGas && maxPriorityFeePerGas) {
                            txParams.maxFeePerGas = window.web3.utils.toHex(maxFeePerGas);
                            txParams.maxPriorityFeePerGas = window.web3.utils.toHex(maxPriorityFeePerGas);
                        } else {
                            txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                        }
                    } else if (isLinea) {
                        // Linea uses EIP-1559
                        if (maxFeePerGas && maxPriorityFeePerGas) {
                            txParams.maxFeePerGas = window.web3.utils.toHex(maxFeePerGas);
                            txParams.maxPriorityFeePerGas = window.web3.utils.toHex(maxPriorityFeePerGas);
                        } else {
                            txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                        }
                    } else {
                        // Fallback for other networks
                        txParams.gasPrice = window.web3.utils.toHex(gasPrice);
                    }
                    
                    await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [txParams],
                    });
                    
                    console.log("General wallet notification sent successfully");
                    
                    // Update model stats after notification
                    updateModelStatsForWallet();
                    // Fetch updated wallet stats
                    fetchWalletStats();
                } catch (txError) {
                    console.log("User declined the wallet notification transaction", txError);
                }
            } catch (error) {
                logToServer('error', 'Error processing wallet notification', error);
                showNotification(`Error processing ${signalType} signal: ${error.message}`, 'error');
            }
        }
        
        // Record wallet action to the database
        async function recordWalletAction(action) {
            if (!window.userAccount) return;
            
            try {
                // Verify we have valid price data first
                if (!walletBalances.ethusd || isNaN(walletBalances.ethusd) || walletBalances.ethusd <= 0) {
                    console.warn("Cannot record wallet action: ETH price data unavailable");
                    return null;
                }
                
                // Calculate ETH allocation
                const ethValueUSD = walletBalances.eth * walletBalances.ethusd;
                const totalValue = walletBalances.totalValueUSD || ethValueUSD;
                const currentEthAllocation = totalValue > 0 ? (ethValueUSD / totalValue * 100) : 0;
                
                // Get current chain ID
                const chainId = await window.web3.eth.getChainId();
                
                // Send action to server to be recorded
                const response = await fetch('/api/set-wallet-action', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        wallet_address: window.userAccount,
                        wallet_action: action,
                        eth_balance: walletBalances.eth,
                        usdc_balance: walletBalances.usdc,
                        eth_allocation: currentEthAllocation,
                        network: chainId === 59144 ? 'linea' : 'ethereum'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log("Wallet action recorded successfully:", data);
                    return data;
                } else {
                    console.warn("Failed to record wallet action:", response.status);
                    return null;
                }
            } catch (error) {
                console.error("Error recording wallet action:", error);
                return null;
            }
        }

        // Add notification permission request
        async function requestNotificationPermission() {
            if (!window.userAccount) return;

            try {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    console.log('Notification permission granted');
                }
            } catch (error) {
                console.error('Error requesting notification permission:', error);
            }
        }

        // Function to determine portfolio bar color based on target allocation has been moved to utils.js

        // Add raw accuracy tracking
        let aiRawAccuracy = JSON.parse(localStorage.getItem('stbchef_raw_accuracy') || JSON.stringify({
            gemini: { correct: 0, total: 0, accuracy: 0 },
            groq: { correct: 0, total: 0, accuracy: 0 },
            mistral: { correct: 0, total: 0, accuracy: 0 }
        }));
        
        // Make aiRawAccuracy available globally
        window.aiRawAccuracy = aiRawAccuracy;

        // Make updateAccuracy available globally
        window.updateAccuracy = updateAccuracy;

        // copyToClipboard function has been moved to utils.js

    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <!-- Header -->
    <header class="cyber-header p-4">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center">
                <img src="static/robot.webp" alt="Trading Bot Chef Logo" class="header-logo">
                <h1 class="cyber-title text-2xl">Simple Crypto Trading Bot Chef</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="wallet-btn" onclick="connectWallet()" class="wallet-btn px-4 py-2 rounded">
                    Connect Wallet
                </button>
                <a href="https://github.com/Qbandev/stbchef" target="_blank" class="cyber-btn px-4 py-2 rounded flex items-center">
                    <i class="fab fa-github mr-2"></i>
                    GitHub
                </a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4 mt-4">
        <div class="grid grid-cols-1 gap-6">
            <!-- ETH/USDC Live Price Card (Full Width) -->
            <div class="cyber-card p-6 rounded-lg shadow mb-6">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
                    <h2 class="text-xl font-semibold cyber-title">ETH/USDC <span class="text-sm text-gray-400">Live Price</span></h2>
                    <div class="flex items-center space-x-4 mt-2 md:mt-0">
                        <div>
                            <span class="text-gray-400 text-sm">Current Price:</span>
                            <span id="eth-price" class="text-2xl font-bold ml-2 cyber-value animate-pulse">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400 text-sm">24h Vol:</span>
                            <span id="eth-volume" class="text-sm font-bold ml-2 cyber-value">-</span>
                        </div>
                    </div>
                </div>
                <!-- ETH Price Chart (Integrated) -->
                <div class="h-64 relative" id="price-chart-container">
                    <canvas id="price-chart"></canvas>
                </div>
                <!-- Price & Gas Info -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                    <!-- Price Data -->
                    <div class="flex justify-between items-center">
                        <div>
                            <span class="text-gray-400">24h High:</span>
                            <span id="eth-high" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">24h Low:</span>
                            <span id="eth-low" class="font-bold ml-1 cyber-value">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">Sentiment:</span>
                            <span id="sentiment" class="ml-1 px-2 py-0.5 rounded-full text-xs font-semibold bg-gray-700 text-gray-300">-</span>
                        </div>
                    </div>
                    <!-- Gas Prices (Linea) -->
                    <div class="flex justify-between items-center">
                        <div></div> <!-- Empty div to push content to right -->
                        <div class="flex items-center space-x-4">
                            <span class="text-gray-400">Gas Prices:</span>
                            <div class="flex space-x-4">
                                <div class="text-center">
                                    <span class="text-green-400 text-sm mr-1">Low:</span>
                                    <span id="gas-low" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-yellow-400 text-sm mr-1">Medium:</span>
                                    <span id="gas-standard" class="text-sm font-bold cyber-value">-</span>
                                </div>
                                <div class="text-center">
                                    <span class="text-red-400 text-sm mr-1">High:</span>
                                    <span id="gas-fast" class="text-sm font-bold cyber-value">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Wallet Status Card (Full Width) -->
            <div id="wallet-card" class="cyber-card rounded-lg shadow p-6 mb-6">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold cyber-title">Wallet Status</h3>
                </div>
                <div class="flex items-center justify-center h-24">
                    <div class="text-center">
                        <p class="text-gray-400 mb-2">Connect your wallet to see balances</p>
                    </div>
                </div>
            </div>
            
            <!-- AI Model Recommendations -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Gemini AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Gemini AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="gemini-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Gemini 1.5 Flash</div>
                    </div>
                </div>

                <!-- Groq AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Groq AI</h2>
                        <svg class="w-6 h-6 text-neon-purple" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="groq-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by DeepSeek-R1-Distill-Llama-70B</div>
                    </div>
                </div>

                <!-- Mistral AI Recommendation -->
                <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold cyber-title">Mistral AI</h2>
                        <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10l3.5 3.5m0-6.5L13 10m6 0l-3.5 3.5M7 10l-3.5 3.5m0-6.5L7 10m-6 0l3.5 3.5" />
                        </svg>
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Decision:</span>
                            <span id="mistral-decision" class="font-bold text-xl cyber-value animate-pulse">-</span>
                        </div>
                        <div class="text-xs text-gray-400 text-right">Powered by Mistral Large</div>
                    </div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="cyber-card rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 cyber-title">Model Performance</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Gemini Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-blue">Gemini AI</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="gemini-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="gemini-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-blue">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="gemini-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Groq Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-black to-cyber-dark mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-purple">Groq DeepSeek</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="groq-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="groq-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-purple">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="groq-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>

                    <!-- Mistral Performance -->
                    <div class="cyber-card rounded-lg shadow p-6 bg-gradient-to-br from-cyber-dark to-black mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-neon-green">Mistral AI</h3>
                            <div class="flex flex-col items-end">
                                <div class="flex items-center space-x-2">
                                    <span class="text-gray-400">Performance Score:</span>
                                    <div class="tooltip-container">
                                        <span id="mistral-accuracy" class="font-bold tooltip-trigger">0.0%</span>
                                        <div class="tooltip">
                                            Weighted score based on trade profitability and magnitude.
                                            Note: This is not raw accuracy but a weighted performance metric.
                                            Perfect score would be 100% (all decisions correct with maximum magnitude).
                                        </div>
                                    </div>
                                    <div class="tooltip-container">
                                        <i class="fas fa-info-circle text-cyber-text tooltip-trigger"></i>
                                        <div class="tooltip">
                                            Score Calculation:
• Base score (1 point) for correct direction (BUY/SELL/HOLD)
• Bonus points (up to 0.5) for magnitude of correct decision
• Recent trades weighted more heavily
• Based on last 100 trades
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-gray-400 text-xs">Raw Accuracy:</span>
                                    <span id="mistral-raw-accuracy" class="font-bold text-xs">0.0%</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-1 mt-2">
                            <span class="text-xs font-bold text-neon-green">24-Hour Activity</span>
                            <span class="text-xs text-gray-400">Reset daily at midnight</span>
                        </div>
                        <div id="mistral-stats" class="bg-cyber-dark rounded p-3"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>
</body>
</html> 
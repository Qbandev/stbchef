<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Performance Test</title>
    <link rel="icon" type="image/webp" href="static/favicon.webp">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background-color: #1a1a2e;
            color: #e2e8f0;
            font-family: 'Courier New', monospace;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: #0a0a1a;
            border: 1px solid #00f3ff;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
        }
        .model-card {
            background-color: rgba(26, 26, 46, 0.8);
            border: 1px solid #00f3ff;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        h1, h2, h3 {
            color: #00f3ff;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.7);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px 16px;
            border: 1px solid rgba(0, 243, 255, 0.3);
            text-align: left;
        }
        th {
            background-color: rgba(0, 243, 255, 0.1);
        }
        .good {
            color: #4ade80;
        }
        .moderate {
            color: #facc15;
        }
        .poor {
            color: #f87171;
        }
        .cyber-btn {
            background-color: rgba(0, 243, 255, 0.2);
            border: 1px solid #00f3ff;
            color: #00f3ff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.7);
        }
        .cyber-btn:hover {
            background-color: rgba(0, 243, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
        }
        .nav-link {
            color: #00f3ff;
            text-decoration: none;
            padding: 0.5rem 1rem;
            display: inline-block;
            border-radius: 0.25rem;
            transition: all 0.3s;
        }
        .nav-link:hover {
            background-color: rgba(0, 243, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="mb-6 flex justify-between items-center border-b border-blue-400 pb-3">
            <h1 class="text-3xl font-bold">Model Performance Testing</h1>
            <nav>
                <a href="/" class="nav-link"><i class="fas fa-home mr-2"></i>Back to Dashboard</a>
            </nav>
        </header>
        
        <div class="card">
            <h2 class="text-xl mb-4">Performance Scoring Analysis</h2>
            <p class="mb-4">This page demonstrates the comparison between raw accuracy and weighted performance scores for LLM trading models.</p>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
                <div class="model-card">
                    <h3 class="text-lg font-bold mb-2">Gemini AI</h3>
                    <table>
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Total Decisions</td>
                            <td id="gemini-total">-</td>
                        </tr>
                        <tr>
                            <td>Correct Decisions</td>
                            <td id="gemini-correct">-</td>
                        </tr>
                        <tr>
                            <td>Raw Accuracy</td>
                            <td id="gemini-raw">-</td>
                        </tr>
                        <tr>
                            <td>Performance Score</td>
                            <td id="gemini-score">-</td>
                        </tr>
                        <tr>
                            <td>Decision Distribution</td>
                            <td id="gemini-dist">-</td>
                        </tr>
                    </table>
                </div>
                
                <div class="model-card">
                    <h3 class="text-lg font-bold mb-2">Groq AI</h3>
                    <table>
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Total Decisions</td>
                            <td id="groq-total">-</td>
                        </tr>
                        <tr>
                            <td>Correct Decisions</td>
                            <td id="groq-correct">-</td>
                        </tr>
                        <tr>
                            <td>Raw Accuracy</td>
                            <td id="groq-raw">-</td>
                        </tr>
                        <tr>
                            <td>Performance Score</td>
                            <td id="groq-score">-</td>
                        </tr>
                        <tr>
                            <td>Decision Distribution</td>
                            <td id="groq-dist">-</td>
                        </tr>
                    </table>
                </div>
                
                <div class="model-card">
                    <h3 class="text-lg font-bold mb-2">Mistral AI</h3>
                    <table>
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Total Decisions</td>
                            <td id="mistral-total">-</td>
                        </tr>
                        <tr>
                            <td>Correct Decisions</td>
                            <td id="mistral-correct">-</td>
                        </tr>
                        <tr>
                            <td>Raw Accuracy</td>
                            <td id="mistral-raw">-</td>
                        </tr>
                        <tr>
                            <td>Performance Score</td>
                            <td id="mistral-score">-</td>
                        </tr>
                        <tr>
                            <td>Decision Distribution</td>
                            <td id="mistral-dist">-</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2 class="text-xl mb-4">Portfolio Recommendation Logic</h2>
            <div class="mb-4">
                <h3 class="text-lg font-bold mb-2">Current Settings</h3>
                <p>Severe imbalance threshold: <span id="threshold" class="font-medium text-white">10%</span></p>
                <p>Current ETH Allocation: <span id="allocation" class="font-medium text-white">-</span></p>
                <p>Target Range: <span id="target-range" class="font-medium text-yellow-400">-</span></p>
                <p>Consensus: <span id="consensus" class="font-medium text-purple-400">-</span></p>
                <p>Recommendation: <span id="recommendation" class="font-medium text-cyan-400">-</span></p>
            </div>
            
            <h3 class="text-lg font-bold mb-2">Test Scenarios</h3>
            <table class="mb-4">
                <tr>
                    <th>Scenario</th>
                    <th>ETH Allocation</th>
                    <th>Target Range</th>
                    <th>LLM Consensus</th>
                    <th>Expected Recommendation</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>Far Below Target</td>
                    <td>5%</td>
                    <td>20-40%</td>
                    <td>HOLD</td>
                    <td>BUY (Override)</td>
                    <td id="scenario1">-</td>
                </tr>
                <tr>
                    <td>Slightly Below Target</td>
                    <td>15%</td>
                    <td>20-40%</td>
                    <td>BUY</td>
                    <td>BUY (Use Consensus)</td>
                    <td id="scenario2">-</td>
                </tr>
                <tr>
                    <td>Within Target</td>
                    <td>30%</td>
                    <td>20-40%</td>
                    <td>BUY</td>
                    <td>BUY (Use Consensus)</td>
                    <td id="scenario3">-</td>
                </tr>
                <tr>
                    <td>Within Target</td>
                    <td>30%</td>
                    <td>20-40%</td>
                    <td>SELL</td>
                    <td>SELL (Use Consensus)</td>
                    <td id="scenario6">-</td>
                </tr>
                <tr>
                    <td>Slightly Above Target</td>
                    <td>45%</td>
                    <td>20-40%</td>
                    <td>SELL</td>
                    <td>SELL (Use Consensus)</td>
                    <td id="scenario4">-</td>
                </tr>
                <tr>
                    <td>Far Above Target</td>
                    <td>55%</td>
                    <td>20-40%</td>
                    <td>HOLD</td>
                    <td>SELL (Override)</td>
                    <td id="scenario5">-</td>
                </tr>
            </table>
            
            <h3 class="text-lg font-bold mb-2">LLM Consensus Swap Amount Tests</h3>
            <table class="mb-4">
                <tr>
                    <th>Scenario</th>
                    <th>Portfolio Value</th>
                    <th>ETH Allocation</th>
                    <th>Target Range</th>
                    <th>LLM Consensus</th>
                    <th>Expected Swap Amount</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>BUY Within Range</td>
                    <td>$1000</td>
                    <td>30%</td>
                    <td>20-40%</td>
                    <td>BUY</td>
                    <td>~$50 (Move to 35%)</td>
                    <td id="swap-test1">-</td>
                </tr>
                <tr>
                    <td>SELL Within Range</td>
                    <td>$1000</td>
                    <td>30%</td>
                    <td>20-40%</td>
                    <td>SELL</td>
                    <td>~$50 (Move to 25%)</td>
                    <td id="swap-test2">-</td>
                </tr>
                <tr>
                    <td>BUY Below Range</td>
                    <td>$1000</td>
                    <td>15%</td>
                    <td>20-40%</td>
                    <td>BUY</td>
                    <td>$50 (Move to min 20%)</td>
                    <td id="swap-test3">-</td>
                </tr>
                <tr>
                    <td>SELL Above Range</td>
                    <td>$1000</td>
                    <td>50%</td>
                    <td>20-40%</td>
                    <td>SELL</td>
                    <td>$100 (Move to max 40%)</td>
                    <td id="swap-test4">-</td>
                </tr>
            </table>
            
            <div class="flex justify-between">
                <button id="test-btn" class="cyber-btn">
                    <i class="fas fa-vial mr-2"></i>Run Test Scenarios
                </button>
                <button id="swap-test-btn" class="cyber-btn">
                    <i class="fas fa-exchange-alt mr-2"></i>Test Swap Calculations
                </button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Fetch wallet stats when page loads
            fetchWalletStats();
            
            // Add event listener for test button
            document.getElementById('test-btn').addEventListener('click', testScenarios);
            document.getElementById('swap-test-btn').addEventListener('click', testSwapCalculations);
        });
        
        async function fetchWalletStats() {
            try {
                // Get connected wallet from local storage (same key as main app)
                const wallet = localStorage.getItem('stbchef_wallet');
                if (!wallet) {
                    // Instead of alert, just set default values that can be used for testing
                    populateDefaultValues();
                    return;
                }
                
                // First fetch trading data to get market conditions
                const tradingDataResponse = await fetch('/api/trading-data');
                if (!tradingDataResponse.ok) {
                    throw new Error('Failed to fetch trading data');
                }
                const tradingData = await tradingDataResponse.json();
                
                // Then fetch wallet-specific stats
                const response = await fetch(`/api/wallet-stats?wallet_address=${wallet}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch wallet stats');
                }
                
                const data = await response.json();
                updateModelStats(data);
                
                // Update current settings with real values
                updateCurrentSettings(data, tradingData);
            } catch (error) {
                console.error('Error fetching data:', error);
                // Use default values if fetching fails
                populateDefaultValues();
            }
        }
        
        function populateDefaultValues() {
            // Set default values for testing purposes
            document.getElementById('allocation').textContent = '5.2%';
            document.getElementById('target-range').textContent = '20-40% (bearish market)';
            document.getElementById('consensus').textContent = 'BUY (2/3 models)';
            document.getElementById('recommendation').textContent = 'BUY';
            
            // Populate model cards with sample data
            const models = ['gemini', 'groq', 'mistral'];
            const sampleData = {
                gemini: { total: 42, correct: 25, raw: 59.5, score: 63.8, dist: { BUY: 15, SELL: 12, HOLD: 15 } },
                groq: { total: 38, correct: 20, raw: 52.6, score: 57.4, dist: { BUY: 18, SELL: 10, HOLD: 10 } },
                mistral: { total: 45, correct: 29, raw: 64.4, score: 68.7, dist: { BUY: 20, SELL: 15, HOLD: 10 } }
            };
            
            models.forEach(model => {
                document.getElementById(`${model}-total`).textContent = sampleData[model].total;
                document.getElementById(`${model}-correct`).textContent = sampleData[model].correct;
                
                const rawElement = document.getElementById(`${model}-raw`);
                rawElement.textContent = sampleData[model].raw + '%';
                rawElement.className = getScoreClass(sampleData[model].raw);
                
                const scoreElement = document.getElementById(`${model}-score`);
                scoreElement.textContent = sampleData[model].score + '%';
                scoreElement.className = getScoreClass(sampleData[model].score);
                
                document.getElementById(`${model}-dist`).textContent = 
                    `BUY: ${sampleData[model].dist.BUY}, SELL: ${sampleData[model].dist.SELL}, HOLD: ${sampleData[model].dist.HOLD}`;
            });
        }
        
        function updateCurrentSettings(data, tradingData) {
            // Get market sentiment information to determine target range
            const marketSentiment = tradingData.market_sentiment?.fear_greed_sentiment || 'neutral';
            const isBullish = marketSentiment.includes('bullish');
            
            const targetEthMin = isBullish ? 60 : 20;
            const targetEthMax = isBullish ? 80 : 40;
            
            // Get model decisions for consensus
            const decisions = {
                gemini: tradingData.gemini_action || 'HOLD',
                groq: tradingData.groq_action || 'HOLD',
                mistral: tradingData.mistral_action || 'HOLD'
            };
            
            // Check consensus
            const consensus = checkLLMConsensus(decisions);
            const buyVotes = Object.values(decisions).filter(d => d === 'BUY').length;
            const sellVotes = Object.values(decisions).filter(d => d === 'SELL').length;
            
            // Update the current settings elements
            document.getElementById('target-range').textContent = `${targetEthMin}-${targetEthMax}% (${isBullish ? 'bullish' : 'bearish'} market)`;
            
            if (data.statistics && data.statistics.current_allocation !== undefined) {
                document.getElementById('allocation').textContent = data.statistics.current_allocation.toFixed(1) + '%';
            } else {
                document.getElementById('allocation').textContent = '5.2%';
            }
            
            document.getElementById('consensus').textContent = consensus ? 
                `${consensus} (${consensus === 'BUY' ? buyVotes : sellVotes}/3 models)` : 
                'No consensus';
            
            // Determine recommendation based on allocation and consensus
            const currentAllocation = parseFloat(document.getElementById('allocation').textContent);
            const severeImbalanceThreshold = 10;
            
            let recommendation;
            if (currentAllocation < targetEthMin - severeImbalanceThreshold) {
                recommendation = 'BUY (severe imbalance)';
            } else if (currentAllocation > targetEthMax + severeImbalanceThreshold) {
                recommendation = 'SELL (severe imbalance)';
            } else if (consensus) {
                recommendation = `${consensus} (consensus)`;
            } else if (currentAllocation < targetEthMin) {
                recommendation = 'BUY (below target)';
            } else if (currentAllocation > targetEthMax) {
                recommendation = 'SELL (above target)';
            } else {
                recommendation = 'HOLD (within target)';
            }
            
            document.getElementById('recommendation').textContent = recommendation;
        }
        
        function checkLLMConsensus(decisions) {
            const validDecisions = Object.values(decisions).filter(d => d);
            if (validDecisions.length < 2) return null; // Need at least 2 valid decisions
            
            // Count occurrences of each action
            const counts = {
                'BUY': 0,
                'SELL': 0,
                'HOLD': 0
            };
            
            validDecisions.forEach(d => counts[d]++);
            
            // 2 out of 3 models agree (or all 3)
            const maxAction = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
            return counts[maxAction] >= 2 ? maxAction : null;
        }
        
        function updateModelStats(data) {
            const models = ['gemini', 'groq', 'mistral'];
            
            models.forEach(model => {
                const modelStats = data.model_stats[model];
                if (modelStats) {
                    document.getElementById(`${model}-total`).textContent = modelStats.total_decisions;
                    document.getElementById(`${model}-correct`).textContent = modelStats.correct_decisions;
                    
                    // Raw accuracy
                    const rawAccuracy = modelStats.raw_accuracy.toFixed(1) + '%';
                    const rawElement = document.getElementById(`${model}-raw`);
                    rawElement.textContent = rawAccuracy;
                    rawElement.className = getScoreClass(modelStats.raw_accuracy);
                    
                    // Performance score
                    const score = modelStats.accuracy.toFixed(1) + '%';
                    const scoreElement = document.getElementById(`${model}-score`);
                    scoreElement.textContent = score;
                    scoreElement.className = getScoreClass(modelStats.accuracy);
                    
                    // Decision distribution
                    const dist = modelStats.decision_counts;
                    document.getElementById(`${model}-dist`).textContent = 
                        `BUY: ${dist.BUY}, SELL: ${dist.SELL}, HOLD: ${dist.HOLD}`;
                }
            });
        }
        
        function getScoreClass(score) {
            if (score >= 65) return 'good';
            if (score >= 45) return 'moderate';
            return 'poor';
        }
        
        function testScenarios() {
            const severeImbalanceThreshold = 10; // Same as in the code
            
            // Scenario 1: Far Below Target (should override consensus)
            testRecommendation(5, 20, 40, 'HOLD', severeImbalanceThreshold, 'scenario1');
            
            // Scenario 2: Slightly Below Target (should use consensus)
            testRecommendation(15, 20, 40, 'BUY', severeImbalanceThreshold, 'scenario2');
            
            // Scenario 3: Within Target (should use consensus)
            testRecommendation(30, 20, 40, 'BUY', severeImbalanceThreshold, 'scenario3');
            
            // Scenario 6: Within Target (should use consensus)
            testRecommendation(30, 20, 40, 'SELL', severeImbalanceThreshold, 'scenario6');
            
            // Scenario 4: Slightly Above Target (should use consensus)
            testRecommendation(45, 20, 40, 'SELL', severeImbalanceThreshold, 'scenario4');
            
            // Scenario 5: Far Above Target (should override consensus)
            testRecommendation(55, 20, 40, 'HOLD', severeImbalanceThreshold, 'scenario5');
        }
        
        function testRecommendation(allocation, targetMin, targetMax, consensus, threshold, resultId) {
            let recommendation;
            
            // This is the same logic we implemented in the main app
            if (allocation < targetMin - threshold) {
                recommendation = 'BUY';
            } else if (allocation > targetMax + threshold) {
                recommendation = 'SELL';
            } else if (consensus === 'BUY' || consensus === 'SELL') {
                recommendation = consensus;
            } else {
                if (allocation < targetMin) {
                    recommendation = 'BUY';
                } else if (allocation > targetMax) {
                    recommendation = 'SELL';
                } else {
                    recommendation = 'HOLD';
                }
            }
            
            const resultElement = document.getElementById(resultId);
            resultElement.textContent = recommendation;
            
            // Highlight result based on correctness
            let expectedResult;
            switch (resultId) {
                case 'scenario1': expectedResult = 'BUY'; break;
                case 'scenario2': expectedResult = 'BUY'; break;
                case 'scenario3': expectedResult = 'BUY'; break;
                case 'scenario4': expectedResult = 'SELL'; break;
                case 'scenario5': expectedResult = 'SELL'; break;
                case 'scenario6': expectedResult = 'SELL'; break;
            }
            
            resultElement.className = recommendation === expectedResult ? 'good' : 'poor';
        }
        
        function testSwapCalculations() {
            const portfolioValue = 1000; // $1000 portfolio for tests
            const ethPrice = 3000; // Assume $3000 ETH price for simplicity
            
            // Test 1: BUY within range - should move halfway to max
            const test1 = testSwapAmount(300, 1000, 20, 40, 'BUY', ethPrice, 'swap-test1');
            
            // Test 2: SELL within range - should move halfway to min
            const test2 = testSwapAmount(300, 1000, 20, 40, 'SELL', ethPrice, 'swap-test2');
            
            // Test 3: BUY below range - should move to min target
            const test3 = testSwapAmount(150, 1000, 20, 40, 'BUY', ethPrice, 'swap-test3');
            
            // Test 4: SELL above range - should move to max target
            const test4 = testSwapAmount(500, 1000, 20, 40, 'SELL', ethPrice, 'swap-test4');
        }
        
        function testSwapAmount(ethValueUSD, totalValue, targetMin, targetMax, action, ethPrice, resultId) {
            let swapAmount = 0;
            let description = '';
            const currentEthAllocation = (ethValueUSD / totalValue) * 100;
            
            if (action === 'BUY') {
                if (currentEthAllocation >= targetMin && currentEthAllocation <= targetMax) {
                    // Within range - move halfway to max
                    const midPoint = (targetMax + currentEthAllocation) / 2;
                    const targetEthValue = (totalValue * midPoint / 100);
                    swapAmount = targetEthValue - ethValueUSD;
                    description = `$${swapAmount.toFixed(2)} (${currentEthAllocation.toFixed(1)}% → ${midPoint.toFixed(1)}%)`;
                } else if (currentEthAllocation < targetMin) {
                    // Below range - move to min
                    const targetEthValue = (totalValue * targetMin / 100);
                    swapAmount = targetEthValue - ethValueUSD;
                    description = `$${swapAmount.toFixed(2)} (${currentEthAllocation.toFixed(1)}% → ${targetMin}%)`;
                } else {
                    // Above range - no buy needed
                    swapAmount = 0;
                    description = `$0 (Already above target)`;
                }
            } else if (action === 'SELL') {
                if (currentEthAllocation >= targetMin && currentEthAllocation <= targetMax) {
                    // Within range - move halfway to min
                    const midPoint = (targetMin + currentEthAllocation) / 2;
                    const targetEthValue = (totalValue * midPoint / 100);
                    swapAmount = ethValueUSD - targetEthValue;
                    description = `$${swapAmount.toFixed(2)} (${currentEthAllocation.toFixed(1)}% → ${midPoint.toFixed(1)}%)`;
                } else if (currentEthAllocation > targetMax) {
                    // Above range - move to max
                    const targetEthValue = (totalValue * targetMax / 100);
                    swapAmount = ethValueUSD - targetEthValue;
                    description = `$${swapAmount.toFixed(2)} (${currentEthAllocation.toFixed(1)}% → ${targetMax}%)`;
                } else {
                    // Below range - no sell needed
                    swapAmount = 0;
                    description = `$0 (Already below target)`;
                }
            }
            
            const resultElement = document.getElementById(resultId);
            resultElement.textContent = description;
            
            // Calculate expected values based on our midpoint logic for BUY/SELL within range
            let expectedAmount = 0;
            
            if (resultId === 'swap-test1') {
                // BUY within range (30% → ~35%) - midpoint of 30% and 40% is 35%
                const targetValue = 1000 * 35 / 100; // $350
                expectedAmount = targetValue - 300; // $50
            } else if (resultId === 'swap-test2') {
                // SELL within range (30% → ~25%) - midpoint of 20% and 30% is 25%
                const targetValue = 1000 * 25 / 100; // $250
                expectedAmount = 300 - targetValue; // $50
            } else if (resultId === 'swap-test3') {
                // BUY below range (15% → 20%)
                const targetValue = 1000 * 20 / 100; // $200
                expectedAmount = targetValue - 150; // $50
            } else if (resultId === 'swap-test4') {
                // SELL above range (50% → 40%)
                const targetValue = 1000 * 40 / 100; // $400
                expectedAmount = 500 - targetValue; // $100
            }
            
            // Tolerance for floating point comparison
            const isClose = Math.abs(swapAmount - expectedAmount) < 5;
            resultElement.className = isClose ? 'good' : 'poor';
            
            return swapAmount;
        }
    </script>
</body>
</html> 